[
  {
    "objectID": "basic.html",
    "href": "basic.html",
    "title": "1  基础",
    "section": "",
    "text": "1.1 字面常量\n字面常量是在代码中直接写入且在程序执行过程中不会改变的固定值。\n在Python中，有几种类型的字面常量，包括：\n字面常量用于给变量赋值、进行计算和定义Python程序中的条件。\n它们提供了一种直接在代码中表示固定值的方式，使程序更易于理解和维护。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>基础</span>"
    ]
  },
  {
    "objectID": "basic.html#字面常量",
    "href": "basic.html#字面常量",
    "title": "1  基础",
    "section": "",
    "text": "数值字面常量：整数、浮点数和复数。\n字符串字面常量：用单引号（’’）或双引号（““）括起来的字符序列。\n布尔字面常量：True和False。\nNone：表示缺少值的特殊常量。\n\n\n\nx = 10  # 将整数字面常量赋值给变量\ny = 3.14  # 将浮点数字面常量赋值给变量\nname = 'John'  # 使用单引号括起来的字符串\nmessage = \"Hello, world!\"  # 使用双引号括起来的字符串\nis_active = True  # 将布尔字面常量赋值给变量\nempty_value = None  # 将None字面常量赋值给变量",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>基础</span>"
    ]
  },
  {
    "objectID": "basic.html#字符串",
    "href": "basic.html#字符串",
    "title": "1  基础",
    "section": "1.2 字符串",
    "text": "1.2 字符串\n字符串是用于表示文本数据的数据类型。\n特性：\n\n在python中，可以用单引号和双引号指定字符串。\n三引号可以指定多行字符串。\n字符串的值不可以修改。\n\n\n# 创建字符串\nname = \"Alice\"\n\n# 连接字符串\ngreeting = \"Hello, \" + name + \"!\"\n\n# 输出字符串\nprint(greeting)  # 输出：Hello, Alice!\n\n# 获取字符串长度\nlength = len(name)\nprint(length)  # 输出：5\n\n# 截取字符串\nsubstring = name[1:3]\nprint(substring)  # 输出：li\n\n# 替换字符串\nnew_name = name.replace(\"A\", \"B\")\nprint(new_name)  # 输出：Blice\n\nHello, Alice!\n5\nli\nBlice\n\n\n\n1.2.1 字符串的格式化函数\n字符串的format函数可以将相应参数传入字符串中。\n\n占位符为{}\n可以通过索引指定插入顺序，python从0开始计数。\n可以命名参数。\n\n\nname = \"Alice\"\nage = 25\n\n# 使用占位符插入变量\ngreeting = \"Hello, my name is {} and I am {} years old.\".format(name, age)\nprint(greeting)  # 输出：Hello, my name is Alice and I am 25 years old.\n\n# 可以通过索引指定插入的顺序\ngreeting2 = \"Hello, my name is {1} and I am {0} years old.\".format(age, name)\nprint(greeting2)  # 输出：Hello, my name is Alice and I am 25 years old.\n\n# 可以使用关键字参数指定插入的值\ngreeting3 = \"Hello, my name is {name} and I am {age} years old.\".format(name=\"Alice\", age=25)\nprint(greeting3)  # 输出：Hello, my name is Alice and I am 25 years old.\n\nHello, my name is Alice and I am 25 years old.\nHello, my name is Alice and I am 25 years old.\nHello, my name is Alice and I am 25 years old.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>基础</span>"
    ]
  },
  {
    "objectID": "basic.html#转义序列",
    "href": "basic.html#转义序列",
    "title": "1  基础",
    "section": "1.3 转义序列",
    "text": "1.3 转义序列\n转义序列是一种特殊的字符序列，以反斜杠（）开头，并在其后跟着一个或多个字符。用于表示非打印字符、特殊字符或具有特殊含义的字符。\n转义序列以反斜杠（）开头，后跟一个或多个字符，用于表示特定的字符或操作。通过使用转义序列，我们可以在字符串中插入这些特殊字符，而不是将它们解释为普通字符。\n转义序列的定义和特性：\n\n转义序列以反斜杠（）开头。\n转义序列由一个或多个字符组成。\n转义序列用于表示非打印字符、特殊字符或具有特殊含义的字符。\n转义序列可以在字符串、字符常量、正则表达式和其他上下文中使用。\n\n以下是一些常见的转义序列及其含义：\n\n：换行符\n制表符\n回车符\n\\’：单引号\n\\“：双引号\n\\：反斜杠\n\n\n# 在字符串中使用转义序列来表示特殊字符：\nprint(\"Hello\\tWorld\")  # 输出：Hello    World\nprint(\"I\\'m a programmer\")  # 输出：I'm a programmer\nprint(\"She said, \\\"Hello!\\\"\")  # 输出：She said, \"Hello!\"\nprint(\"\\\"I love you.\\\" \\n \\\"Me too.\\\"\")\n# 在正则表达式中使用转义序列来匹配特殊字符：\nimport re\npattern = r\"\\d+\"  # 匹配一个或多个数字\nresult = re.findall(pattern, \"12345\")\nprint(result)  # 输出：['12345']\n\nHello   World\nI'm a programmer\nShe said, \"Hello!\"\n\"I love you.\" \n \"Me too.\"\n['12345']",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>基础</span>"
    ]
  },
  {
    "objectID": "basic.html#变量",
    "href": "basic.html#变量",
    "title": "1  基础",
    "section": "1.4 变量",
    "text": "1.4 变量\n变量是 Python 中的一个概念，用于存储和操作数据。它可以存储各种类型的数据，例如整数、浮点数、字符串等。\n特性：\n\n可以通过赋值操作将数据存储到变量中。\n可以使用变量名来访问变量中存储的数据。\n变量的值可以随时修改。\n变量可以在程序的不同位置使用和传递。\n变量的作用域可以限定在特定的代码块中。\n\n\ni = 5\nprint(i)\n\ne = ( i + 1 ) * 2\n\nprint(e)\n\ns = '''This is a multi-line string.\nThis is the second line.'''\n\nprint(s)\n\n5\n12\nThis is a multi-line string.\nThis is the second line.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>基础</span>"
    ]
  },
  {
    "objectID": "basic.html#运行逻辑",
    "href": "basic.html#运行逻辑",
    "title": "1  基础",
    "section": "1.5 运行逻辑",
    "text": "1.5 运行逻辑\n\n1.5.1 逻辑行和物理行\n逻辑行是指在代码中表示一个语句或命令的行，而物理行是指在代码文件中实际占据一行的文本。\n逻辑行可以跨越多个物理行，通过使用行连接符（）将多个物理行连接成一个逻辑行。 物理行则是代码文件中的实际行数，每个物理行都以换行符（）结尾。\n逻辑行的特征：\n\n一个逻辑行可以包含一个或多个语句或命令。\n逻辑行可以跨越多个物理行。\n逻辑行以换行符（）结尾。\n\n物理行的特征：\n\n物理行是代码文件中的实际行数。\n每个物理行都以换行符（）结尾。\n\nPython鼓励每个物理行对应一个逻辑行，即每行一个语句，以保证代码的可读性。\n\n# 逻辑行跨越多个物理行的示例\nx = 1 + \\\n    2 + \\\n    3\n\nprint(x)\n\n# 逻辑行和物理行相同的示例\ny = 5\nprint(y)\n\ny = 5;\nprint(y);\n\ny = 5; print(y);\n\ny = 5; print(y)\n\n6\n5\n5\n5\n5\n\n\n\n\n1.5.2 缩进\n缩进是 Python 中的一种语法规则，用于表示代码块的层次结构。在 Python 中，缩进是强制性的，它决定了代码的执行顺序和逻辑关系。逻辑行的缩进级别决定了语句的分组，同组的语句构成一个代码块。\n基本概念：\n\n缩进是通过使用空格或制表符来实现的。\n缩进的数量和方式必须保持一致，通常建议使用四个空格进行缩进。\n缩进的层次结构决定了代码块的嵌套关系。\n\n特性：\n\n缩进用于定义函数、循环、条件语句等代码块。\n缩进可以提高代码的可读性和可维护性。\n缩进错误会导致语法错误或逻辑错误。\n\n代码示例： 以下是一个缩进构成代码块的示例：\n\ndef greet(name):\n    if name == \"Alice\":\n        print(\"Hello, Alice!\")\n    else:\n        print(\"Hello, stranger!\")\n\ngreet(\"Bob\")\n\nHello, stranger!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>基础</span>"
    ]
  },
  {
    "objectID": "operators_and_expressions.html",
    "href": "operators_and_expressions.html",
    "title": "2  运算符和表达式",
    "section": "",
    "text": "2.1 运算符",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>运算符和表达式</span>"
    ]
  },
  {
    "objectID": "operators_and_expressions.html#运算符",
    "href": "operators_and_expressions.html#运算符",
    "title": "2  运算符和表达式",
    "section": "",
    "text": "2.1.1 算术运算符：\n\n加法运算符（+）：用于将两个值相加。可以处理数值，字符串和列表等类型。\n减法运算符（-）：用于将一个值减去另一个值。如果第一个操作数缺失，默认为0。\n乘法运算符（*）：用于将两个值相乘。用于处理字符串时，则返回重复固定次数的字符串。\n除法运算符（/）：用于将一个值除以另一个值。\n取模运算符（%）：用于计算两个值相除的余数。\n幂运算符（**）：用于计算一个值的指数。\n整除运算符（//）：用于计算两个值相除的整数部分。答案会向下取整到最近的整数值；如果其中有操作数是浮点数，则答案会是浮点数。\n\n# 加法运算符\nx1 = 2 + 3\nprint(x1)\nx2 = \"a\" + \"b\"\nprint(x2)\n# 减法运算符\ny1 = 3 - 2\nprint(y1)\ny2 = - 2\nprint(y2)\n# 乘法运算符\na1 = 5 * 6\nprint(a1)\na2 = \"my\" * 6\nprint(a2)\n# 除法运算符\nb = 50 / 25\nprint(b)\n# 取模运算符\nc1 = 26 % 3\nprint(c1)\nc2 = -25.5 % 2.25\nprint(c2)\n# 幂运算符\nd= 2 ** 3\nprint(d)\n# 整除运算符\ne1 = 28 // 3\nprint(e1)\ne2 = 9//1.8\nprint(e2)\n\n\n2.1.2 比较运算符：\n\n等于运算符（==）：用于检查两个值是否相等。\n不等于运算符（!=）：用于检查两个值是否不相等。\n大于运算符（&gt;）：用于检查一个值是否大于另一个值。\n小于运算符（&lt;）：用于检查一个值是否小于另一个值。\n大于等于运算符（&gt;=）：用于检查一个值是否大于或等于另一个值。\n小于等于运算符（&lt;=）：用于检查一个值是否小于或等于另一个值。\n\na = 1 == 1\nprint(a)\nb = 1 != 1\nprint(b)\nc = 2 &gt; 1\nprint(c)\nd = 2 &lt; 1\nprint(d)\ne = 2 &gt;= 2\nprint(e)\nf = 1 &lt;= 2\nprint(f)\n\n\n2.1.3 逻辑运算符（布尔运算符）：\n\n与运算符（and）：用于检查多个条件是否同时为真。只有当所有条件都为真时，结果才为真。\n或运算符（or）：用于检查多个条件是否至少有一个为真。只要有一个条件为真，结果就为真。\n非运算符（not）：用于对条件进行取反。\n\n# 与运算符（and）：只有当所有条件都为真时，结果才为真\na = True and True\nprint(a)  # 输出：True\n\nb = True and False\nprint(b)  # 输出：False\n\n# 或运算符（or）：只要有一个条件为真，结果就为真\nc = True or False\nprint(c)  # 输出：True\n\nd = False or False\nprint(d)  # 输出：False\n\n# 非运算符（not）：对条件进行取反\ne = not True\nprint(e)  # 输出：False\n\nf = not False\nprint(f)  # 输出：True\n\n2.1.3.1 短路评估：\n当使用逻辑运算符（如and和or）连接多个条件表达式时，Python会根据运算符的特性来决定是否对所有条件进行求值。 - and运算中，只要任意一个条件为False，则整个表达式必然为False，此时Python会停止计算后面的值并立刻返回False。 - or运算中，只要任意一个条件为True，则整个表达式必然为True，此时Python会停止计算后面的值并立刻返回True。 - 短路评估可以提高代码的效率和性能，避免了不必要的运算和求值。\n# 短路评估的示例\na = 4\nb = 0\n\nif b != 0 and a / b &lt; 1:\n    print(\"条件满足\")\nelse:\n    print(\"条件不满足\")    \n在上面的示例中，通过短路评估，在b != 0这一步判断整体结果为False，进而跳过执行后面的a / b的除以0运算，避免了出现错误。如果不适用短路评估，会先判断b != 0为False，进而执行除法运算，会出现除以0错误。\n\n\n2.1.3.2 优先级\n每个运算符都有不同的优先级，其中 not 在 and 和 or 之前进行评估。括号可以用来在其他部分之前评估表达式的一部分。\n在Python中，所有的布尔运算符的优先级都低于比较运算符，比较运算符的优先级低于算术运算符。\n\n\n\n2.1.4 位运算符：\n位（bit）：存储、处理数据的最小单位。一位只能存储0或1这两个可能的值。计算机中的数字以二进制（即由0和1组成）的方式储存。\n位移：位移是用来修改数字位值的操作。位移分为左移和右移，左移是在原数右边添加一个0，右移是把最右边一位去掉。\n\n在十进制中，向左移动一位（即在尾部添加一个0）表示乘以10，向右移动一位（即去掉尾部的数字）表示除以10。\n在二进制中，向左移动一位（即在尾部添加一个0）表示乘以2，向右移动一位（即去掉尾部的数字）表示除以2。\n\n位运算符\n\n按位与运算符（&）：用于对两个值进行按位与操作。如果对应的两个二进制位都为1，则该位的结果值为1，否则0。\n按位或运算符（|）：用于对两个值进行按位或操作。如果对应的两个二进制位有一个为1，则该位的结果值为1，否则0。\n按位异或运算符（^）：用于对两个值进行按位异或操作。如果对应的两个二进制位一个为1，另一个为0，则该位结果值为1，否则0（即同为0或者同为1则结果为0）\n按位取反运算符（~）：用于对一个值进行按位取反操作。对一个二进制数按位取反，即将0变1，1变0。x的按位取反是-(x+1)。\n左移运算符（&lt;&lt;）：用于将一个值向左移动指定的位数。\n右移运算符（&gt;&gt;）：用于将一个值向右移动指定的位数。\n\n位运算符是操作二进制位的，不过在实际的编程过程中，使用并不频繁，所以在此处我只给出了简单的解释和例子。\n# 定义两个变量\na = 60  # 60的二进制表示为0011 1100\nb = 13  # 13的二进制表示为0000 1101\n\nprint(a, \"的二进制表示为\", bin(a))\nprint(b, \"的二进制表示为\", bin(b))\n\nprint(\"a & b =\", a & b)  # 按位与运算。二进制结果0000 1100，对应十进制为12\nprint(\"a | b =\", a | b)  # 按位或运算。二进制结果0011 1101，对应十进制为61\nprint(\"a ^ b =\", a ^ b)  # 按位异或运算。二进制结果0011 0001，对应十进制为49\nprint(\"~a =\", ~a)  # 按位取反运算。二进制结果1100 0011，对应十进制为-61（注意：是负数）\n\nprint(\"a &lt;&lt; 2 =\", a &lt;&lt; 2)  # 左移2位运算。二进制结果1111 0000，对应十进制为240\nprint(\"a &gt;&gt; 2 =\", a &gt;&gt; 2)  # 右移2位运算。二进制结果0000 1111，对应十进制为15\n\n\n2.1.5 赋值运算符：\n\n简单赋值运算符（=）：用于将一个值赋给一个变量。\n加法赋值运算符（+=）：用于将一个值与一个变量相加，并将结果赋给该变量。\n减法赋值运算符（-=）：用于将一个值从一个变量中减去，并将结果赋给该变量。\n乘法赋值运算符（*=）：用于将一个值与一个变量相乘，并将结果赋给该变量。\n除法赋值运算符（/=）：用于将一个值除以一个变量，并将结果赋给该变量。\n取模赋值运算符（%=）：用于计算两个值相除的余数，并将结果赋给一个变量。\n幂赋值运算符（**=）：用于计算一个值的指数，并将结果赋给一个变量。\n整除赋值运算符（//=）：用于计算两个值相除的整数部分，并将结果赋给一个变量。\n\n# 简单赋值运算符（=）\na = 10\nprint(\"a =\", a)  # 输出：a = 10\n\n# 加法赋值运算符（+=）\na += 2\nprint(\"a =\", a)  # 输出：a = 12\n\n# 减法赋值运算符（-=）\na -= 2\nprint(\"a =\", a)  # 输出：a = 10\n\n# 乘法赋值运算符（*=）\na *= 2\nprint(\"a =\", a)  # 输出：a = 20\n\n# 除法赋值运算符（/=）\na /= 2\nprint(\"a =\", a)  # 输出：a = 10.0\n\n# 取模赋值运算符（%=）\na %= 3\nprint(\"a =\", a)  # 输出：a = 1.0\n\n# 幂赋值运算符（**=）\na **= 3\nprint(\"a =\", a)  # 输出：a = 1.0\n\n# 整除赋值运算符（//=）\na = 10\na //= 3\nprint(\"a =\", a)  # 输出：a = 3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>运算符和表达式</span>"
    ]
  },
  {
    "objectID": "operators_and_expressions.html#表达式",
    "href": "operators_and_expressions.html#表达式",
    "title": "2  运算符和表达式",
    "section": "2.2 表达式",
    "text": "2.2 表达式\n表达式是由运算符和操作数组成的组合，用于计算和生成值。\n在Python中，表达式可以是简单的算术表达式，也可以是复杂的逻辑表达式。\n例如，以下是一些常见的表达式示例：\n\n算术表达式：2 + 3 * 4\n逻辑表达式：(x &gt; 5) and (y &lt; 10)\n字符串拼接表达式：‘Hello’ + ‘World’\n列表推导式：[x for x in range(10) if x % 2 == 0]\n\n表达式的值可以根据操作数的类型和运算符的规则进行计算。在计算表达式时，Python会按照一定的优先级和结合性来确定运算的顺序。\n\n2.2.1 计算顺序\n类似数学中的乘法优先级高于加法优先级，Python里的表达式也存在优先级之分。Python会先计算优先级较高的运算符和表达式，然后再计算优先级较低的表达式。\n对于复杂的表达式，虽然可以依靠记忆优先级规则来确保正确的运算顺序，但是为了代码的清晰和易读，一般建议显性地使用括号来标明运算顺序。\n在运算符具有相同的优先级时，计算顺序由它们的结合性确定。结合性可以是左结合或右结合。\n\n左结合意味着从左到右进行计算。常见的例子包括算术运算符（如加法、减法、乘法、除法等）、比较运算符和大多数位运算符。\n右结合意味着从右到左进行计算。常见的例子包括指数运算符、赋值运算符（=）和复合赋值运算符（如+=、-=、*=、/=、%=、**=、//=、&=、^=、&gt;&gt;=、&lt;&lt;=）。\n\n\n\n2.2.2 数学运算和赋值的快捷方式\n常见的做法是对变量进行数学运算，然后将运算结果赋值给变量，因此对于这种表达式有一个快捷方式。\na = 2\na = a * 3\nprint(\"a =\", a)\n\nb = 2\nb *= 3\nprint(\"b =\", b)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>运算符和表达式</span>"
    ]
  },
  {
    "objectID": "control_flow.html",
    "href": "control_flow.html",
    "title": "3  控制流",
    "section": "",
    "text": "3.1 if 语句\n条件语句允许根据条件的真假来执行不同的代码块。if 语句用于执行条件为真时的代码块，而 else 语句用于执行条件为假时的代码块。\n# 示例代码来源： A Byte of Python\n# 我们这里先定义一下猜测的值，而非通过input来获取值\n# 这是由于Quarto和Jupyter Notebook这类环境无法处理中间输入（input）\n# 这两个环境都被设计为批量执行代码的模式，一旦所有的cell开始执行，它们就能完成所有的运行，无需人工干预\n# 所以，我们这里直接设定一个值，而非通过input来获取这个值\nguess = 20  \n\nnumber = 23\n\nprint('你的猜测是：', guess)\n\nif guess == number:\n    print('恭喜你，你猜对了。')\n    print('（但你没有赢得任何奖品！）')\nelif guess &lt; number:\n    # 另一个代码块\n    print('不对，它比那个数稍微大一点')\n    # 你可以在代码块中做任何你想做的事情...\nelse:\n    print('不对，它比那个数稍微小一点')\n    # 你必须猜大于number才能到达这里\n\nprint('完成')\n# 这个最后的语句总是会被执行，\n# 在if语句执行之后。\n\n# 如果你想在其他环境（如标准Python环境或IDLE）中获得用户输入，\n# 你可以将第五行的代码改为 \"guess = int(input('请输入一个整数：'))\"。\n# 这样就能接收用户的输入作为 'guess' 的值，然后进行后续的判断。\n\n你的猜测是： 20\n不对，它比那个数稍微大一点\n完成\n示例代码中的知识点：",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>控制流</span>"
    ]
  },
  {
    "objectID": "control_flow.html#if-语句",
    "href": "control_flow.html#if-语句",
    "title": "3  控制流",
    "section": "",
    "text": "input 函数会将一个字符串打印到屏幕上并等待输入，在输入内容后，input() 函数会将输入的内容作为一个字符串返回。\nint 是一个类，在这里它用于将字符串转换为整数。如果需要转化为浮点数则用 float。\n缩进级别用于将语句分类为不同的代码块。应当遵循一致的缩进原则。\nif，elif 和 else 语句在逻辑行的末尾必须有一个冒号，后面跟着对应的代码块。\nelif 语句是将两个相关的 if else-if else 合并成一个组合的 if-elif-else 语句。可以简化程序和缩进量。\n可以在一个 if 语句里嵌套另一个 if 语句，这被称为嵌套的 if 语句。\nelif 和 else 语句是可选的。一个 if 可以在只有 if 部分的情况下生效。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>控制流</span>"
    ]
  },
  {
    "objectID": "control_flow.html#while语句",
    "href": "control_flow.html#while语句",
    "title": "3  控制流",
    "section": "3.2 while语句",
    "text": "3.2 while语句\nwhile语句允许在条件为真时重复执行一组语句。while语句是一种循环语句，可以包括一个可选的if语句。\n\n# 示例代码来源： A Byte of Python\nnumber = 23\nrunning = True\n\n# 由于我们无法在Quarto或Jupyter环境中使用input()函数，这里我们设定了一个预设的猜测值列表\nguesses = [20, 25, 23]  \nguesses_iter = iter(guesses)  # 创建一个迭代对象 \n\nwhile running:\n    # 在Quarto和Jupyter环境中，'input()' 函数需要改写为从预设列表中迭代猜测值\n    guess = next(guesses_iter)\n    print('你的猜测是：', guess)\n\n    if guess == number:\n        # 如果猜测值等于设定值，则输出猜对了，并终止while循环\n        print('恭喜你，你猜对了。')\n        running = False\n    elif guess &lt; number:\n        # 结果也会显示预设猜测值偏小\n        print('不对，它比那个数稍微大一点')\n    else:\n        # 结果也会显示预设猜测值偏大\n        print('不对，它比那个数稍微小一点')\n\nprint('完成')\n\n# 迭代器 'guesses_iter' 遍历完所有guesses后，程序就会结束\n# 在实际的Python环境或IDLE中运行时，你可以取消 'guess = next(guesses_iter)' 这一行的注释\n# 并将 'guess = int(input('请输入一个整数 : '))' 这一行注释去掉，将 'guesses' 与 'guesses_iter'注释掉\n# 这样就能通过用户输入来获取猜测值，并通过持续的while循环来实现用户的持续猜测\n\n你的猜测是： 20\n不对，它比那个数稍微大一点\n你的猜测是： 25\n不对，它比那个数稍微小一点\n你的猜测是： 23\n恭喜你，你猜对了。\n完成\n\n\n示例代码中的知识点：\n\n在 while 循环之前将变量 running 设置为 True，程序会先检查变量 running 是否为 True，然后继续执行相应的 while 块。\n执行完块之后，再次检查条件（即变量 running）。\n如果条件为真，则再次执行 while 块。\n如果条件为假，则执行可选的 else 块，然后继续下一条语句。\n如果 while 循环有一个 else 子句，除非使用 break 语句跳出循环，否则它总是会被执行。\nTrue 和 False 被称为布尔类型，可以分别视作值 1 和 0 的等价物。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>控制流</span>"
    ]
  },
  {
    "objectID": "control_flow.html#for-循环",
    "href": "control_flow.html#for-循环",
    "title": "3  控制流",
    "section": "3.3 for 循环",
    "text": "3.3 for 循环\nfor..in 语句是另一种循环语句，它遍历一个对象序列，即逐个遍历序列中的每个项目。\n就现在的进度，序列可以被视作一个有序的项目集合。\n\n# 示例代码来源： A Byte of Python\nfor i in range(1, 5):\n    print(i)\nelse:\n    print('for循环结束')\n\n1\n2\n3\n4\nfor循环结束\n\n\n示例代码中的知识点：\n\n内置函数 range 可以生成数字序列。\n默认情况下，range 的步长为 1。给 range 提供的第三个数字将成为步长，例如 range(1,5,2) 给出了 [1,3]。不包括第二个数字（即结尾数字）。\nrange 一次只生成一个数字，如果需要完整的数字列表需要调用 list()。\nfor 循环中的 else 部分是可选的。若包含，除非使用 break 语句跳出循环，否则它总是会被执行。\n尽管示例代码仅演示了数字列表，但 for 循环适用于任何类型的对象构成的序列。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>控制流</span>"
    ]
  },
  {
    "objectID": "control_flow.html#break-语句",
    "href": "control_flow.html#break-语句",
    "title": "3  控制流",
    "section": "3.4 break 语句",
    "text": "3.4 break 语句\nbreak 语句被称为跳转语句，可以停止执行循环语句，即使循环条件尚未为 False 或者项的序列尚未完全迭代完成。\n如果跳出一个 for 或 while 循环，相应的循环 else 块不会被执行。\n\n# 示例代码来源： A Byte of Python\n# 设定预设的输入列表\ninputs = ['你好', 'abcdef', '12345', '退出']\n\n# 创建一个迭代器\ninputs_iter = iter(inputs)\n\nwhile True:\n    # 从预设的输入列表中获取输入\n    s = next(inputs_iter)\n\n    print('输入的字符串是: ', s)\n    if s == '退出':\n        break\n    print('字符串的长度是', len(s))\nprint('完成')\n\n# 这里我们通过预设的输入列表和迭代器来模拟用户的输入\n# 在每次循环中，我们从列表中获取一个输入，并检查这个输入是否等于'退出'，如果是就结束循环\n# 否则，我们就输出这个输入的长度\n# 这样就可以在Quarto或Jupyter这类不支持`input()`函数的环境中运行，如果在实际的Python环境或IDLE中运行时，\n# 可以将 's = next(inputs_iter)' 这一行注释掉，将 's = input('输入点什么: ')' 这一行的注释去掉，\n# 同时将 'inputs' 与 'inputs_iter' 注释，即可恢复到原先的状态。\n\n输入的字符串是:  你好\n字符串的长度是 2\n输入的字符串是:  abcdef\n字符串的长度是 6\n输入的字符串是:  12345\n字符串的长度是 5\n输入的字符串是:  退出\n完成\n\n\n示例代码中的知识点：\n\n内置的 len 函数可以测量输入字符串的长度。\nbreak 语句也可以与 for 循环一起使用。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>控制流</span>"
    ]
  },
  {
    "objectID": "control_flow.html#continue-语句",
    "href": "control_flow.html#continue-语句",
    "title": "3  控制流",
    "section": "3.5 continue 语句",
    "text": "3.5 continue 语句\ncontinue 语句用于跳过当前循环块中的其余语句，并继续下一次循环的迭代。\n\n# 示例代码来源： A Byte of Python\n# 设定预设的输入列表\ninputs = ['你好', 'abcdef', '12', '1234', '退出']\n\n# 创建一个迭代器\ninputs_iter = iter(inputs)\n\nwhile True:\n    # 从预设的输入列表中获取输入\n    # s = input('输入点什么: ')\n    s = next(inputs_iter)\n\n    print('输入的字符串是: ', s)\n    if s == '退出':\n        break\n    if len(s) &lt; 3:\n        print('太短了')\n        continue\n    print('输入长度足够')\n    # 你可以在代码块中做任何你想做的事情...\nprint('完成')\n\n# 这段代码在Quarto和Jupyter环境下都能够顺利运行。在每次循环中，它会从预设的字符串列表中获取一个输入，然后根据这个输入的长度执行不同的操作：\n# 1. 如果输入是'退出'，那么它会结束整个循环；\n# 2. 如果输入的长度小于3，那么它会打印'太短了'，并且跳过此次循环剩下的部分，直接开始下一次循环；\n# 3. 如果输入的长度不小于3，那么它会打印'输入长度足够'。\n# 可以将 's = next(inputs_iter)' 这一行注释掉，将 's = input('输入点什么: ')' 这一行的注释去掉，\n# 同时将 'inputs' 与 'inputs_iter' 注释，即可恢复到原先的状态。\n\n输入的字符串是:  你好\n太短了\n输入的字符串是:  abcdef\n输入长度足够\n输入的字符串是:  12\n太短了\n输入的字符串是:  1234\n输入长度足够\n输入的字符串是:  退出\n完成",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>控制流</span>"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "4  函数",
    "section": "",
    "text": "4.1 函数参数\n函数可以接受参数，并利用这些值来执行某些效果。\n参数（parameter）：\n实参（argument）：\n这个概念类似于食谱和做饭。食谱上的材料列表（比如说需要多少克的面粉，多少克的糖）就像是参数列表，而你实际使用的面粉和糖的数量就像实参。\n# 示例代码来源： A Byte of Python\ndef print_max(a, b):\n    if a &gt; b:\n        print(a, 'is maximum')  # 输出 a 是最大值\n    elif a == b:\n        print(a, 'is equal to', b)  # 输出 a 等于 b\n    else:\n        print(b, 'is maximum')  # 输出 b 是最大值\n\n# 直接传递字面值\nprint_max(3, 4)\n\nx = 5\ny = 7\n\n# 将变量作为参数传递\nprint_max(x, y)\n\n4 is maximum\n7 is maximum\n在示例代码中，我们定义了一个 print_max 的函数，其中包括两个参数 a 和 b。我们使用一个 if..else 语句来找出较大的数字并将其打印出来。\n第一次调用函数 print_max 时，我们直接提供数字作为参数。在第二种情况下，我们使用变量 x，y 作为参数调用函数。 print_max(x, y) 导致参数 x 的值被赋给参数 a，参数 y 的值被赋给参数 b。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#函数参数",
    "href": "functions.html#函数参数",
    "title": "4  函数",
    "section": "",
    "text": "在定义函数时，我们为函数预留了一些位置，这些位置就是参数。参数是函数定义时的接收者。\n参数在函数头部的圆括号之间定义，用逗号分隔，它们在整个函数体内部都是可访问的。\n参数是变量，用于存储函数调用时传递的值（实参）。\n\n\n\n在调用函数时，我们会向函数中传递一些值，这些值就是实参。实参是函数调用时的输入。\n实参是赋予函数中定义的参数的具体值。同样用逗号分隔。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#局部变量",
    "href": "functions.html#局部变量",
    "title": "4  函数",
    "section": "4.2 局部变量",
    "text": "4.2 局部变量\n\n在函数定义内部声明的变量被称为“局部变量”。\n“局部变量”的有效范围被限制在声明该变量的函数内部，这种约束被称为变量的”作用域”。\n变量的作用域从其声明的位置开始，直到该代码块或函数的结束。\n即使在函数外部存在同名变量，局部变量也被视为独立的变量。无论名称是否相同，函数内部的局部变量与函数外部的变量不会有任何关联。\n\n\n# 示例代码来源： A Byte of Python\nx = 50\n\ndef func(x):\n    print('x is', x)  # 输出 x 的值\n    x = 2  # 修改局部变量 x 的值\n    print('Changed local x to', x)  # 输出修改后的 x 的值\n\n\nfunc(x)\nprint('x is still', x)  # 输出最初的 x 的值\n\nx is 50\nChanged local x to 2\nx is still 50\n\n\n第一次在函数体的第一行打印变量 x 的值时，Python 使用在函数定义之前在主块中声明的参数值。\n接下来，我们给函数中的局部变量 x 赋值为2。当我们在函数中改变局部变量 x 的值时，主块中定义的 x 不受影响。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#global-语句",
    "href": "functions.html#global-语句",
    "title": "4  函数",
    "section": "4.3 global 语句",
    "text": "4.3 global 语句\n\n当我们需要对程序整体级别（即不在函数或类等特定作用域内）定义的变量进行赋值时，我们通常会使用全局声明语句（global statement）。\n全局声明语句告诉 Python，我们正在操作的是一个全局变量，而非局部变量。\n注意，如果不使用全局声明，我们是无法在函数内部直接修改函数外部定义的变量的。\n当在函数内部引用一个未经定义的变量时，Python 会尝试在函数外部查找这个变量。\n尽管如此，我们并不推荐这一措施，因为这可能导致代码阅读者在理解这个变量的定义位置上出现困扰。\n如果要在函数内部操作函数外部的变量，推荐使用 global 声明明确指出，表明你在操纵的是在全局范围内定义的变量。\n\n\n# 示例代码来源： A Byte of Python\nx = 50\n\ndef func():\n    global x\n\n    print('x is', x)  # 输出 x 的值\n    x = 2  # 修改全局变量 x 的值\n    print('Changed global x to', x)  # 输出修改后的 x 的值\n\n\nfunc()\nprint('Value of x is', x)  # 输出最终的 x 的值\n\nx is 50\nChanged global x to 2\nValue of x is 2\n\n\nglobal 语句用于声明 x 是一个全局变量 - 因此，当我们在函数内部给 x 赋值时，当我们在主块中使用 x 的值时，这个变化会反映出来。\n可以使用相同的 global 语句指定多个全局变量，例如 global x, y, z。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#默认参数值",
    "href": "functions.html#默认参数值",
    "title": "4  函数",
    "section": "4.4 默认参数值",
    "text": "4.4 默认参数值\n我们可以通过设置默认参数值，使得某些函数参数变得可选。当用户没有显式提供参数值时，函数将会采用这些设置的默认值。\n可以通过在函数定义中，在需要设置默认值的参数名后面加上等号（=）及其默认值来实现这一点。\n\n# 示例代码来源： A Byte of Python\ndef say(message, times=1):\n    print(message * times)\n\nsay('Hello')  # 输出 \"Hello\"\nsay('World', 5)  # 输出 \"WorldWorldWorldWorldWorld\"\n\nHello\nWorldWorldWorldWorldWorld\n\n\n函数say的功能是按照我们指定的次数重复打印一个字符串。\n\n当我们没有明确指定打印次数时，该函数会默认打印一次该字符串。这是通过设置参数times的默认值为1来实现的。\n在第一种使用情况中，我们仅传入字符串参数，此时函数会默认打印一次该字符串。\n在第二种使用情况中，我们将字符串和一个数值5作为参数传入函数，此数值表示我们希望该字符串被重复打印5次。\n\n注意：\n\n只有参数列表末尾的参数才能具有默认参数值。\n即在函数的参数列表中，不能将具有默认参数值的参数放在没有默认参数值的参数之前。这是因为参数是按位置赋值的。\n例如，def func(a, b=5) 是有效的，但 def func(a=5, b) 是无效的。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#关键字参数",
    "href": "functions.html#关键字参数",
    "title": "4  函数",
    "section": "4.5 关键字参数",
    "text": "4.5 关键字参数\n\n如果你有一个带有大量参数的函数，并且你只希望指定其中的一部分参数，那么你可以使用命名参数。\n这种参数被称为关键字参数，其中参数值的指定是基于参数名称（关键字），而不是位置（这是我们之前一直使用的方式）。\n利用关键字参数，我们可以更灵活地调用函数，无需按照函数定义时参数的顺序一一对应。\n只要其他参数具有默认参数值，我们可以只给我们想要的参数赋值。\n\n\n# 示例代码来源： A Byte of Python\ndef func(a, b=5, c=10):\n    print('a is', a, 'and b is', b, 'and c is', c)\n\nfunc(3, 7)\nfunc(25, c=24)\nfunc(c=50, a=100)\n\na is 3 and b is 7 and c is 10\na is 25 and b is 5 and c is 24\na is 100 and b is 5 and c is 50\n\n\n名为func的函数有一个参数没有默认参数值，接着是两个带有默认参数值的参数。\n\n在第一种用法中，func(3, 7)，参数a获得值3，参数b获得值7，而c获得默认值10。\n在第二种用法中，变量func(25, c=24)由于参数的位置而获得值25。然后，参数c由于命名即关键字参数而获得值24。变量b获得默认值5。\n在第三种用法中，我们对所有指定的值使用关键字参数。\n需要注意的是，尽管在函数定义中，参数a在参数c之前，我们却可以先为参数c指定值，再为参数a指定值。这是关键字参数的一个特点。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#可变参数",
    "href": "functions.html#可变参数",
    "title": "4  函数",
    "section": "4.6 可变参数",
    "text": "4.6 可变参数\n可变参数是一种特殊的参数，它可以接收任意数量的参数。这在你预先不知道会有多少参数被传入函数，或者数量会变化的情况下非常有用。\n在Python中，可变参数是通过在参数前面添加星号（*）来表示的。\n\n# 示例代码来源： A Byte of Python\ndef total(a=5, *numbers, **phonebook):\n    print('a', a)\n\n    # 遍历元组中的所有项\n    for single_item in numbers:\n        print('single_item', single_item)\n\n    # 遍历字典中的所有项\n    for first_part, second_part in phonebook.items():\n        print(first_part, second_part)\n\ntotal(10, 1, 2, 3, Jack=1123, John=2231, Inge=1560) \n\na 10\nsingle_item 1\nsingle_item 2\nsingle_item 3\nJack 1123\nJohn 2231\nInge 1560\n\n\n\n当我们声明一个带星号的参数，比如 *param ，那么从该位置开始到最后的所有位置参数都会被收集成一个名为’param’的元组。\n同样地，当我们声明一个双星参数，比如 **param ，那么从那个点开始直到结尾的所有关键字参数都会被收集到一个叫做’param’的字典中。\n我们可以在函数的内部，如同访问一个普通的元组或字典一样来访问这些参数。\n一个函数只能有一个可变参数，并且必须放在所有的位置参数和默认参数之后。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#return-语句",
    "href": "functions.html#return-语句",
    "title": "4  函数",
    "section": "4.7 return 语句",
    "text": "4.7 return 语句\nreturn 语句用于从函数中返回结果或者结束函数的运行。\n在一个函数中，return 语句后面可以跟一个表达式，此表达式的值就是这个函数的返回值。\n\n# 示例代码来源： A Byte of Python\ndef maximum(x, y):\n    if x &gt; y:\n        return x\n    elif x == y:\n        return 'The numbers are equal'\n    else:\n        return y\n\nprint(maximum(2, 3)) \n\n3\n\n\n\n在这个函数中，maximum 函数使用一个简单的 if..else 语句来找到较大的值，然后返回该值。\n在这个例子中，如果我们调用maximum(2, 3)，那么这个函数的返回值就是3。\n需要注意的是，一旦 return 语句被执行，函数的运行就会立即结束，后面的代码都不会再被执行。\n请注意，一个没有值的语句等同于 return None 。在Python中， None 是一个特殊类型，表示无值。\n每个函数在结尾处都隐含有一个 return None 语句，除非你自己编写了 return 语句。\n有一个内置函数叫做 max ，已经实现了“查找最大值”的功能。所以尽可能使用这个内置函数。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "functions.html#文档字符串",
    "href": "functions.html#文档字符串",
    "title": "4  函数",
    "section": "4.8 文档字符串",
    "text": "4.8 文档字符串\n文档字符串，英文称为Docstrings，是一种在Python中对函数、方法、类、模块等提供说明的注释方式，具有非常重要的参考价值。\n文档字符串位于函数、方法、类、模块定义的第一行，由一对三引号(“““或’’’)引起来，可以是单行也可以是多行。\n\n# 示例代码来源： A Byte of Python\ndef print_max(x, y):\n    '''Prints the maximum of two numbers.\n\n    The two values must be integers.'''\n    # convert to integers, if possible\n    x = int(x)\n    y = int(y)\n\n    if x &gt; y:\n        print(x, 'is maximum')\n    else:\n        print(y, 'is maximum')\n\nprint_max(3, 5)\nprint(print_max.__doc__)\n\n5 is maximum\nPrints the maximum of two numbers.\n\n    The two values must be integers.\n\n\n\n通行的文档字符串的格式是：使用多行字符串，其中第一行以大写字母开头，以句号结尾。然后第二行为空行，接着从第三行开始提供任何详细的解释。\n强烈建议您在所有非平凡函数的文档字符串中遵循这个约定。\n在这个例子中，我们可以使用函数的 __doc__ 属性（注意双下划线）来访问 print_max 函数的文档字符串。\nPython中的 help()的作用即是获取该函数的 __doc__ 属性，并以整洁的方式呈现。可以尝试输入 help(print_max) 来查看 print_max 函数的文档字符串。\n自动化工具可以以这种方式从您的程序中检索文档。因此，强烈建议在编写任何非平凡函数时使用文档字符串。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "modules.html",
    "href": "modules.html",
    "title": "5  模块",
    "section": "",
    "text": "5.1 基本概念\n在 Python 中，模块是一种组织和重用代码的方式。一个模块是一个包含了函数、类和变量的文件，它可以被其他程序导入和使用。\n模块的基本概念是将相关的代码组织在一起，以便于维护和重用。通过将代码分割成模块，可以提高代码的可读性和可维护性。\n模块具有以下特性：\n在 Python 中，模块可以是 Python 编写的，也可以是用 C/C++ 等其他编程语言编写并编译成二进制代码的。后者通常被称为”编译的模块”，或者”扩展模块”。\n它们通常用于提高性能（因为编译后的代码运行速度更快），或者提供Python不能直接提供的功能（比如调用操作系统的底层API）。\n模块使用方法参考如下的代码示例：",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>模块</span>"
    ]
  },
  {
    "objectID": "modules.html#基本概念",
    "href": "modules.html#基本概念",
    "title": "5  模块",
    "section": "",
    "text": "封装：模块将相关的代码封装在一个单独的文件中，使得代码更加有组织和易于管理。\n命名空间：模块创建了一个独立的命名空间，避免了命名冲突。通过使用模块名作为前缀，可以访问模块中定义的函数、类和变量。\n代码重用：模块可以被其他程序导入和使用，实现了代码的重用。通过导入模块，可以直接使用模块中定义的函数、类和变量，而无需重新编写代码。\n可扩展性：模块可以根据需要进行扩展和修改。可以在模块中添加新的函数、类和变量，以满足不同的需求。\n\n\n\n\n\nimport sys\n\nprint(\"The script has the name %s\" % (sys.argv[0]))\nif len(sys.argv) &gt; 1:\n    print(\"It has some arguments:\")\n    for arg in sys.argv[1:]:\n        print(arg)\n\nprint('\\n\\nThe PYTHONPATH is', sys.path, '\\n')\n\n5.1.1 sys模块\nsys模块包含与Python解释器及其环境（即系统）相关的功能。\n\nsys.argv是Python中的一个列表，它包含了从命令行传递给Python脚本的参数。\n这些参数是以字符串的形式存储的，其中sys.argv[0]是脚本的名称（即执行的Python文件名），其余的sys.argv[1]、sys.argv[2]…依次是外部传入的参数。\n在sys模块中，可以使用点表示法访问argv变量，即sys.argv。这样可以清晰地表明argv变量是sys模块的一部分，同时避免和程序中所使用的任何argv变量冲突。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>模块</span>"
    ]
  },
  {
    "objectID": "modules.html#import-语句",
    "href": "modules.html#import-语句",
    "title": "5  模块",
    "section": "5.2 import 语句",
    "text": "5.2 import 语句\n当 Python 执行 import 语句时，Python 解释器会通过以下步骤寻找需要 import 的对象。\n\n首先，解释器会检查内建模块（built-in modules）。Python 的内建模块是用 C 编写的，并链接到 Python 解释器中。例如示例代码中使用的 sys 就是内建模块。\n如果模块不在内建模块中，Python 解释器接着会检查 sys.modules 字典。sys.modules 字典储存了所有导入模块的路径名称和模块对象。可以将其理解为 Python 已经导入模块的一个历史记录或缓存。如果模块之前已经被导入，则直接从这个字典中获取。\n如果在 sys.modules 中也找不到，Python 解释器接下来会查看 sys.path 列表。sys.path 列表包含了 Python 解释器搜索模块的位置，包括：\n\n程序执行的当前目录，即程序启动时所在的目录。运行 import os; print(os.getcwd()) 以查找程序的当前目录。\n一些 Python 的标准库目录\n额外安装的第三方包的路径。通常位于 site-packages 目录下。\n\nPython 会在 sys.path 中列出的目录从上到下按顺序搜索模块。它会检查每一个目录，看是否含有需要导入的模块。如果在所有目录中都找不到，那么 Python 会引发一个 ModuleNotFoundError。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>模块</span>"
    ]
  },
  {
    "objectID": "modules.html#字节编译的-.pyc-文件",
    "href": "modules.html#字节编译的-.pyc-文件",
    "title": "5  模块",
    "section": "5.3 字节编译的 .pyc 文件",
    "text": "5.3 字节编译的 .pyc 文件\n在 Python 中，字节编译的 .pyc 文件是一种优化技术，用于提高 Python 程序的执行速度。当 Python 解释器执行一个模块时，它会将模块的源代码编译成字节码，并将字节码保存到一个与模块同名的 .pyc 文件中。\n通常，这些 .pyc 文件在与相应的 .py 文件相同的目录中被创建。如果 Python 没有权限在该目录中写入文件，则 .pyc 文件将不会被创建。在 Python 3 中，标准库和第三方库的模块安装在 Python 的安装目录下，他们的 .pyc 文件通常被存储在 __pycache__ 目录下。\n无论是自己编写的模块还是下载的模块，只要它们被 Python 解释器执行过，都会生成相应的 .pyc 文件，以提高程序的执行速度。\n字节编译的 .pyc 文件具有以下特性：\n\n提高执行速度：由于字节码是一种中间形式，比源代码更接近机器语言，因此执行字节码比执行源代码更快。通过将模块的字节码保存到 .pyc 文件中，可以避免每次执行模块时都重新编译源代码，从而提高程序的执行速度。\n跨平台兼容性：.pyc 文件是与平台无关的，可以在不同的操作系统上执行。这意味着可以在一个平台上编译 .pyc 文件，然后将其复制到另一个平台上执行，而无需重新编译源代码。\n缓存机制：Python 解释器会检查 .pyc 文件的时间戳，以确定是否需要重新编译源代码。如果源代码没有发生变化，且 .pyc 文件的时间戳较新，解释器将直接加载 .pyc 文件，而不重新编译源代码。这种缓存机制可以减少程序启动时间和内存占用。\n可读性差：.pyc 文件是经过编译的字节码，与源代码相比，可读性较差。这是因为字节码是一种低级的、面向机器的表示形式，而源代码是面向人的高级语言。因此，通常情况下，.pyc 文件不需要手动编辑或查看。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>模块</span>"
    ]
  },
  {
    "objectID": "modules.html#from...import-语句",
    "href": "modules.html#from...import-语句",
    "title": "5  模块",
    "section": "5.4 from...import 语句",
    "text": "5.4 from...import 语句\n使用 from...import 语句可以让我们直接调用被导入的函数或者对象，不需要在前面加上模块名称。例如，我们可以直接导入 math 模块中的 sqrt 函数，这样在调用时就不需要再写 math. 了。\n这种方法的好处是我们可以只导入想用的函数或者类，不必加载整个模块，相比第一种方式可以节省一些内存。然而，如果代码中有大量的 from...import 语句，或从多个模块中导入具有相同名称的函数，那么这可能导致名字空间污染和函数冲突。\n同时，也可以使用 from...import 语句导入多个函数或者类，例如，我们导入 math 模块中的 sqrt 和 pi：\nfrom math import sqrt\nprint(sqrt(16))  # Output: 4.0\n\nfrom math import sqrt, pi\nprint(sqrt(16)) # Output: 4.0\nprint(pi)       # Output: 3.141592653589793",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>模块</span>"
    ]
  },
  {
    "objectID": "modules.html#python模块的-__name__-属性",
    "href": "modules.html#python模块的-__name__-属性",
    "title": "5  模块",
    "section": "5.5 Python模块的 __name__ 属性",
    "text": "5.5 Python模块的 __name__ 属性\n在 Python 中，每个模块都有一个内置的属性 __name__ ，这个属性对于理解模块的加载方式、以及模块与运行脚本的区别非常重要。\n当直接运行一个 py 文件（比如命令行执行 python your_script.py ）时，Python会把 __name__ 属性自动置为 __main__ 。在这种情况下，我们说 your_script.py 是作为一个脚本运行的。\n但是，如果你导入这个 py 文件作为一个模块（比如在另一个 py 文件中使用 import your_script ），那么Python会把 __name__ 属性自动置为模块的名称（这里的例子中就是 your_script ）。在这种情况下，我们说 your_script.py 是被导入的模块。\n参加如下的示例代码：\nif __name__ == '__main__':\n    print('This program is being run by itself')\nelse:\n    print('I am being imported from another module')\n根据以上的属性，许多 Python 脚本（尤其是那些同时被作为模块和脚本运行的脚本）都会在文件末尾包含以下代码：\nif __name__ == \"__main__\":\n    run_my_script()\n其中，run_my_script() 是该脚本中定义的一个函数。这段代码的目的是：\n\n如果你直接运行这个 py 文件，Python 会执行 run_my_script() 函数；\n如果你把这个 py 文件作为模块导入，Python 不会执行 run_my_script() 函数。\n\n这种方法允许一个 Python 模块同时被安全地导入并独立运行，是 Python 编程中一个常见且实用的技巧。\n总的来说，Python 的 __name__ 属性作为一个内建的模块属性，通过它可以有效区分脚本的直接执行和模块的导入调用，对理解和控制 Python 代码流程有着重要作用。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>模块</span>"
    ]
  },
  {
    "objectID": "modules.html#制作自己的模块",
    "href": "modules.html#制作自己的模块",
    "title": "5  模块",
    "section": "5.6 制作自己的模块",
    "text": "5.6 制作自己的模块\n在 Python 中，任何一个 Python 文件都可以被视为一个模块，只需要按照一定的格式组织你的代码，然后将其保存为以 .py 结尾的文件即可。\n导入模块时，Python 解释器会在几个特定的目录中寻找模块文件，这些目录的路径存储在 sys.path 列表中。如果你的模块位于这些目录之外的路径，需要将模块的路径添加到系统路径中，如下面的示例代码所示：\n# 示例代码来源： A Byte of Python\nimport sys\nsys.path.append(\"practical_code/modules\") # 将模块的路径添加到系统路径中\n\nimport mymodule\n\nmymodule.say_hi()\nprint('Version', mymodule.__version__)\n使用 from..import 语句的示例代码如下：\n# 示例代码来源： A Byte of Python\nimport sys\nsys.path.append(\"practical_code/modules\") #\n\nfrom mymodule import say_hi, __version__\n\nsay_hi()\nprint('Version', __version__)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>模块</span>"
    ]
  },
  {
    "objectID": "modules.html#dir-函数",
    "href": "modules.html#dir-函数",
    "title": "5  模块",
    "section": "5.7 dir 函数",
    "text": "5.7 dir 函数\ndir 函数是 Python 内置函数之一，用于返回一个对象的属性和方法列表。 它接受一个可选的参数，该参数是一个对象或模块的名称。如果直接使用 dir() 并且不提供任何参数，则返回当前作用域中能访问到的所有变量、函数、类等的名称。\n基本概念： - 对象：在 Python 中，一切皆为对象，包括数字、字符串、列表、函数等。对象 - 属性：对象的特征或数据，可以通过点运算符访问。 - 方法：对象的行为或功能，可以通过点运算符调用。\n特性： - dir 函数返回的列表包含了对象或模块的所有属性和方法的名称。 - 返回的列表是无序的，不保证属性和方法的顺序。 - dir 函数只返回公共的属性和方法，不包括私有的属性和方法。 - 如果参数是一个模块的名称，dir 函数返回的列表包含了该模块的所有公共属性和方法的名称。 - 如果参数是一个对象，dir 函数返回的列表包含了该对象的所有属性和方法的名称。\na = 5\n# 调用dir()函数，打印当前全局作用域的所有名称\nprint(dir())\n\n# 使用del语句删除变量a\ndel a\n\n# 再次调用dir()函数\nprint(dir()) # 这一次，返回的列表中将不再包含 'a'，因为我们已经删除了 a 这个变量\n\n# 使用dir()函数查看sys的所有属性和方法\nimport sys\ndir(sys)\n\ndef my_function():\n    \"\"\"\n    This is a sample function.\n    \"\"\"\n    pass\n\n# 使用dir()函数查看my_function的所有属性和方法\nprint(dir(my_function))\n\ndir() 函数在无参数调用时，返回的是当前范围内的变量、方法和定义的类型列表。\n当创建新的变量或者方法，他们会被添加到这个列表中；当删除变量或者方法，他们则会从这个列表中消失。\n当 dir() 函数以模块名或函数作为参数调用，例如 dir(sys)，它会返回包含模块或函数所有属性和方法的名字的列表。\n调用 dir() 函数来查看一个自定义模块或函数的属性和方法，它会返回包括以下属性的列表：\n\n__doc__：这是模块或函数的文档字符串，即在你定义它时用三引号包裹的那段描述文本。\n__name__：这是模块或函数的名称。\n\n对于模块，如果直接运行这个模块的话，__name__ 的值会是 ‘main’ 。如果这个模块是被其他程序导入的，__name__ 则会等于模块自身的名字。\n对于函数，__name__ 属性是函数的名称。\n\n__module__：__module__ 属性只有函数对象才有，它代表的是定义这个函数的模块名。\n\n在主程序中定义的函数，__module__ 通常为’main’；\n在被导入的模块中定义的函数，__module__ 则会是那个模块的名字。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>模块</span>"
    ]
  },
  {
    "objectID": "modules.html#包",
    "href": "modules.html#包",
    "title": "5  模块",
    "section": "5.8 包",
    "text": "5.8 包\n在 Python 中，包（Package）是一种组织和管理 Python 模块（Module）的方式。可以简单地将其视为包含一个或多个 Python 模块的文件夹。\n一个 Python 包可能包含 Python 模块、其他子包、或者一些附属的文件（如文档、数据文件等）。Python 包的主要目标是提供一种方便的方式来组织和共享一组相关功能的代码。\n通常，一个 Python 包中会有一个特殊文件 __init__.py，它用于标记所在目录是一个 Python 包，可以包含一些初始化代码或者指定包的特定属性。然而，从 Python 3.3开始，也支持所谓的隐式命名空间包，不再强制要求包中必须有 __init__.py 文件。\n代码示例：\n假如我们有以下目录结构：\nmy_package/\n├── __init__.py\n├── module1.py\n└── sub_package/\n    ├── __init__.py\n    └── module2.py\n    \n在这个结构中，my_package 是一个 Python 包，它包含一个模块 module1 和一个子包 sub_package。sub_package 也是 Python 包，并且它包含一个模块 module2.py。\n假设在 module1.py 中，我们定义了一个函数 func1，在 module2.py 中，我们定义了一个函数func2。\n# 文件路径: my_package/module1.py\n\ndef func1():\n    print(\"This is function 1 from module 1\")\n\n# 文件路径: my_package/sub_package/module2.py\n\ndef func2():\n    print(\"This is function 2 from module 2\")    \n在 Python 中，我们可以使用以下方法导入和使用这些函数：\nimport sys\nsys.path.append(\"practical_code/modules\") #将包的路径添加到系统路径中\n\n# 导入 my_package 包中的 module1 模块\nimport my_package.module1\n\n# 调用 module1 中的函数 func1\nmy_package.module1.func1()  # Outputs: This is function 1 from module 1\n\n# 导入 sub_package 包中的 module2 模块\nimport my_package.sub_package.module2\n\n# 调用 module2 中的函数 func2\nmy_package.sub_package.module2.func2()  # Outputs: This is function 2 from module 2",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>模块</span>"
    ]
  },
  {
    "objectID": "data_structures.html",
    "href": "data_structures.html",
    "title": "6  数据结构",
    "section": "",
    "text": "6.1 序列（Sequence）\n在Python中，序列(Sequence)是最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。\nPython有三种常见的序列类型：\n另外三种非序列的数据结构是：\n这三种类型并非有序，也不能通过索引访问元素。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "data_structures.html#序列sequence",
    "href": "data_structures.html#序列sequence",
    "title": "6  数据结构",
    "section": "",
    "text": "列表（List）\n元组（Tuple）\n字符串（String）\n\n\n\n集合（Set）\n字典（Dictionary）\n冰冻集合（frozenset）",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "data_structures.html#列表list",
    "href": "data_structures.html#列表list",
    "title": "6  数据结构",
    "section": "6.2 列表（List）",
    "text": "6.2 列表（List）\nPython 的列表类似于其他编程语言中的数组，但是比这些数组更灵活。列表中的元素不一定要是相同的数据类型。\n列表用方括号 [] 包围元素，并用逗号 , 分割。\n\nmy_list = [1, \"apple\", 3.14]\nprint(my_list[0]) # prints: 1\n\n1\n\n\n列表：\n\n是有序的\n是可变的\n可以包含任何类型的元素\n可以通过索引访问元素，索引从0开始\n\n\n\n\n\n\n\n索引\n\n\n\n注意, Python的索引是从0开始。这意味着在使用索引访问列表元素时，列表中的第一个元素是 list[0]，第二个元素是 list[1]，以此类推。\n此外，索引是前包含后不包含的。word[1:3]这样的索引意味着从索引1开始，直到索引3之前的元素（即索引1和2）。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "data_structures.html#元组tuple",
    "href": "data_structures.html#元组tuple",
    "title": "6  数据结构",
    "section": "6.3 元组（Tuple）",
    "text": "6.3 元组（Tuple）\n元组是有序的、不可变的列表。可以理解为一种“只读”版本的列表。\n元组用括号 () 包围元素，并用逗号 , 分割。\n\nmy_tuple = (1, \"apple\", 3.14)\nprint(my_tuple[0]) # prints: 1\n\n1\n\n\n元组：\n\n是有序的\n是不可变的\n可以包含任何类型的元素\n可以通过索引访问元素，索引从0开始\n\n下面是一个体现元组和列表的差别的代码示例\n\n# 创建一个列表\nmy_list = [1, 2, 3]\n# 在列表末尾添加一个元素\nmy_list.append(4)\nprint(my_list[3])\n# 创建一个元组\nmy_tuple = (1, 2, 3)\n# 不能修改元组\n# my_tuple.append(4)  # 这样会报错\n\n4",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "data_structures.html#集合set",
    "href": "data_structures.html#集合set",
    "title": "6  数据结构",
    "section": "6.4 集合（Set）",
    "text": "6.4 集合（Set）\n集合是非有序的数据结构，它不允许重复元素。\n集合用花括号{}包围元素，并用逗号 , 分割。\n\nmy_set = {1, \"apple\", 3.14, \"apple\"}\nprint(my_set) # prints: {1, \"apple\", 3.14}\n\n{'apple', 1, 3.14}\n\n\n集合:\n\n是无序的\n集合中元素不能重复\n可以包含任何类型的元素\n不能通过索引访问元素",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "data_structures.html#字典dictionary",
    "href": "data_structures.html#字典dictionary",
    "title": "6  数据结构",
    "section": "6.5 字典（Dictionary）",
    "text": "6.5 字典（Dictionary）\n字典是一个无序的键值对集合。\n“键值对”（Key-Value Pair）指的是两个关联的部分：一个是唯一的键（Key），另一个是值（Value）。每个键都有一个关联的值。这种关联叫做”映射”。\n字典使用花括号{}包围元素，键值之间用冒号:分隔，而键值对之间用逗号,分隔。\n\n\n\n\n\n\n为什么叫字典\n\n\n\n在一本实体字典中，你可以根据词条（对应于计算机中的“键”）找到对应的解释或者翻译（对应于计算机中的“值”）。这构成了一个”词条-解释”对，与计算机科学中的”键-值对”类似。\n因此，考虑到这种映射关系，计算机科学中的这种包含”键-值对”的数据结构，就被命名为字典（Dictionary）。\n\n\n\nmy_dict = {\n    \"name\": \"apple\",\n    \"color\": \"red\",\n}\nprint(my_dict[\"name\"]) # prints: apple\n\nages = {\n    \"Tom\": 30, \n    \"Alice\": 25, \n    \"Bob\": 27\n}\n\nprint(ages[\"Alice\"]) # 输出：25\nages[\"Tom\"] = 31  # 将Tom的年龄改为31\nprint(ages[\"Tom\"]) # 输出：31\n\napple\n25\n31\n\n\n字典:\n\n是无序的\n键值对中的键是唯一的,但值可以重复\n可以包含任何类型的元素\n通过键来访问元素\n\n当你使用一个键来访问一个字典时，Python会返回与该键相关联的值。如果你使用一个不存在的键，Python会引发一个KeyError异常。\n为了避免这一点，可以使用get()方法。get(key, default)方法允许指定一个默认值，当字典中不存在指定的键时，它会返回该默认值而不是引发异常。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "data_structures.html#sec-objects-and-classes",
    "href": "data_structures.html#sec-objects-and-classes",
    "title": "6  数据结构",
    "section": "6.6 对象（Object）和类（Class）",
    "text": "6.6 对象（Object）和类（Class）\nPython是一种面向对象的编程语言。在Python中，几乎所有的东西都是对象，拥有其属性和方法。类(Class)就是为创建对象的种类或类型提供了定义的一种机制。\n对象(Object)：在Python中，对象是数据的核心单元。每个对象都具有一个类型（例如，字符串，列表，字典等），以及一个独一无二的身份（在内存中的地址）。对象可以包含包含多种数据（即属性）和功能（即方法）。它可以视为现实世界中的客观实体，比如一张桌子、一个圆形、一个人等。\n举例来说，一个人（对象）有姓名（属性）和能进行各种活动（方法）如跑步、学习等。\n类(Class)：类是对象的模板或蓝图。它定义了对象的基本结构，并封装了对象需要执行的行为（方法）。你可以定义一个类来创建属于这个类的对象。类就相当于制造物件的工厂，负责规定其生产出的对象应该拥有哪些特性。\n举例来说，你可以定义一个“人”的类（class），它有名字和年龄等属性，也有吃饭，睡觉等方法。然后根据这个“人”类，我们可以创建不同的人对象，比如创建一个名叫“张三”、年龄25岁的人对象。\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def introduce(self):\n        return f\"Hello, my name is {self.name} and I am {self.age} years old.\"\n\n# 创建一个属于Person类的对象\nsomeone = Person('张三', 25)\n\n# 调用对象的方法\nprint(someone.introduce())\n\nHello, my name is 张三 and I am 25 years old.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "data_structures.html#引用",
    "href": "data_structures.html#引用",
    "title": "6  数据结构",
    "section": "6.7 引用",
    "text": "6.7 引用\n在Python中，每当你创建一个对象并将其赋值给一个变量时，Python并不会将对象的值存储在变量中。相反，Python仅仅是将变量设置为一个引用，指向存储在内存中的对象。这种方式被称为绑定变量名到对象，或者叫做引用。\n\n6.7.1 创建对象和引用\n举个例子，当你创建一个列表并赋值给某个变量：\n\nlist1 = [1, 2, 3]\n\n此时，list1只是一个引用，它指向存储在内存中的一个列表对象，此对象包含元素1, 2, 3。如果你再创建一个引用，并指向同样的对象：\n\nlist2 = list1\n\n此时你有两个引用——list1和list2，它们同时指向同一个对象。\n\n\n6.7.2 修改可变类型的对象\n如果你通过其中一个引用去修改这个对象，例如你通过list1去删除第一个元素：\n\ndel list1[0]\n\n那么无论你是通过list1还是list2来访问这个列表对象，你都会发现的此对象的内容已经发生了变化：\n\nprint(list1)  # 输出: [2, 3]\nprint(list2)  # 输出: [2, 3]\n\n[2, 3]\n[2, 3]\n\n\n这是因为list1和list2都只是引用，它们并不包含实际的列表内容，而只是指向内存中的一个位置，即同一个列表对象的地址。\n\n\n6.7.3 对象的复制\n然而，有时你可能需要创建一个对象的副本，这样你就可以修改这个副本，而不影响原来的对象。例如，通过切片操作可以创建一个列表的副本：\n\nlist3 = list2[:]\n\n此时list3引用的是一个完全新的列表对象，这个对象的内容是list2所指向的列表的一个完全的拷贝。所以，当你更改list3的内容时，list2指向的列表内容不会被修改：\n\ndel list3[0]\nprint(list2)  # 输出: [2, 3]\nprint(list3)  # 输出: [3]\n\n[2, 3]\n[3]",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "problem_solving.html",
    "href": "problem_solving.html",
    "title": "7  问题解决",
    "section": "",
    "text": "7.1 软件开发流程\n软件开发的一个基本流程是：",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>问题解决</span>"
    ]
  },
  {
    "objectID": "problem_solving.html#软件开发流程",
    "href": "problem_solving.html#软件开发流程",
    "title": "7  问题解决",
    "section": "",
    "text": "分析（What）：定义我们要解决的问题\n设计（How）：确定实现目标的方法\n实施（Do It）：首先从一个简单版本开始，将核心功能实现出来\n测试和调试（Test）：验证程序是否按照期望运行，找出并修复程序中的错误和问题\n使用（Operation or Deployment）：通过实际使用，观察程序的运行效果\n改进（Maintain）：基于使用阶段的反馈进行，对程序进行优化和升级\n\n\n\n\n\n\n\nSoftware is grown, not built. – Bill de hÓra\n软件是成长的，而不是建造的。– Bill de hÓra",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>问题解决</span>"
    ]
  },
  {
    "objectID": "problem_solving.html#问题示例备份程序",
    "href": "problem_solving.html#问题示例备份程序",
    "title": "7  问题解决",
    "section": "7.2 问题示例：备份程序",
    "text": "7.2 问题示例：备份程序\n《A Byte of Python》中给出的问题是：\n\n\n\n\n\n\nI want a program which creates a backup of all my important files.\n我想要一个能够备份我所有重要文件的程序。\n\n\n\n其设计思路是：\n\n备份的文件和目录在列表中指定。\n备份必须存储在一个主备份目录中。\n文件被备份到一个zip文件中。\n压缩文件的名称是当前的日期和时间。\n使用标准的 zip 命令，该命令在任何标准的GNU/Linux或Unix发行版中都是默认可用的。请注意，只要具有命令行界面，您可以使用任何归档命令。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>问题解决</span>"
    ]
  },
  {
    "objectID": "problem_solving.html#知识点",
    "href": "problem_solving.html#知识点",
    "title": "7  问题解决",
    "section": "7.3 知识点",
    "text": "7.3 知识点\n《A Byte of Python》本章的示例代码中有一些重要的知识点：\n\n7.3.1 Python字符串格式化\n\n7.3.1.1 .format()方法\n.format()方法是一种字符串格式化方式，我们可以将值插入到字符串模板的占位符中。例如：\n\nname = \"Alice\"\nprint(\"Hello, {}\".format(name)) # 输出：Hello, Alice\n\nHello, Alice\n\n\n在这段代码中，{} 是一个占位符，可以在.format()方法中传入变量name，它会被自动替换到占位符的位置。\n我们还可以在{}中添加数字，以指定.format()方法参数的位置：\n\nfirstname = \"Alice\"\nlastname = \"Bob\"\nprint(\"Hello, {0} {1}\".format(firstname, lastname)) # 输出：Hello, Alice Bob\n\nHello, Alice Bob\n\n\n这里的 {0} 和 {1} 分别对应.format()方法里的第一个和第二个参数。\n\n\n\n7.3.2 f-string（格式化字符串字面值）\n在Python 3.6及以上版本中，我们通常使用f-string进行字符串格式化，它使字符串格式化更加简洁、高效。f-string的工作方式是，在字符串前面加上一个f或F，然后将要插入的变量或表达式写在 {} 之中，Python 会自动将其替换为它的值。例如：\n\nname = \"Alice\"\nprint(f\"Hello, {name}\") # 输出：Hello, Alice\n\nHello, Alice\n\n\n在 {} 中可以写入一些简单的Python表达式，Python会自动执行这些表达式并将结果替换到 {} 的位置：\n\na = 5\nb = 10\nprint(f\"Five plus ten is {a + b}, not {2 * (a + b)}.\") # 输出：Five plus ten is 15, not 30.\n\nFive plus ten is 15, not 30.\n\n\n\n\n7.3.3 操作系统路径分隔符在Python中的使用\n在不同的操作系统中，文件路径的表示方法是不同的。在Windows系统中，我们习惯使用反斜线\\来表示路径，例如：C:\\Users\\Admin\\Documents。而在UNIX系统（比如Linux, MacOS）中，我们使用正斜线/来表示路径，例如：/home/admin/Documents。 然而，在Python的字符串中，反斜线’'是一个特殊字符，被用作转义字符，用于引入特殊的字符序列。例如\\n表示换行，\\t表示制表符。例如：\n\nprint(\"Hello\\nWorld\") # 输出：\n# Hello\n# World\n\nHello\nWorld\n\n\n因此，如果我们想在Python字符串中使用Windows路径，如C:\\Users\\Admin\\Documents，我们需要使用双反斜线\\\\来转义，例如C:\\\\Users\\\\Admin\\\\Documents。代码示例：\n\npath = \"C:\\\\Users\\\\Admin\\\\Documents\"\nprint(path) # 输出：C:\\Users\\Admin\\Documents\n\nC:\\Users\\Admin\\Documents\n\n\n另外，我们可以使用Python的原始字符串来表示路径。原始字符串不会处理反斜线\\为特殊字符，我们只需在字符串前加上字符r即可。代码示例：\n\npath = r\"C:\\Users\\Admin\\Documents\"\nprint(path) # 输出：C:\\Users\\Admin\\Documents\n\nC:\\Users\\Admin\\Documents\n\n\n但是，不推荐直接在字符串中使用单个反斜线\\来表示Windows路径，因为这很容易引入一些我们不想要的转义序列。例如，\\U开始的是一个Unicode转义序列，如果路径中恰好包含\\U，Python会尝试处理它为特殊字符序列，从而导致错误。所以，应尽量避免使用如C:\\Users这样的字符串。\n注意：在大多数情况下，我们推荐使用os.path模块来处理路径，这样可以确保你的代码在不同的操作系统中都能正确运行。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>问题解决</span>"
    ]
  },
  {
    "objectID": "problem_solving.html#其他问题",
    "href": "problem_solving.html#其他问题",
    "title": "7  问题解决",
    "section": "7.4 其他问题",
    "text": "7.4 其他问题\n与之难度相似的，可以作为新手入门的问题还有：\n\n一个能够整理我在多个文件夹下的文档，将它们根据类型（如.doc, .pdf等）分门别类地存放在不同的文件夹中的程序\n一个能够给我所有的图片按指定的大小进行缩放的程序\n一个能够统计一篇英文文章中每个单词出现次数的程序\n一个能够找出两个文件夹中相同的文件并列出的程序",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>问题解决</span>"
    ]
  },
  {
    "objectID": "object_oriented_programming.html",
    "href": "object_oriented_programming.html",
    "title": "8  面向对象编程",
    "section": "",
    "text": "8.1 对象和类的回顾\n在 ?sec-objects-and-classes 中我们已经介绍了对象和类的概念，我们可以总结如下：",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>面向对象编程</span>"
    ]
  },
  {
    "objectID": "object_oriented_programming.html#对象和类的回顾",
    "href": "object_oriented_programming.html#对象和类的回顾",
    "title": "8  面向对象编程",
    "section": "",
    "text": "类（Class）：类是对一类事物的抽象描述，它定义了这种事物的静态特性（字段）和动态行为（方法）。类是创建对象的模板，对象是类的实例。\n对象（Object）：对象是类的实例，即根据类的定义创建的实体。每个对象都有自己的属性（类变量和实例变量）和行为（方法）。\n属性（Attribute）：属性是类或对象的特性，包括静态特性（字段）和动态行为（方法）。\n方法（Method）：方法是类定义的一部分。方法定义了对象的动态行为，描述了对象如何响应外部的请求或如何完成某些具体的任务。\n\n\n\n\n\n\n\nTip\n\n\n\n类似结构功能主义——在面向对象编程中，对象的字段就像是他的“结构”，而方法则如同他的“功能”。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>面向对象编程</span>"
    ]
  },
  {
    "objectID": "object_oriented_programming.html#类的构建功能部分",
    "href": "object_oriented_programming.html#类的构建功能部分",
    "title": "8  面向对象编程",
    "section": "8.2 类的构建（功能部分）",
    "text": "8.2 类的构建（功能部分）\n一个最简单的类如下所示：\n\nclass Person:\n    pass  # An empty block\n\np = Person()\nprint(p)\n\n&lt;__main__.Person object at 0x000001E1F50CDB50&gt;\n\n\n我们使用class语句和类的名称创建一个新的类，然后是一个缩进的语句块，构成类的主体。在这里，用pass语句表示一个空的语句块，因为Python中的语句块不能为空。\n类的名称后跟一对括号可以创建一个对象/实例。在实例代码中，我们通过print(p)语句来确认这个对象已经被创建。打印的结果说明这个对象是一个在 __main__ 模块中的Person类的实例。\n类的构建主要是通过定义类的方法实现的。方法描述了类或其实例可以进行的操作。在Python中，我们常常在类的内部定义方法，就像定义普通的函数那样。\n\n8.2.1 方法: 类的功能实现\n类和对象可以和函数一样拥有方法，唯一的不同之处在于方法的第一个参数是self。\n以下是一个简单的类的方法例子：\n\nclass Person:\n    def say_hi(self):\n        print('Hello, how are you?')\n\np = Person()\np.say_hi()\n\nHello, how are you?\n\n\n\n\n8.2.2 self在类方法中的作用\n在Python中，类方法的第一个参数通常会是一个名为self的特殊参数，这个self参数代表方法的所属实例，或者说，将会调用这个方法的实例。通过self参数，方法可以自由地访问和修改对象的字段和其他方法。\n\n\n\n\n\n\nTip\n\n\n\n在定义类的方法时，我们并不知道这个方法将来会被哪个实例对象调用。所以我们需要一个参数（习惯上叫做self）来接收运行时传入的实例对象，这样这个方法才能访问到实例的属性或者调用实例的其他方法。\n\n\n\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\n    def bark(self):\n        return f\"{self.name} says woof!\"\n\nd1 = Dog(\"Fido\")\nd2 = Dog(\"Rex\")\n\nprint(d1.bark())  # 输出 \"Fido says woof!\"\nprint(d2.bark())  # 输出 \"Rex says woof!\"\n\nFido says woof!\nRex says woof!\n\n\n当一个实例调用其方法时，Python 解释器会自动将实例本身传入方法的self参数。通过self，我们可以在方法内部访问和修改实例的属性。\n在这个例子中，bark()方法在d1和d2两个不同的实例中调用，self就代表了调用这个方法的实例，因此self.name会分别返回d1和d2的name属性。在每一次方法的调用中，Python都会自动地将当前的对象实例作为第一个参数传递进去。\n\n\n\n\n\n\nCaution\n\n\n\nrex.bark()\n在这里，当我们调用rex.bark()时，从表面看，我们并没有给bark方法提供任何参数。但实际上，Python解释器会自动把rex这个实例传递给bark方法的self参数。这就是为何在类的方法最开始位置总会有一个self参数，而在调用方法时，我们通常并不需要显式地提供这个参数。\n同理，这也意味着哪怕是一个不带参数的方法，他也仍然需要一个参数- self\n\n\n\n\n8.2.3 __init__方法：类的构造函数\n在Python中，我们通常会在类中定义一个特殊的方法__init__，这个方法称为类的构造函数。当我们根据类创建一个新的实例时，Python解释器会自动调用__init__方法对新创建的实例进行初始化。\n\n\n\n\n\n\n魔术方法\n\n\n\n__init__方法的名称前后都有两个下划线，这代表它是一个特殊的方法，有特别的含义。\n在Python中，这种双下划线开头和结尾的方法通常被称为“魔术方法”。这些方法是由Python解释器自动调用的，我们通常不需要显式地调用它们。\n\n\n__init__方法的第一个参数总是self，即这个对象本身的引用。在__init__方法中，我们可以设置实例的初始状态，比如添加一些初始的属性值。\n以下是一个包含有__init__方法的类的例子：\n\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nmy_dog = Dog('Willy', 5)\n\n在这个例子中，Dog类有一个__init__方法，这个方法接收三个参数：self、name和age。对于self参数，我们已经知道，当我们创建类的实例时，Python会自动为我们提供。其它的参数（name和age），我们需要在创建对象时提供。\n__init__方法通常用于在创建对象时初始化对象的状态。通过在__init__方法中设置对象的属性，可以确保对象一旦被创建，就具有一定的初始状态。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>面向对象编程</span>"
    ]
  },
  {
    "objectID": "object_oriented_programming.html#字段结构部分",
    "href": "object_oriented_programming.html#字段结构部分",
    "title": "8  面向对象编程",
    "section": "8.3 字段（结构部分）",
    "text": "8.3 字段（结构部分）\n在类或对象中定义的变量被称为字段，用于描述对象的状态或性质。上述的静态特性就是指类或对象的字段。\n\n\n\n\n\n\nCaution\n\n\n\n属性 = 字段+ 方法\n\n\n字段是绑定到类或对象的命名空间中的变量，因此，这些名称只在类和对象的上下文中有效。\n字段有两种类型：\n\n类变量：属于类，所有的对象实例共享这一个变量，一个对象修改了它，会影响到所有的对象。\n实例变量：属于对象，每个对象实例都有自己的一份副本，一个对象修改了它，不会影响其他的对象。\n\n下面是一个用于理解类变量和实例变量的例子：\n\nclass Robot:\n    \"\"\"Represents a robot, with a name.\"\"\"\n\n    # A class variable, counting the number of robots\n    population = 0\n\n    def __init__(self, name):\n        \"\"\"Initializes the data.\"\"\"\n        self.name = name\n        print(\"(Initializing {})\".format(self.name))\n\n        # When this person is created, the robot\n        # adds to the population\n        Robot.population += 1\n\n    def die(self):\n        \"\"\"I am dying.\"\"\"\n        print(\"{} is being destroyed!\".format(self.name))\n\n        Robot.population -= 1\n\n        if Robot.population == 0:\n            print(\"{} was the last one.\".format(self.name))\n        else:\n            print(\"There are still {:d} robots working.\".format(\n                Robot.population))\n\n    def say_hi(self):\n        \"\"\"Greeting by the robot.\n\n        Yeah, they can do that.\"\"\"\n        print(\"Greetings, my masters call me {}.\".format(self.name))\n\n    @classmethod\n    def how_many(cls):\n        \"\"\"Prints the current population.\"\"\"\n        print(\"We have {:d} robots.\".format(cls.population))\n\n\ndroid1 = Robot(\"R2-D2\")\ndroid1.say_hi()\nRobot.how_many()\n\ndroid2 = Robot(\"C-3PO\")\ndroid2.say_hi()\nRobot.how_many()\n\nprint(\"\\nRobots can do some work here.\\n\")\n\nprint(\"Robots have finished their work. So let's destroy them.\")\ndroid1.die()\ndroid2.die()\n\nRobot.how_many()\n\n(Initializing R2-D2)\nGreetings, my masters call me R2-D2.\nWe have 1 robots.\n(Initializing C-3PO)\nGreetings, my masters call me C-3PO.\nWe have 2 robots.\n\nRobots can do some work here.\n\nRobots have finished their work. So let's destroy them.\nR2-D2 is being destroyed!\nThere are still 1 robots working.\nC-3PO is being destroyed!\nC-3PO was the last one.\nWe have 0 robots.\n\n\n在这个例子中：\n\npopulation是一个类变量，用于跟踪机器人的数量。\nname是一个实例变量，用于存储机器人的名字。\n__init__方法是一个特殊的方法，用于初始化机器人的名字。\nhow_many是一个类方法，用于打印当前机器人的数量。我们使用装饰器将how_many方法标记为类方法。\ndie是一个实例方法，用于表示机器人的销毁。\n所有的类成员都是公有的。一个下划线开头的名称（例如_name）表示这个名称是受保护的，不应该被外部访问。两个下划线开头的名称（例如__name）表示这个名称是私有的，不应该被外部访问。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>面向对象编程</span>"
    ]
  },
  {
    "objectID": "object_oriented_programming.html#继承",
    "href": "object_oriented_programming.html#继承",
    "title": "8  面向对象编程",
    "section": "8.4 继承",
    "text": "8.4 继承\n继承是面向对象编程的一个重要特性，它允许我们定义一个新的类，这个类可以继承一个或多个已经存在的类的属性和方法。被继承的类称为父类（或基类），继承的类称为子类（或派生类）。\n继承的主要作用是实现代码的复用，通过继承，子类可以继承父类的属性和方法，从而不需要重复编写相同的代码。\n在Python中，继承是通过在类定义时在类名后面的括号中指定父类来实现的。下面是一个简单的继承的例子：\n\nclass SchoolMember:\n    '''Represents any school member.'''\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        print('(Initialized SchoolMember: {})'.format(self.name))\n\n    def tell(self):\n        '''Tell my details.'''\n        print('Name:\"{}\" Age:\"{}\"'.format(self.name, self.age), end=\" \")\n\n\nclass Teacher(SchoolMember):\n    '''Represents a teacher.'''\n    def __init__(self, name, age, salary):\n        SchoolMember.__init__(self, name, age)\n        self.salary = salary\n        print('(Initialized Teacher: {})'.format(self.name))\n\n    def tell(self):\n        SchoolMember.tell(self)\n        print('Salary: \"{:d}\"'.format(self.salary))\n\n\nclass Student(SchoolMember):\n    '''Represents a student.'''\n    def __init__(self, name, age, marks):\n        SchoolMember.__init__(self, name, age)\n        self.marks = marks\n        print('(Initialized Student: {})'.format(self.name))\n\n    def tell(self):\n        SchoolMember.tell(self)\n        print('Marks: \"{:d}\"'.format(self.marks))\n\nt = Teacher('Mrs. Shrividya', 40, 30000)\ns = Student('Swaroop', 25, 75)\n\n# prints a blank line\nprint()\n\nmembers = [t, s]\nfor member in members:\n    # Works for both Teachers and Students\n    member.tell()\n\n(Initialized SchoolMember: Mrs. Shrividya)\n(Initialized Teacher: Mrs. Shrividya)\n(Initialized SchoolMember: Swaroop)\n(Initialized Student: Swaroop)\n\nName:\"Mrs. Shrividya\" Age:\"40\" Salary: \"30000\"\nName:\"Swaroop\" Age:\"25\" Marks: \"75\"\n\n\n在这个例子中：\n\n使用继承时，在类定义中的类名后面的元组中指定基类名（例如，class Teacher(SchoolMember):）。\n基类的__init__方法是通过调用SchoolMember.__init__(self, name, age)来显式调用的。\n\n这是因为子类的__init__方法会覆盖父类的__init__方法。\n如果我们想要在子类的__init__方法中调用父类的__init__方法，我们需要显式地调用它。\n\nTeacher和Student类都继承了SchoolMember类。这意味着Teacher和Student类都可以访问SchoolMember类的属性和方法。\n对于每一个子类，我们都定义了一个tell方法，这个方法会覆盖父类的tell方法。这就是所谓的多态性，即不同的类可以对相同的方法做出不同的响应。\n\n如果子类中没有定义tell方法，那么子类会继承父类的tell方法。\nPython始终会优先调用子类的方法，如果找不到这个方法，则开始按照继承链向上查找。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>面向对象编程</span>"
    ]
  },
  {
    "objectID": "object_oriented_programming.html#总结",
    "href": "object_oriented_programming.html#总结",
    "title": "8  面向对象编程",
    "section": "8.5 总结",
    "text": "8.5 总结\n\n8.5.1 面向对象编程的主要特点\n面向对象编程（OOP）的主要特点是：\n\n模块化：每一个对象都可以看作是一个独立的模块，它拥有自己的属性（也称为数据成员）和方法（也称为成员函数）。\n可复用性：对象的代码可以在需要的地方复用，可以通过继承、封装、多态这些机制实现代码的重用。\n扩展性：继承和多态性的机制提高了程序的可扩展性。\n\n\n\n\n\n\n\n其他常见的编程范型\n\n\n\n面向过程编程（Procedural programming）：是最早的编程范型之一，它的主要思想是将程序分解为一步一步的过程或者函数，通过定义数据和函数的执行步骤来解决问题。\n函数式编程（Functional Programming）：倡导编写纯函数，避免程序状态改变和数据可变性，以求更高的可理解性和更低的bug产生率。\n逻辑编程（Logic Programming） ：通过描述问题的逻辑来编写程序，程序会自动推导出解决问题的答案。Prolog就是一种逻辑编程语言。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>面向对象编程</span>"
    ]
  },
  {
    "objectID": "input_and_output.html",
    "href": "input_and_output.html",
    "title": "9  输入和输出",
    "section": "",
    "text": "9.1 用户输入\ninput() 函数接受一个字符串作为参数，并将其显示给用户。然后它等待用户输入并按下回车键。一旦用户输入并按下回车键， input() 函数将返回用户输入的文本。\n一些注意事项：\n下面是一些示例代码：\n以上的示例代码中有以下几个要点：",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>输入和输出</span>"
    ]
  },
  {
    "objectID": "input_and_output.html#用户输入",
    "href": "input_and_output.html#用户输入",
    "title": "9  输入和输出",
    "section": "",
    "text": "input() 函数总是返回一个字符串。如果你需要一个整数，你需要使用 int() 函数将返回的字符串转换为整数。\ninput() 函数总是返回一个字符串。如果你需要一个浮点数，你需要使用 float() 函数将返回的字符串转换为浮点数。\ninput() 函数可以不带参数直接使用，这时它将只显示一个简单的冒号提示符，等待用户输入。也可以带一个字符串作为参数，这个字符串将作为提示信息显示给用户。\n使用 input() 函数时，在用户输入内容并按下回车键之前，程序会暂停运行，也就是被阻塞。\n\n如果你要输入密码或其他敏感信息，可能希望用户输入的内容不被显示出来。这时可以使用 getpass 模块中的 getpass() 函数。\n\n\n\n# 例子1\nname = input(\"What is your name? \")\nprint(\"Hello, \" + name + \"!\")\n# 例子2\ndef reverse(text):\n    return text[::-1]\n\ndef is_palindrome(text):\n    return text == reverse(text)\nsomething = input(\"Enter text: \")\nif is_palindrome(something):\n    print(\"Yes, it is a palindrome\")\nelse:\n    print(\"No, it is not a palindrome\")\n# 例子3\nimport getpass\npassword = getpass.getpass(\"Enter your password: \")\nif password == \"12345\":\n    print(\"Access granted\")\nelse:\n    print(\"Access denied\")\n# 例子4\ndef reverse(text):\n    return text[::-1]\ndef is_palindrome(text):\n    return text == reverse(text)\n    \nsomething = input(\"Enter text: \")\nfiltered_something = ''.join(c for c in something if c.isalnum()).lower()\nif is_palindrome(filtered_something):\n    print(\"Yes, it is a palindrome\")\nelse:\n    print(\"No, it is not a palindrome\")\n\n\n例子1中，input() 函数带有一个字符串参数，这个字符串作为提示信息显示给用户。\n例子2中，input() 函数带有一个字符串参数，这个字符串作为提示信息显示给用户。用户输入的内容被传递给 reverse() 函数和 is_palindrome() 函数。\n例子2中，我们使用切片功能来反转字符串。text[::-1] 返回一个反转的字符串。切片的语法是 text[start:end:step]。默认值是 start=0，end=len(text)，step=1。给定一个负的 step 值，意味着从右向左切片，也即反转字符串。\n例子3中，我们使用 getpass 模块中的 getpass() 函数来获取用户输入的密码。这个函数不会显示用户输入的内容。\n例子4中，我们使用了 isalnum() 方法来检查字符串中是否只包含字母和数字。isalnum() 方法返回 True 如果字符串中只包含字母和数字，否则返回 False。join() 方法将一个字符串列表连接起来，返回一个新的字符串。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>输入和输出</span>"
    ]
  },
  {
    "objectID": "input_and_output.html#文件",
    "href": "input_and_output.html#文件",
    "title": "9  输入和输出",
    "section": "9.2 文件",
    "text": "9.2 文件\nPython提供了一些内置的函数和方法，使我们能够创建、打开、读写文件。这些操作主要通过内置的 open() 函数和文件对象的方法来实现。\n以下是一些常见的文件操作：\n\nopen 函数：这事一个内建函数，用于打开一个文件，并返回一个文件对象。\n\nopen 函数接受两个参数：文件名（必须）和模式（可选）。\n模式参数是一个字符串，用于指定文件的打开模式。默认值是 r，表示只读模式。还包括 w（写入模式）、a（追加模式）、r+（读写模式）等。\nw 模式会创建一个新文件，如果文件已经存在，它将被覆盖。\n在r模式下，文件对象的方法只能用于读取文件内容。在w模式下，文件对象的方法只能用于写入文件内容。在a模式下，文件对象的方法只能用于追加文件内容。\n如果想要在写入一些内容之后立即读取，需要以读写模式（如r+或w+）打开文件。\n\nread 方法：用于读取文件内容。\n\nread 方法接受一个整数作为参数，用于指定要读取的字节数。如果没有指定参数，read() 方法将读取整个文件。\n在读取或写入文件内容后，文件对象的指针将移动到文件的末尾。如果要再次读取文件内容，需要使用 seek 方法将文件指针移动到文件的开头。\n\nwrite 方法：用于写入文件内容。这个方法接受一个字符串作为参数，将这个字符串写入文件。\nclose 方法：用于关闭文件。关闭文件后，任何对文件对象的操作都将失败。\n\n以下是一些示例代码：\n\nfile1 = open(r\"practical_code\\input_and_output\\myfile.txt\", \"r\")\ncontent = file1.read()\nprint(content)\nfile1.close()\n\n# This is a example of Python IO.\nAnd this is the second line.\n\n\n\nfile2 = open(r\"practical_code\\input_and_output\\myfile2.txt\", \"w\")\nfile2.write(\"This is a test\")\nfile2.close()\n\n当进行文件操作时，应始终注意在操作结束后关闭文件。为了更有效地管理文件资源，Python提供了 with 语句，它可以自动关闭文件。以下是一个示例：\n\nwith open(r\"practical_code\\input_and_output\\myfile.txt\", \"r\") as file:\n    content = file.read()\n    print(content)\n\n# This is a example of Python IO.\nAnd this is the second line.\n\n\n以下是一个更复杂的示例：\n\npoem = '''\\\nProgramming is fun\nWhen the work is done\nif you wanna make your work also fun:\n    use Python!\n'''\nf = open(r\"practical_code\\input_and_output\\poem.txt\", \"w\")\nf.write(poem)\nf.close()\n\nf = open(r\"practical_code\\input_and_output\\poem.txt\", \"r\")\nwhile True:\n    line = f.readline()\n    if len(line) == 0:\n        break\n    print(line, end='')\nf.close()\n\nProgramming is fun\nWhen the work is done\nif you wanna make your work also fun:\n    use Python!\n\n\n在这个示例代码中：\n\n我们首先使用 open 函数创建一个文件对象，然后使用 write 方法写入一些内容。\n使用readline 方法读取文件内容。readline 方法每次读取一行内容，并返回一个字符串。当到达文件末尾时，readline 方法将返回一个空字符串，即 len(line) == 0。这时我们使用 break 语句退出循环。\n我们使用 end='' 参数来避免在每行的末尾添加一个新的空行。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>输入和输出</span>"
    ]
  },
  {
    "objectID": "input_and_output.html#pickle模块",
    "href": "input_and_output.html#pickle模块",
    "title": "9  输入和输出",
    "section": "9.3 Pickle模块",
    "text": "9.3 Pickle模块\nPickle是一个Python标准模块，它是Python中用于对象序列化和反序列化的一个重要模块。\n通过Pickle模块，Python对象结构可以转化为一个字节流，这个字节流包含了重建原来对象的所有必要信息。转化为字节流的过程被称为”pickling”，而从字节流恢复对象的过程被称为”unpickling”。\nPickle可以处理几乎所有的Python对象，包括函数、类、甚至是用户自定义的对象。\n“持久化存储对象”这个概念，通常指的是将内存中的对象状态保存到持久化存储媒介，如硬盘、数据库或者远程服务器等，然后在稍后的时间，即使原程序已经停止，也可以将这些数据重新读取到内存中，恢复为对象。\nPickle模块的功能就是持久化存储对象的重要手段之一。通过pickle模块，我们可以将内存中的Python对象转化为字节流，然后将这些字节流存储在文件，数据库或通过网络发送到其他地方。当我们需要的时候，可以通过unpickling操作，重新将这些字节流转化回Python对象。\n使用pickle模块进行pickling和unpickling的主要方法有：\n\npickle.dumps(obj)：将Python对象转化为字节流。\npickle.dump(obj, file)：将Python对象转化为字节流，并将这些字节流写入文件。\npickle.loads(bytes_object)：从一个字节字符串中恢复对象。\npickle.load(file)：从文件中读取字节流，并将这些字节流转化为Python对象。\n\n下面是这个模块一些基本使用示例：\n\nimport pickle\n\ndata = {\n    'a': [1, 2.0, 3, 4+6j],\n    'b': (\"character string\", b\"byte string\"),\n    'c': {None, True, False}\n}\n\nwith open(r\"practical_code\\input_and_output\\data.pkl\", \"wb\") as f:\n    pickle.dump(data, f)\n\nwith open(r\"practical_code\\input_and_output\\data.pkl\", \"rb\") as f:\n    restored_data = pickle.load(f)\nprint(restored_data)\n\n{'a': [1, 2.0, 3, (4+6j)], 'b': ('character string', b'byte string'), 'c': {False, None, True}}\n\n\n在这个示例中，我们首先使用 pickle.dump 方法将一个Python对象转化为字节流，并将这些字节流写入文件。然后我们使用 pickle.load 方法从文件中读取字节流，并将这些字节流转化为Python对象。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>输入和输出</span>"
    ]
  },
  {
    "objectID": "input_and_output.html#unicoin字符和编码",
    "href": "input_and_output.html#unicoin字符和编码",
    "title": "9  输入和输出",
    "section": "9.4 Unicoin字符和编码",
    "text": "9.4 Unicoin字符和编码\n在Python 3中，字符串是Unicode字符串。Unicode是一个标准，它定义了世界上所有文字的字符集。Unicode字符集包含了世界上所有的文字，包括中文、日文、希腊文、西里尔文等。每个字符都有一个唯一的Unicode码点，这个码点是一个整数。\n编码和解码：\n\n将Unicode字符转化为字节流的过程被称为编码。在Python中，我们可以使用 encode 方法将Unicode字符串编码为字节流\n将字节流转化为Unicode字符的过程被称为解码。可以使用 decode 方法将字节流解码为Unicode字符串。\n一种常见的编码方式是UTF-8编码。\n在编程时，如果我们需要处理非ASCII字符，我们应该始终使用Unicode字符串。这样，只有在需要将Unicode字符串转化为字节流时，我们才需要使用编码。\n\n当我们编写一个使用Unicode字符的程序时，我们应该确保程序使用UTF-8编码。这样，我们的程序可以处理世界上所有的文字。\n下面是一个处理Unicode字符的示例：\n\nimport io\n\nf = io.open(r\"practical_code\\input_and_output\\zh_CN.txt\", \"wt\", encoding=\"utf-8\")\nf.write(u\"你好，世界！\")\nf.close()\n\ntext = io.open(r\"practical_code\\input_and_output\\zh_CN.txt\", encoding=\"utf-8\").read()\nprint(text)\n\n你好，世界！\n\n\n在这个示例代码中：\n\n在Python 3中，io.open 函数的用法和 open 函数完全一样。\n但是在Python 2中，open 函数不支持指定编码。在Python 2中，我们应该使用 io.open 函数来打开文件。\n如果需要程序能同时兼容Python 2和Python 3，我们应该使用 io.open 函数来打开文件。但如果我们只需要兼容Python 3，出于简洁的考虑，我们可以只使用 open 函数。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>输入和输出</span>"
    ]
  },
  {
    "objectID": "exceptions.html",
    "href": "exceptions.html",
    "title": "10  异常情况",
    "section": "",
    "text": "10.1 处理异常\n我们可以使用try..except语句来捕获异常。try语句包含了可能会引发异常的代码块，以及对这些异常的处理代码块。except块中包含了所有的错误处理程序。\ntry..except语句的基本语法如下：\ntry:\n    # 这里是可能抛出异常的代码\n    x = 1 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\n\nCannot divide by zero\n在上述代码示例中：",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>异常情况</span>"
    ]
  },
  {
    "objectID": "exceptions.html#处理异常",
    "href": "exceptions.html#处理异常",
    "title": "10  异常情况",
    "section": "",
    "text": "try语句包含了可能抛出异常的代码块，即x = 1 / 0。\nexcept语句包含了对异常的处理代码块，即print(\"Cannot divide by zero\")。\nexcept语句可以处理单个指定的异常，也可以处理一个括号内的异常元组。\n如果没有指定异常类型，那么except语句将捕获所有类型的异常。\n在代码示例中，except ZeroDivisionError指定了只捕获ZeroDivisionError异常。这是一个特定的异常类型，用于处理除零错误。\n每个try语句都可以包含多个except语句，用于处理不同类型的异常。但是，只有一个except语句会被执行。\n每个try语句都至少包含一个except语句或finally语句，用于处理异常。\n\n\n10.1.1 else语句\nelse语句用于指定只有在没有发生异常时才会执行的代码块。else语句的基本语法如下：\n\ntry:\n    # 这里是可能抛出异常的代码\n    x = 1 / 1\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\nelse:\n    # 这里是只有在没有发生异常时才会执行的代码\n    print(\"No exceptions occurred\")\n\nNo exceptions occurred\n\n\n在上述代码示例中：\n\nelse语句包含了只有在没有发生异常时才会执行的代码块，即print(\"No exceptions occurred\")。\nelse语句通常用于在没有发生异常时执行一些清理操作。\nelse语句必须在所有的except语句之后，但在finally语句之前。\n\n\n\n10.1.2 finally语句\nfinally语句用于指定无论是否发生异常都要执行的代码块。finally语句通常用于释放资源或执行清理操作。finally语句的基本语法如下：\n\ntry:\n    # 这里是可能抛出异常的代码\n    x = 1 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\nelse:\n    # 这里是只有在没有发生异常时才会执行的代码\n    print(\"No exceptions occurred\")\nfinally:\n    # 这里是无论是否发生异常都要执行的代码\n    print(\"This is always executed\")\n\nCannot divide by zero\nThis is always executed\n\n\n在上述代码示例中：\n\nfinally语句包含了无论是否发生异常都要执行的代码块，即print(\"This is always executed\")。\nfinally语句通常用于释放资源或执行清理操作。例如，我们可以在finally语句中关闭文件、释放锁、关闭数据库连接等。\n\n\n\n10.1.3 with语句\n在Python中，with语句是一种语法糖，主要用于简化资源管理相关的代码。对于文件操作、网络连接、数据库连接这类需要在使用结束后显式释放的资源，可以通过with语句来自动处理资源的释放，使得代码更加简洁，避免了资源泄露的可能性。\n\n\n\n\n\n\n什么是语法糖\n\n\n\n语法糖（Syntactic Sugar）指的是一种设计使得某些编程任务更易读或者可表现性更强的语法。其主要目的是提高程序的可读性，使代码更简洁，或者语义更明显。\n“语法糖”这个术语的含义最早源于 Peter J. Landin（一位计算机科学家）在1964年创造的，该术语是用来形象地描述那些没有给计算机语言添加新功能，但是使人们用更舒适的方式编写或读代码的特性。\n这个名词的形象含义是，这种语法就像是在给代码增加了一些“糖”，让原本可能枯燥乏味、硬邦邦的代码变得更加甜美，更具美感，给编程带来了乐趣。就像糖改善了食物的口感，但是并没有增加食物的营养，语法糖使代码写起来更加愉快、更容易理解，但并没有改变编程语言的核心功能或语义。\n比如在Python中的装饰器、列表推导式等，它们并没有为Python语言增加什么新的功能，只是让我们在编写相同功能代码的时候，代码显得更加清晰，可阅读性更强，让编程更具有乐趣。所以称其为”语法糖”。\n\n\nwith语句的基本语法如下：\nwith expression as variable:\n    # code block\n其中expression必须是一个对象，它必须实现了__enter__和__exit__方法。\n\n__enter__方法在代码块开始执行前调用，用于返回一个资源对象。\n__exit__方法在代码块结束后调用，负责清理或释放资源。\n\n一个使用with语句的示例如下：\nwith open(r\"practical_code\\input_and_output\\data.pkl\", \"wb\") as f:\n    pickle.dump(data, f)\n在上述代码示例中：\n\nwith语句首先调用文件对象的__enter__方法打开文件，然后将返回的文件对象赋值给f。\n之后，with语句执行代码块，即pickle.dump(data, f)。\n无论这个代码块是否发生异常，with语句都会调用文件对象的__exit__方法关闭文件。这样，我们就不需要显式地调用f.close()方法来关闭文件了。\n\n在处理异常时，如果不使用with语句，我们需要在try语句的finally语句中显式地调用f.close()方法来关闭文件。而使用with语句，我们就不需要这样做了。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>异常情况</span>"
    ]
  },
  {
    "objectID": "exceptions.html#异常类",
    "href": "exceptions.html#异常类",
    "title": "10  异常情况",
    "section": "10.2 异常类",
    "text": "10.2 异常类\nPython提供了一些内置的异常类，用于表示不同类型的错误情况。常见的异常类包括：\n\nException：所有异常类的基类。\nNameError：名称错误，当尝试访问不存在的变量或函数时引发。\nTypeError：类型错误，当操作或函数应用于不兼容的类型时引发。\nValueError：值错误，当操作或函数应用于具有正确类型但具有无效值的对象时引发。\nIndexError：索引错误，当尝试访问列表、元组或字符串中不存在的索引时引发。\nKeyError：键错误，当尝试访问字典中不存在的键时引发。\nFileNotFoundError：文件未找到错误，当尝试打开不存在的文件时引发。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>异常情况</span>"
    ]
  },
  {
    "objectID": "exceptions.html#引发异常",
    "href": "exceptions.html#引发异常",
    "title": "10  异常情况",
    "section": "10.3 引发异常",
    "text": "10.3 引发异常\n我们可以使用raise语句来引发异常。raise语句用于引发指定的异常。\n可以被引发的异常可以是任何类的实例，但通常是内置的异常类的实例。raise语句的基本语法如下：\nraise ValueError(\"Invalid value\")\n这行代码将引发一个ValueError异常，异常消息为Invalid value。一般来说，我们用这种方式引发异常来通知调用者发生了一些特定的错误情况，这种时候我们可以自定义异常类。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>异常情况</span>"
    ]
  },
  {
    "objectID": "exceptions.html#自定义异常类",
    "href": "exceptions.html#自定义异常类",
    "title": "10  异常情况",
    "section": "10.4 自定义异常类",
    "text": "10.4 自定义异常类\n自定义异常类是一个继承自Exception类的类。我们可以通过继承Exception类来创建自定义的异常类。自定义异常类的基本语法如下：\nclass ShortInputException(Exception):\n    def __init__(self, length, atleast):\n        self.length = length\n        self.atleast = atleast\ntry:\n    text = input(\"Enter something --&gt; \")\n    if len(text) &lt; 3:\n        raise ShortInputException(len(text), 3)\nexcept EOFError:\n    print(\"Why did you do an EOF on me?\")\nexcept ShortInputException as e:\n    #print(\"ShortInputException: The input was of length %d, was expecting at least %d\" % (e.length, e.atleast))\n    print(f\"ShortInputException: The input was of length {e.length}, was expecting at least {e.atleast}\")\nelse:\n    print(\"No exception was raised\")\n在上述代码示例中：\n\nShortInputException是一个自定义的异常类，它继承自Exception类。\nraise ShortInputException(len(text), 3)语句引发了一个ShortInputException异常。\n当except语句捕获到一个异常时，它会生成一个异常实例。这个异常实例包括了异常的详细信息。我们可以使用as关键字来给这个异常实例指定一个变量名，然后在except语句中使用这个变量名来访问异常的详细信息。\n%d是一个占位符，用于格式化字符串。%运算符用于格式化字符串。在这个例子中，%d表示将一个整数插入到字符串中。\n在Python 3.6及以后的版本中，我们可以使用f字符串来格式化字符串。f字符串是一种新的字符串格式化语法，它允许我们在字符串中使用变量名，而不是占位符。这种方式更为直观灵活。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>异常情况</span>"
    ]
  },
  {
    "objectID": "standard_library.html",
    "href": "standard_library.html",
    "title": "11  标准库",
    "section": "",
    "text": "11.1 sys模块\nsys模块提供了一些变量和函数，用于与Python解释器进行交互。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>标准库</span>"
    ]
  },
  {
    "objectID": "standard_library.html#sys模块",
    "href": "standard_library.html#sys模块",
    "title": "11  标准库",
    "section": "",
    "text": "11.1.1 sys.argv\n正如我们在 Section 5.1.1 看到的，sys.argv是一个包含命令行参数的列表。\n我们在此总结一下：\n\nsys.argv[0]是脚本的名称\nsys.argv[1]是第一个参数\nsys.argv[2]是第二个参数\nsys.argv的长度是命令行参数的个数\n\n下面是一个简单的例子：\n\nimport sys\n\nprint(sys.argv)\n\n['c:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\ipykernel_launcher.py', '-f', 'C:\\\\Windows\\\\Temp\\\\tmp79v95aph.json', '--HistoryManager.hist_file=:memory:']\n\n\n\n\n11.1.2 sys.version\nsys.version包含了Python解释器的版本信息。\n\nimport sys\n\nprint(sys.version)\n\n3.11.8 | packaged by conda-forge | (main, Feb 16 2024, 20:40:50) [MSC v.1937 64 bit (AMD64)]\n\n\nsys模块有一个名为version_info的元组，它包含了Python解释器的版本信息。\n\n\n11.1.3 sys.path\nsys.path是一个包含了模块搜索路径的列表。\n\nimport sys\n\nprint(sys.path)\n\n['c:\\\\Conda_data\\\\envs\\\\main\\\\python311.zip', 'c:\\\\Conda_data\\\\envs\\\\main\\\\DLLs', 'c:\\\\Conda_data\\\\envs\\\\main\\\\Lib', 'c:\\\\Conda_data\\\\envs\\\\main', '', 'c:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages', 'c:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\win32', 'c:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\win32\\\\lib', 'c:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\Pythonwin']",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>标准库</span>"
    ]
  },
  {
    "objectID": "standard_library.html#os模块",
    "href": "standard_library.html#os模块",
    "title": "11  标准库",
    "section": "11.2 os模块",
    "text": "11.2 os模块\nos模块提供了许多与操作系统交互的函数。\n常见的操作包括：获取当前工作目录、更改目录、创建目录、删除目录、删除文件等。\n\n11.2.1 os.getcwd()\nos.getcwd()返回当前工作目录。\n\nimport os\n\nprint(os.getcwd())\n\nC:\\Code\\MyProjects\\My-Python-Learning\n\n\n\n\n11.2.2 os.listdir()\nos.listdir()返回指定目录下的文件和目录列表。\n\nimport os\n\nprint(os.listdir())\n\n['.git', '.github', '.gitignore', '.quarto', 'basic.qmd', 'control_flow.qmd', 'data_structures.qmd', 'docs', 'exceptions.qmd', 'exceptions_files', 'functions.qmd', 'index.qmd', 'input_and_output.qmd', 'LICENSE', 'modules.qmd', 'more.qmd', 'object_oriented_programming.qmd', 'operators_and_expressions.qmd', 'practical_code', 'problem_solving.qmd', 'python-logo-only.svg', 'README.md', 'README.zh-CN.md', 'references.bib', 'references.qmd', 'standard_library.ipynb', 'standard_library.qmd', 'standard_library_files', '_book', '_quarto.yml']\n\n\n\n\n11.2.3 os.mkdir()\nos.mkdir()创建一个新目录。\nimport os\n\nos.mkdir(r'practical_code/standard_library/newdir')\n\n\n11.2.4 os.remove()\nos.remove()删除一个文件。\nimport os\n\nos.remove(r'practical_code/standard_library/newdir')\n\n\n11.2.5 os.rmdir()\nos.rmdir()删除一个目录。\nimport os\n\nos.rmdir(r'practical_code/standard_library/newdir')",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>标准库</span>"
    ]
  },
  {
    "objectID": "standard_library.html#logging模块",
    "href": "standard_library.html#logging模块",
    "title": "11  标准库",
    "section": "11.3 logging模块",
    "text": "11.3 logging模块\nlogging模块提供了一个灵活的方式来记录日志信息。\nlogging模块的基本语法如下：\n\nimport logging\n\nlogging.debug('This is a debug message')\nlogging.info('This is an info message')\nlogging.warning('This is a warning message')\nlogging.error('This is an error message')\nlogging.critical('This is a critical message')\n\nWARNING:root:This is a warning message\nERROR:root:This is an error message\nCRITICAL:root:This is a critical message\n\n\n此外，logging模块还提供了一些配置选项，可以将日志信息输出到指定位置，或者指定日志的格式、等级等。\n以下是一个更复杂一点的例子：\n\nimport os\nimport logging\n\nlogging_file = os.path.join(os.getcwd(), 'practical_code/standard_library/logging.log')\n\nprint(\"Logging to\", logging_file)\n\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    filename=logging_file,\n    filemode='w'\n)\n\nlogging.debug('This is a debug message')\nlogging.info('This is an info message')\nlogging.warning('This is a warning message')\n\nWARNING:root:This is a warning message\n\n\nLogging to C:\\Code\\MyProjects\\My-Python-Learning\\practical_code/standard_library/logging.log\n\n\n在上述的示例代码中：\n\nlogging_file是日志文件的路径，这里配置为practical_code/standard_library/logging.log\nlogging.basicConfig()函数用于配置日志的格式、等级、输出位置等\nlogging.debug()、logging.info()、logging.warning()等函数用于记录日志信息\nfilemode='w'表示以写入模式打开日志文件，如果文件已经存在，会被覆盖\n%(asctime)s、%(name)s、%(levelname)s、%(message)s是日志格式的占位符，分别表示日志记录的时间、日志记录的名称、日志的等级、日志的信息",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>标准库</span>"
    ]
  },
  {
    "objectID": "standard_library.html#每周模块系列",
    "href": "standard_library.html#每周模块系列",
    "title": "11  标准库",
    "section": "11.4 每周模块系列",
    "text": "11.4 每周模块系列\n除了上述介绍的模块外，还有许多其他有用的标准库模块，例如调试、测试、文件处理、网络通信、日期和时间处理、数学、科学、加密等等。\n此外，Doug Hellmann的Python模块每周精选是一个很好的资源，它介绍了Python标准库中的许多模块。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>标准库</span>"
    ]
  },
  {
    "objectID": "more.html",
    "href": "more.html",
    "title": "12  更多",
    "section": "",
    "text": "12.1 字符串方法\n字符串实现了所有常见的序列操作，如索引、切片、连接、重复、成员资格检查等。此外，字符串还提供了一些特有的方法，用于查找、替换、大小写转换等。\n在Python中，常用的字符串方法有：",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>更多</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "我的Python学习笔记",
    "section": "",
    "text": "前言\n欢迎阅读《我的python学习笔记》！这里是我学习 Python 的笔记和实践记录。\n在我的 Python 学习之旅中，我使用 Quarto 记录了一系列的交互式笔记。我采用了 Quarto 书籍项目的形式，以便在阅读材料的同时，观看和执行相关的嵌入式代码。\n本仓库下的 ‘master-zh’ 和 ‘master-en’ 分支分别存放着我制作的中文和英文版本交互式笔记。\n此外，对于一些简单的代码实践，我将它们放置在 ‘practical_code’ 文件夹中。可以在这里查看我在学习 Python 过程中的实战项目和练习。\n目前，这些笔记是基于Swaroopch C H的书籍《A Byte of Python》(CH 2024)而编写的，该书采用CC BY-SA 3.0许可证。\n除非另有说明，这些笔记采用CC BY-SA 4.0许可证发布。\n在学完这本书之后，我可能会参考其他的书籍更进一步完善这本笔记。\n\n\n\n\nCH, Swaroop. 2024. “Swaroopch/Byte-of-Python.” https://github.com/swaroopch/byte-of-python.",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "参考文献",
    "section": "",
    "text": "CH, Swaroop. 2024. “Swaroopch/Byte-of-Python.”\nhttps://github.com/swaroopch/byte-of-python.",
    "crumbs": [
      "参考文献"
    ]
  },
  {
    "objectID": "more.html#字符串方法",
    "href": "more.html#字符串方法",
    "title": "12  更多",
    "section": "",
    "text": "str.startswith(prefix[, start[, end]])：检查字符串是否以指定的前缀开头。\nstr.endswith(suffix[, start[, end]])：检查字符串是否以指定的后缀结尾。\nstr.title()：将字符串中的每个单词的首字母大写。\nstr.upper()：将字符串中的所有字母大写。\nstr.lower()：将字符串中的所有字母小写。\nstr.strip([chars])：去除字符串首尾的指定字符。如果不指定参数，则默认去除空白字符。\nstr.lstrip([chars])：去除字符串开头的指定字符。如果不指定参数，则默认去除空白字符。\nstr.rstrip([chars])：去除字符串结尾的指定字符。如果不指定参数，则默认去除空白字符。\nstr.replace(old, new[, count])：将字符串中的指定子串替换为新的子串。\nstr.removeprefix(prefix)：去除字符串开头的指定前缀。\nstr.removesuffix(suffix)：去除字符串结尾的指定后缀。",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>更多</span>"
    ]
  },
  {
    "objectID": "more.html#python-推导式comprehensions",
    "href": "more.html#python-推导式comprehensions",
    "title": "12  更多",
    "section": "12.2 Python 推导式（Comprehensions）",
    "text": "12.2 Python 推导式（Comprehensions）\nPython 推导式是一种简洁且功能强大的语法，用于创建新的序列（如列表、集合、字典）或生成器。推导式允许你在一行代码中将循环和条件语句组合起来，提高代码的可读性和效率。\nPython 提供了四种类型的推导式：\n\n列表推导式（List Comprehension）\n集合推导式（Set Comprehension）\n字典推导式（Dictionary Comprehension）\n生成器表达式（Generator Expression）\n\n\n12.2.1 列表推导式（List Comprehension）\n列表推导式用于创建新的列表。其语法如下：\n[expression for item in iterable if condition]\n\nexpression：表达式，用于对每个元素进行操作或转换。\nitem：迭代器变量，表示当前迭代的元素。\niterable：可迭代对象，如列表、元组、字符串等。\nif condition：可选的条件语句，用于过滤元素。\n\n示例：\n\nsquares = [x ** 2 for x in range(1, 6)]\n# 输出：[1, 4, 9, 16, 25]\n\n\n\n12.2.2 集合推导式（Set Comprehension）\n集合推导式用于创建新的集合。其语法与列表推导式类似，但使用大括号 {} 而不是方括号 []。\nunique_squares = {x ** 2 for x in [1, 1, 2, 3, 3, 4]}\n# 输出：{1, 4, 9, 16}\n\n\n12.2.3 字典推导式（Dictionary Comprehension）\n字典推导式用于创建新的字典。其语法如下：\n{key_expression: value_expression for item in iterable if condition}\n\nkey_expression：表达式，用于生成字典的键。\nvalue_expression：表达式，用于生成字典的值。\nitem、iterable 和 if condition 的含义与列表推导式相同。\n\n示例：\n\nsquare_dict = {x: x ** 2 for x in range(1, 6)}\n# 输出：{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n\n\n12.2.4 生成器表达式（Generator Expression）\n生成器表达式用于创建生成器对象。其语法与列表推导式类似，但使用圆括号 () 而不是方括号 []。生成器表达式是延迟计算的，只有在需要时才会生成数值，因此对于大型数据集或无限序列非常有用。\n\nsquare_generator = (x ** 2 for x in range(1, 6))\nfor square in square_generator:\n    print(square)\n# 输出：\n# 1\n# 4\n# 9\n# 16\n# 25\n\n1\n4\n9\n16\n25\n\n\n值得注意的是，生成器表达式并不局限于生成特定的值序列。它可以根据需求生成任意类型的对象，如字符串、元组、集合等，甚至是常量值。\n下面是一个例子：\n\ndef count_failed_students(student_scores):\n    \"\"\"Count the number of failing students out of the group provided.\n\n    :param student_scores: list - containing int student scores.\n    :return: int - count of student scores at or below 40.\n    \"\"\"\n    return sum(1 for score in student_scores if score &lt;= 40)\n\n在这个函数里，我们需要统计学生成绩中不及格的人数。我们使用了生成器表达式 sum(1 for score in student_scores if score &lt;= 40) 来计算不及格的学生人数。这里的生成器表达式返回的是一个生成器对象，它会在迭代时逐个生成值 1，最终通过 sum() 函数将这些值相加得到不及格的学生人数。\n这种用法可能不太常见，但它展示了生成器表达式的灵活性。它不仅可以生成基于表达式的值序列，还可以根据条件生成常量值，用于计数、过滤或其他目的。\n\n\n12.2.5 嵌套推导式\n推导式还可以嵌套使用，以生成更复杂的结构。例如，你可以使用嵌套的列表推导式来创建矩阵：\n\nmatrix = [[i * j for j in range(1, 4)] for i in range(1, 4)]\n# 输出：[[1, 2, 3], [2, 4, 6], [3, 6, 9]]\n\n\n\n12.2.6 总结\n推导式是 Python 中一种强大且表达力强的特性，可以简化代码并提高可读性。它们允许你在一行代码中将循环和条件语句组合起来，用于创建新的列表、集合、字典或生成器。\n理解和使用推导式是编写 Pythonic 代码的重要部分。合理运用推导式可以使你的代码更加简洁、优雅和高效。",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>更多</span>"
    ]
  },
  {
    "objectID": "more.html#字典推导式dictionary-comprehension",
    "href": "more.html#字典推导式dictionary-comprehension",
    "title": "12  更多",
    "section": "12.3 字典推导式（Dictionary Comprehension）",
    "text": "12.3 字典推导式（Dictionary Comprehension）\n字典推导式用于创建新的字典。其语法如下：\n{key_expression: value_expression for item in iterable if condition}\n\nkey_expression：表达式，用于生成字典的键。\nvalue_expression：表达式，用于生成字典的值。\nitem、iterable 和 if condition 的含义与列表推导式相同。\n\n示例：\n\nsquare_dict = {x: x ** 2 for x in range(1, 6)}\n# 输出：{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>更多</span>"
    ]
  },
  {
    "objectID": "more.html#生成器表达式generator-expression",
    "href": "more.html#生成器表达式generator-expression",
    "title": "12  更多",
    "section": "12.4 生成器表达式（Generator Expression）",
    "text": "12.4 生成器表达式（Generator Expression）\n生成器表达式用于创建生成器对象。其语法与列表推导式类似，但使用圆括号 () 而不是方括号 []。生成器表达式是延迟计算的，只有在需要时才会生成数值，因此对于大型数据集或无限序列非常有用。\n\nsquare_generator = (x ** 2 for x in range(1, 6))\nfor square in square_generator:\n    print(square)\n# 输出：\n# 1\n# 4\n# 9\n# 16\n# 25\n\n1\n4\n9\n16\n25\n\n\n值得注意的是，生成器表达式并不局限于生成特定的值序列。它可以根据需求生成任意类型的对象，如字符串、元组、集合等，甚至是常量值。\n下面是一个例子：\n\ndef count_failed_students(student_scores):\n    \"\"\"Count the number of failing students out of the group provided.\n\n    :param student_scores: list - containing int student scores.\n    :return: int - count of student scores at or below 40.\n    \"\"\"\n    return sum(1 for score in student_scores if score &lt;= 40)\n\n在这个函数里，我们需要统计学生成绩中不及格的人数。我们使用了生成器表达式 sum(1 for score in student_scores if score &lt;= 40) 来计算不及格的学生人数。这里的生成器表达式返回的是一个生成器对象，它会在迭代时逐个生成值 1，最终通过 sum() 函数将这些值相加得到不及格的学生人数。\n这种用法可能不太常见，但它展示了生成器表达式的灵活性。它不仅可以生成基于表达式的值序列，还可以根据条件生成常量值，用于计数、过滤或其他目的。 ### 嵌套推导式\n推导式还可以嵌套使用，以生成更复杂的结构。例如，你可以使用嵌套的列表推导式来创建矩阵：\n\nmatrix = [[i * j for j in range(1, 4)] for i in range(1, 4)]\n# 输出：[[1, 2, 3], [2, 4, 6], [3, 6, 9]]\n\n\n12.4.1 总结\n推导式是 Python 中一种强大且表达力强的特性，可以简化代码并提高可读性。它们允许你在一行代码中将循环和条件语句组合起来，用于创建新的列表、集合、字典或生成器。\n理解和使用推导式是编写 Pythonic 代码的重要部分。合理运用推导式可以使你的代码更加简洁、优雅和高效。",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>更多</span>"
    ]
  }
]