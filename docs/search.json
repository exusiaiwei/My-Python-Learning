[
  {
    "objectID": "basic.html",
    "href": "basic.html",
    "title": "1  Basic",
    "section": "",
    "text": "1.1 Literal Constants\nLiteral constants are fixed values that are directly written in the code and do not change during program execution.\nIn Python, there are several types of literal constants, including:\nLiteral constants are used to assign values to variables, perform calculations, and define conditions in Python programs.\nThey provide a way to represent fixed values directly in the code, making the program more understandable and maintainable.\nx = 10  # Assign an integer literal to the variable\ny = 3.14  # Assign a float literal to the variable\nname = 'John'  # String enclosed in single quotes\nmessage = \"Hello, world!\"  # String enclosed in double quotes\nis_active = True  # Assign a boolean literal to the variable\nempty_value = None  # Assign a None literal to the variable",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basic</span>"
    ]
  },
  {
    "objectID": "basic.html#literal-constants",
    "href": "basic.html#literal-constants",
    "title": "1  Basic",
    "section": "",
    "text": "Numeric literals: integers, floating-point numbers, and complex numbers.\nString literals: sequences of characters enclosed in single quotes (’’) or double quotes (““).\nBoolean literals: True and False.\nNone: a special constant that represents the absence of a value.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basic</span>"
    ]
  },
  {
    "objectID": "basic.html#string",
    "href": "basic.html#string",
    "title": "1  Basic",
    "section": "1.2 String",
    "text": "1.2 String\nThe string is a data type used to represent text data.\nFeatures:\n\nIn Python, you can specify a string with single or double quotes.\nTriple quotes can be used to specify a multi-line string.\nThe value of a string cannot be modified.\n\n\n# Create a string\nname = \"Alice\"\n\n# Concatenate strings\ngreeting = \"Hello, \" + name + \"!\"\n\n# Print the string\nprint(greeting)  # Output: Hello, Alice!\n\n# Get the length of the string\nlength = len(name)\nprint(length)  # Output: 5\n\n# Slice the string\nsubstring = name[1:3]\nprint(substring)  # Output: li\n\n# Replace in the string\nnew_name = name.replace(\"A\", \"B\")\nprint(new_name)  # Output: Blice\n\nHello, Alice!\n5\nli\nBlice\n\n\n\n1.2.1 String formatting function\nThe format function of a string can pass the corresponding parameters into the string.\n\nThe placeholder is {}\nCan specify the insertion order by index, python counts from 0.\nParameters can be named.\n\n\nname = \"Alice\"\nage = 25\n\n# Use placeholders to insert variables\ngreeting = \"Hello, my name is {} and I am {} years old.\".format(name, age)\nprint(greeting)  # Output: Hello, my name is Alice and I am 25 years old.\n\n# You can specify the order of insertion by index\ngreeting2 = \"Hello, my name is {1} and I am {0} years old.\".format(age, name)\nprint(greeting2)  # Output: Hello, my name is Alice and I am 25 years old.\n\n# You can use keyword parameters to specify the value to be inserted\ngreeting3 = \"Hello, my name is {name} and I am {age} years old.\".format(name=\"Alice\", age=25)\nprint(greeting3)  # Output: Hello, my name is Alice and I am 25 years old.\n\nHello, my name is Alice and I am 25 years old.\nHello, my name is Alice and I am 25 years old.\nHello, my name is Alice and I am 25 years old.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basic</span>"
    ]
  },
  {
    "objectID": "basic.html#escape-sequences",
    "href": "basic.html#escape-sequences",
    "title": "1  Basic",
    "section": "1.3 Escape Sequences",
    "text": "1.3 Escape Sequences\nEscape sequences are a special sequence of characters that start with a backslash (\\) and are followed by one or more characters. They are used to represent non-printing characters, special characters, or characters with special meanings.\nEscape sequences start with a backslash (\\) and are followed by one or more characters to represent a specific character or operation. By using escape sequences, we can insert these special characters into strings, rather than interpreting them as ordinary characters.\nDefinition and Characteristics of Escape Sequences:\n\nEscape sequences start with a backslash (\\).\nEscape sequences are formed by one or more characters.\nEscape sequences are used to represent non-printing characters, special characters, or characters with special meanings.\nEscape sequences can be used in strings, character constants, regular expressions, and other contexts.\n\nHere are some common escape sequences and what they represent:\n\n\\n: newline\n\\t: tab\n\\r: carriage return\n\\': single quote\n\\\": double quote\n\\\\: backslash\n\n\n# Using escape sequences to represent special characters in strings:\nprint(\"Hello\\tWorld\")  # Output: Hello    World\nprint(\"I\\'m a programmer\")  # Output: I'm a programmer\nprint(\"She said, \\\"Hello!\\\"\")  # Output: She said, \"Hello!\"\nprint(\"\\\"I love you.\\\" \\n \\\"Me too.\\\"\")\n\n# Using escape sequences to match special characters in regular expressions:\nimport re\npattern = r\"\\d+\"  # Matches one or more digits\nresult = re.findall(pattern, \"12345\")\nprint(result)  # Output: ['12345']\n\nHello   World\nI'm a programmer\nShe said, \"Hello!\"\n\"I love you.\" \n \"Me too.\"\n['12345']",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basic</span>"
    ]
  },
  {
    "objectID": "basic.html#variables",
    "href": "basic.html#variables",
    "title": "1  Basic",
    "section": "1.4 Variables",
    "text": "1.4 Variables\nA variable is a concept in Python that is used to store and manipulate data. It can store various types of data, such as integers, floating-point numbers, strings, etc.\nFeatures:\n\nYou can store data in a variable via an assignment operation.\nYou can use the variable name to access the data stored in the variable.\nThe value of a variable can be modified at any time.\nVariables can be used and passed at different locations in a program.\nThe scope of a variable can be limited within a specific block of code.\n\n\ni = 5\nprint(i)\n\ne = ( i + 1 ) * 2\n\nprint(e)\n\ns = '''This is a multi-line string.\nThis is the second line.'''\n\nprint(s)\n\n5\n12\nThis is a multi-line string.\nThis is the second line.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basic</span>"
    ]
  },
  {
    "objectID": "basic.html#execution-logic",
    "href": "basic.html#execution-logic",
    "title": "1  Basic",
    "section": "1.5 Execution Logic",
    "text": "1.5 Execution Logic\n\n1.5.1 Logical Lines and Physical Lines\nA logical line refers to a line in the code that represents a statement or command, while a physical line refers to the text that actually occupies a line in the code file.\nA logical line can span multiple physical lines by connecting multiple physical lines into one logical line using line connectors (\\). A physical line is the actual number of lines in the code file, with each physical line ending with a newline character (\\n).\nFeatures of Logical Lines:\n\nA logical line can contain one or more statements or commands.\nLogical lines can span multiple physical lines.\nA logical line ends with a newline character (\\n).\n\nFeatures of Physical Lines:\n\nPhysical lines are the actual number of lines in the code file.\nEach physical line ends with a newline character (\\n).\n\nPython encourages each physical line to correspond to one logical line, that is, one statement per line, to ensure code readability.\n\n# Example of a logical line spanning multiple physical lines\nx = 1 + \\\n    2 + \\\n    3\n\nprint(x)\n\n# Example of logical lines being the same as physical lines\ny = 5\nprint(y)\n\ny = 5;\nprint(y);\n\ny = 5; print(y);\n\ny = 5; print(y)\n\n6\n5\n5\n5\n5\n\n\n\n\n1.5.2 Indentation\nIndentation is a syntax rule in Python used to represent the hierarchical structure of the code blocks. In Python, the indentation is mandatory and it determines the execution order and logical relations of the code. The level of indentation of the logical lines determines the grouping of the statements. Statements in the same group form a block of code.\nBasic Concepts:\n\nIndentation is achieved through the use of spaces or tabs.\nThe amount and style of indentation must remain consistent, typically four spaces are recommended for indentation.\nThe hierarchal structure of the indentation determines the nesting relation of the code blocks.\n\nFeatures:\n\nIndentation is used to define code blocks for functions, loops, conditional statements, and more.\nIndentation can enhance the readability and maintainability of the code.\nIndentation errors can lead to syntax errors or logical errors.\n\nCode Example: Here is one example where indentation forms blocks of code:\n\ndef greet(name):\n    if name == \"Alice\":\n        print(\"Hello, Alice!\")\n    else:\n        print(\"Hello, stranger!\")\n\ngreet(\"Bob\")\n\nHello, stranger!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basic</span>"
    ]
  },
  {
    "objectID": "operators_and_expressions.html",
    "href": "operators_and_expressions.html",
    "title": "2  Operators and Expressions",
    "section": "",
    "text": "2.1 Operators",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operators and Expressions</span>"
    ]
  },
  {
    "objectID": "operators_and_expressions.html#operators",
    "href": "operators_and_expressions.html#operators",
    "title": "2  Operators and Expressions",
    "section": "",
    "text": "2.1.1 1. Arithmetic Operators:\n\nAddition Operator (+): Used to add two values. It can handle numeric values, strings, and lists, among other types.\nSubtraction Operator (-): Used to subtract one value from another. If the first operand is missing, it defaults to 0.\nMultiplication Operator (*): Used to multiply two values. When used with strings, it returns a string repeated a fixed number of times.\nDivision Operator (/): Used to divide one value by another.\nModulus Operator (%): Used to calculate the remainder of two values divided.\nExponentiation Operator (**): Used to calculate the exponent of a value.\nFloor Division Operator (//): Used to calculate the integer part of the division of two values. The answer is rounded down to the nearest integer value; if either operand is a floating-point number, the answer will be a floating-point number.\n\n\n# Addition Operator\nx1 = 2 + 3\nprint(x1)\nx2 = \"a\" + \"b\"\nprint(x2)\n# Subtraction Operator\ny1 = 3 - 2\nprint(y1)\ny2 = - 2\nprint(y2)\n# Multiplication Operator\na1 = 5 * 6\nprint(a1)\na2 = \"my\" * 6\nprint(a2)\n# Division Operator\nb = 50 / 25\nprint(b)\n# Modulus Operator\nc1 = 26 % 3\nprint(c1)\nc2 = -25.5 % 2.25\nprint(c2)\n# Exponentiation Operator\nd= 2 ** 3\nprint(d)\n# Floor Division Operator\ne1 = 28 // 3\nprint(e1)\ne2 = 9//1.8\nprint(e2)\n\n5\nab\n1\n-2\n30\nmymymymymymy\n2.0\n2\n1.5\n8\n9\n4.0\n\n\n\n\n2.1.2 2. Comparison Operators:\n\nEquality Operator (==): Used to check if two values are equal.\nInequality Operator (!=): Used to check if two values are not equal.\nGreater Than Operator (&gt;): Used to check if one value is greater than another.\nLess Than Operator (&lt;): Used to check if one value is less than another.\nGreater Than or Equal Operator (&gt;=): Used to check if one value is greater than or equal to another.\nLess Than or Equal Operator (&lt;=): Used to check if one value is less than or equal to another.\n\n\na = 1 == 1\nprint(a)\nb = 1 != 1\nprint(b)\nc = 2 &gt; 1\nprint(c)\nd = 2 &lt; 1\nprint(d)\ne = 2 &gt;= 2\nprint(e)\nf = 1 &lt;= 2\nprint(f)\n\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\n\n\n\n\n2.1.3 3. Logical Operators (Boolean Operators):\n\nAnd Operator (and): Used to check if multiple conditions are all true. The result is true only when all conditions are true.\nOr Operator (or): Used to check if at least one condition is true. The result is true as long as one condition is true.\nNot Operator (not): Used to negate a condition.\n\n\n# Logical AND operator (and): The result is true only when all conditions are true\na = True and True\nprint(a)  # Output: True\n\nb = True and False\nprint(b)  # Output: False\n\n# Logical OR operator (or): The result is true as long as one condition is true\nc = True or False\nprint(c)  # Output: True\n\nd = False or False\nprint(d)  # Output: False\n\n# Logical NOT operator (not): Negates the condition\ne = not True\nprint(e)  # Output: False\n\nf = not False\nprint(f)  # Output: True\n\nTrue\nFalse\nTrue\nFalse\nFalse\nTrue\n\n\n\n2.1.3.1 Short-circuit evaluation:\nWhen using logical operators (such as and and or) to connect multiple conditional expressions, Python determines whether to evaluate all conditions based on the characteristics of the operator.\n\nIn the case of the and operator, if any condition is False, the entire expression will be False, and Python will stop evaluating the remaining values and immediately return False.\nIn the case of the or operator, if any condition is True, the entire expression will be True, and Python will stop evaluating the remaining values and immediately return True. Short-circuit evaluation can improve code efficiency and performance by avoiding unnecessary computations and evaluations.\n\n\n# Example of short-circuit evaluation\na = 4\nb = 0\n\nif b != 0 and a / b &lt; 1:\n    print(\"Condition is satisfied\")\nelse:\n    print(\"Condition is not satisfied\")\n\nCondition is not satisfied\n\n\nIn the above example, short-circuit evaluation is used to skip the division by zero operation (a / b) as the overall result is determined to be False at the step b != 0. This avoids the error that would occur if the division operation was executed without short-circuit evaluation.\n\n\n\n2.1.4 4. Bitwise Operators:\nBit: The smallest unit for storing and processing data. A bit can only hold two possible values: 0 or 1. Numbers in a computer are stored in binary form, which consists of 0s and 1s.\nBitwise Shift: Bitwise shift is an operation used to modify the value of a number by shifting its bits. There are two types of bitwise shifts: left shift and right shift. Left shift adds a 0 to the right end of the number, while right shift removes the rightmost bit.\n\nIn decimal, shifting one place to the left (adding a 0 at the end) is equivalent to multiplying by 10, and shifting one place to the right (removing the rightmost digit) is equivalent to dividing by 10.\nIn binary, shifting one place to the left (adding a 0 at the end) is equivalent to multiplying by 2, and shifting one place to the right (removing the rightmost bit) is equivalent to dividing by 2.\n\nBitwise Operators:\n\nBitwise AND Operator (&): Performs a bitwise AND operation on two values. If both corresponding bits are 1, the result is 1; otherwise, it is 0.\nBitwise OR Operator (|): Performs a bitwise OR operation on two values. If at least one of the corresponding bits is 1, the result is 1; otherwise, it is 0.\nBitwise XOR Operator (^): Performs a bitwise XOR operation on two values. If one of the corresponding bits is 1 and the other is 0, the result is 1; otherwise, it is 0 (i.e., the result is 0 if both bits are the same).\nBitwise NOT Operator (~): Performs a bitwise NOT operation on a value. It flips each bit, changing 0 to 1 and 1 to 0. The bitwise NOT of x is -(x+1).\nLeft Shift Operator (&lt;&lt;): Shifts a value to the left by a specified number of bits.\nRight Shift Operator (&gt;&gt;): Shifts a value to the right by a specified number of bits.\n\n\n# Define two variables\na = 60  # The binary representation of 60 is 0011 1100\nb = 13  # The binary representation of 13 is 0000 1101\n\nprint(a, \"in binary is\", bin(a))\nprint(b, \"in binary is\", bin(b))\n\nprint(\"a & b =\", a & b)  # Bitwise AND operation. The binary result is 0000 1100, which is 12 in decimal\nprint(\"a | b =\", a | b)  # Bitwise OR operation. The binary result is 0011 1101, which is 61 in decimal\nprint(\"a ^ b =\", a ^ b)  # Bitwise XOR operation. The binary result is 0011 0001, which is 49 in decimal\nprint(\"~a =\", ~a)  # Bitwise NOT operation. The binary result is 1100 0011, which is -61 in decimal (note: it is a negative number)\n\nprint(\"a &lt;&lt; 2 =\", a &lt;&lt; 2)  # Left shift operation by 2 bits. The binary result is 1111 0000, which is 240 in decimal\nprint(\"a &gt;&gt; 2 =\", a &gt;&gt; 2)  # Right shift operation by 2 bits. The binary result is 0000 1111, which is 15 in decimal\n\n60 in binary is 0b111100\n13 in binary is 0b1101\na & b = 12\na | b = 61\na ^ b = 49\n~a = -61\na &lt;&lt; 2 = 240\na &gt;&gt; 2 = 15\n\n\n\n\n2.1.5 5. Assignment Operator：\n\nAddition Assignment Operator (+=): Used to add a value to a variable and assign the result to that variable.\nSubtraction Assignment Operator (-=): Used to subtract a value from a variable and assign the result to that variable.\nMultiplication Assignment Operator (*=): Used to multiply a value with a variable and assign the result to that variable.\nDivision Assignment Operator (/=): Used to divide a value by a variable and assign the result to that variable.\nModulus Assignment Operator (%=): Used to calculate the remainder of two values divided and assign the result to a variable.\nExponentiation Assignment Operator (**=): Used to calculate the exponent of a value and assign the result to a variable.\nFloor Division Assignment Operator (//=): Used to calculate the integer part of two values divided and assign the result to a variable.\n\n\n# Simple Assignment Operator (=)\na = 10\nprint(\"a =\", a)  # Output: a = 10\n\n# Addition Assignment Operator (+=)\na += 2\nprint(\"a =\", a)  # Output: a = 12\n\n# Subtraction Assignment Operator (-=)\na -= 2\nprint(\"a =\", a)  # Output: a = 10\n\n# Multiplication Assignment Operator (*=)\na *= 2\nprint(\"a =\", a)  # Output: a = 20\n\n# Division Assignment Operator (/=)\na /= 2\nprint(\"a =\", a)  # Output: a = 10.0\n\n# Modulus Assignment Operator (%=)\na %= 3\nprint(\"a =\", a)  # Output: a = 1.0\n\n# Exponentiation Assignment Operator (**=)\na **= 3\nprint(\"a =\", a)  # Output: a = 1.0\n\n# Floor Division Assignment Operator (//=)\na = 10\na //= 3\nprint(\"a =\", a)  # Output: a = 3\n\na = 10\na = 12\na = 10\na = 20\na = 10.0\na = 1.0\na = 1.0\na = 3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operators and Expressions</span>"
    ]
  },
  {
    "objectID": "operators_and_expressions.html#expressions",
    "href": "operators_and_expressions.html#expressions",
    "title": "2  Operators and Expressions",
    "section": "2.2 Expressions",
    "text": "2.2 Expressions\nAn expression is a combination of operators and operands used to calculate and generate values.\nIn Python, expressions can be simple arithmetic expressions or complex logical expressions.\nFor example, here are some common examples of expressions:\n\nArithmetic expression: 2 + 3 * 4\nLogical expression: (x &gt; 5) and (y &lt; 10)\nString concatenation expression: ‘Hello’ + ‘World’\nList comprehension expression: [x for x in range(10) if x % 2 == 0]\n\nThe value of an expression is calculated based on the types of operands and the rules of operators. When evaluating an expression, Python determines the order of operations based on certain precedence and associativity rules.\n\n2.2.1 Order of Evaluation\nSimilar to how multiplication has higher precedence than addition in mathematics, expressions in Python also have different levels of precedence. Python evaluates operators and expressions with higher precedence first, and then evaluates expressions with lower precedence.\nFor complex expressions, although you can rely on remembering the precedence rules to ensure the correct order of operations, it is generally recommended to use parentheses explicitly to indicate the order of evaluation for clarity and readability.\nIn cases where operators have the same precedence, the order of evaluation is determined by their associativity. Associativity can be left-associative or right-associative. - Left-associative means evaluation proceeds from left to right. Common examples include arithmetic operators (such as addition, subtraction, multiplication, division, etc.), comparison operators, and most bitwise operators. - Right-associative means evaluation proceeds from right to left. Common examples include exponentiation operator, assignment operator (=), and compound assignment operators (such as +=, -=, *=, /=, %=, **=, //=, &=, ^=, &gt;&gt;=, &lt;&lt;=).\n\n# Left-associative\nprint(1 - 2 + 3)  # Output: 2\n\n# Right-associative\n# For the exponentiation operator, Python evaluates from right to left\n# So it first calculates 4**2, which is 16, and then calculates 2**16\nprint(2 ** 4 ** 2)  # Output: 65536\n# Explicitly specify the order of evaluation\nprint((2 ** 4) ** 2)  # Output: 256\n\n2\n65536\n256\n\n\n\n\n2.2.2 Mathematical Operations and Shortcut for Assignment\nA common practice is to perform mathematical operations on variables and then assign the result back to the variable, and there is a shortcut for this type of expression.\n\na = 2\na = a * 3\nprint(\"a =\", a)\n\nb = 2\nb *= 3\nprint(\"b =\", b)\n\na = 6\nb = 6",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Operators and Expressions</span>"
    ]
  },
  {
    "objectID": "control_flow.html",
    "href": "control_flow.html",
    "title": "3  Control Flow",
    "section": "",
    "text": "3.1 if Statement\nConditional statements allow different code blocks to be executed based on the truth or falsehood of a condition. The if statement is used to execute a code block when a condition is true, while the else statement is used to execute a code block when a condition is false.\n# The sample code comes from A Byte of Python\n# Here we define the guess value directly, instead of obtaining it through input\n# This is because environments like Quarto and Jupyter Notebook can't handle intermediate input (input function)\n# Such environments are designed to execute code in bulk. Once all cells start executing, they can complete all runs without human intervention\n# Therefore, we directly set a value here, instead of obtaining it through input\nguess = 20  \n\nnumber = 23\n\nprint('Your guess is:', guess)\n\nif guess == number:\n    print('Congratulations, you guessed it right.')\n    print('(But you did not win any prize!)')\nelif guess &lt; number:\n    # Another code block\n    print('No, it is a little bit larger than that.')\n    # You can do anything you want to do in the code block...\nelse:\n    print('No, it is a little bit smaller than that.')\n    # You will only get here if your guess is greater than number\n\nprint('Done')\n# This last statement will always be executed,\n# after if statement.\n\n# If you want to obtain user input in other environments (such as standard Python environment or IDLE),\n# You can change the fifth line of code to \"guess = int(input('Enter an integer:'))\".\n# This way, you can receive user input as the value of 'guess', and then perform subsequent judgement.\n\nYour guess is: 20\nNo, it is a little bit larger than that.\nDone\nThe knowledge points in the example code:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "control_flow.html#if-statement",
    "href": "control_flow.html#if-statement",
    "title": "3  Control Flow",
    "section": "",
    "text": "The input function prints a string to the screen and waits for input. After the input is entered, the input() function returns the input as a string.\nint is a class, and here it is used to convert a string to an integer. If you need to convert to a float, you can use float.\nIndentation is used to classify statements into different code blocks. Consistent indentation should be followed.\nif, elif, and else statements must have a colon at the end of the logical line, followed by the corresponding code block.\nThe elif statement combines two related if else-if else statements into a single if-elif-else statement. It can simplify the program and reduce indentation.\nIt is possible to nest one if statement inside another if statement, which is called a nested if statement.\nelif and else statements are optional. An if statement can be effective with only the if part.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "control_flow.html#while-statement",
    "href": "control_flow.html#while-statement",
    "title": "3  Control Flow",
    "section": "3.2 while Statement",
    "text": "3.2 while Statement\nThe while statement allows a set of statements to be repeatedly executed as long as a condition is true. The while statement is a type of loop statement and can include an optional if statement.\n\n# The sample code comes from A Byte of Python\nnumber = 23\nrunning = True\n\n# As we can't use input() function in Quarto or Jupyter Notebook, we set up a preset guess list here\nguesses = [20, 25, 23]  \nguesses_iter = iter(guesses)  # Create an iterator \n\nwhile running:\n    # In Quarto and Jupyter Notebook, 'input()' function needs to be rewritten as iterating guess value from preset list\n    guess = next(guesses_iter)\n    print('Your guess is:', guess)\n\n    if guess == number:\n        # If the guess value equals to set value, it will print that you guess right and end the while loop\n        print('Congratulations! You guess it right.')\n        running = False\n    elif guess &lt; number:\n        # It will also show that the preset guess value is too low\n        print('No, it is a little higher than that.')\n    else:\n        # It will also show that the preset guess value is too high\n        print('No, it is a little lower than that.')\n\nprint('Done')\n\n# When the iterator 'guesses_iter' traverse all guesses, the program will end\n# If you are running it in a real Python environment or IDLE, you can comment out the line 'guess = next(guesses_iter)'\n# and uncomment the line 'guess = int(input('Enter an integer : '))', and also comment out 'guesses' and 'guesses_iter'\n# Then it can achieve the continuous guessing of the user through the user input and continuous while loop\n\nYour guess is: 20\nNo, it is a little higher than that.\nYour guess is: 25\nNo, it is a little lower than that.\nYour guess is: 23\nCongratulations! You guess it right.\nDone\n\n\nThe knowledge points in the example code:\n\nBy setting the variable running to True before the while loop, the program checks if the variable running is True before executing the corresponding while block.\nAfter executing the block, the condition (i.e., the variable running) is checked again.\nIf the condition is true, the while block is executed again.\nIf the condition is false, the optional else block is executed, and then the next statement is continued.\nIf a while loop has an else clause, it will always be executed unless the loop is exited using a break statement.\nTrue and False are called boolean types and can be considered as equivalents of the values 1 and 0, respectively.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "control_flow.html#for-loop",
    "href": "control_flow.html#for-loop",
    "title": "3  Control Flow",
    "section": "3.3 for Loop",
    "text": "3.3 for Loop\nThe for..in statement is another type of loop statement that iterates over an object sequence, i.e., it iterates over each item in the sequence one by one.\nAt this point, a sequence can be seen as an ordered collection of items.\n\n# Example code from A Byte of Python\nfor i in range(1, 5):\n    print(i)\nelse:\n    print('The for loop is over')\n\n1\n2\n3\n4\nThe for loop is over\n\n\nThe knowledge points in the example code are as follows:\n\nThe built-in function range can generate a sequence of numbers.\nBy default, the step size of range is 1. The third number provided to range will be the step size, for example, range(1,5,2) gives [1,3]. The second number (i.e., the end number) is not included.\nrange generates only one number at a time. If you need the complete list of numbers, you need to call list().\nThe else part in a for loop is optional. If included, it will always be executed unless the loop is exited using the break statement.\nAlthough the example code only demonstrates a list of numbers, the for loop can be used with sequences composed of objects of any type.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "control_flow.html#break-statement",
    "href": "control_flow.html#break-statement",
    "title": "3  Control Flow",
    "section": "3.4 break statement",
    "text": "3.4 break statement\nThe break statement is called a jump statement, which can stop the execution of a loop statement even if the loop condition is not False or the sequence of items has not been fully iterated.\nIf a for or while loop is exited using break, the corresponding else block of the loop will not be executed.\n\n# The sample code comes from A Byte of Python\n# Set up a preset input list\ninputs = ['Hello', 'abcdef', '12345', 'quit']\n\n# Create an iterator\ninputs_iter = iter(inputs)\n\nwhile True:\n    # Get the input from the preset input list\n    s = next(inputs_iter)\n\n    print('The input string is: ', s)\n    if s == 'quit':\n        break\n    print('The length of the string is', len(s))\nprint('Done')\n\n# Here we use a preset input list and iterator to simulate user input\n# In each loop, we get an input from the list and check whether the input is 'quit'. If yes, we break the loop.\n# Otherwise, we print out the length of the input\n# This way, we can run the code in an environment like Quarto or Jupyter Notebook that does not support input()\n# If you want to run it in a real Python environment or IDLE,\n# you can comment out the line 's = next(inputs_iter)', uncomment the line 's = input('Enter something: ')',\n# also comment out 'inputs' and 'inputs_iter', and it will be back to its original state.\n\nThe input string is:  Hello\nThe length of the string is 5\nThe input string is:  abcdef\nThe length of the string is 6\nThe input string is:  12345\nThe length of the string is 5\nThe input string is:  quit\nDone\n\n\nThe knowledge points in the example code are as follows:\n\nThe built-in function len can measure the length of an input string.\nThe break statement can also be used with a for loop.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "control_flow.html#continue-statement",
    "href": "control_flow.html#continue-statement",
    "title": "3  Control Flow",
    "section": "3.5 continue statement",
    "text": "3.5 continue statement\nThe continue statement is used to skip the remaining statements in the current loop block and continue with the next iteration of the loop.\n\n# The sample code comes from A Byte of Python\n# Set up a preset input list\ninputs = ['Hello', 'abcdef', '12', '1234', 'quit']\n\n# Create an iterator\ninputs_iter = iter(inputs)\n\nwhile True:\n    # Get input from the preset input list\n    # s = input('Enter something : ')\n    s = next(inputs_iter)\n\n    print('The input string is: ', s)\n    if s == 'quit':\n        break\n    if len(s) &lt; 3:\n        print('Too short')\n        continue\n    print('Input length is sufficient')\n    # You can do anything you want to do in the code block...\nprint('Done')\n\n# This code can run smoothly in both Quarto and Jupyter environments. In each loop, \n# it will get an input from the preset string list and then perform different operations based on the length of this input:\n# 1. If the input is 'quit', then it will end the entire loop;\n# 2. If the length of the input is less than 3, then it will print 'Too short', and skip the rest of the current loop, and directly start the next loop;\n# 3. If the length of the input is not less than 3, then it will print 'Input length is sufficient'.\n\nThe input string is:  Hello\nInput length is sufficient\nThe input string is:  abcdef\nInput length is sufficient\nThe input string is:  12\nToo short\nThe input string is:  1234\nInput length is sufficient\nThe input string is:  quit\nDone",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "4  Functions",
    "section": "",
    "text": "4.1 Function Parameters\nFunctions can accept parameters and utilize these values to produce some effect.\nParameter:\nArgument:\nThis concept is analogous to a recipe and cooking. The list of ingredients on a recipe (e.g. certain grams of flour, certain grams of sugar) is like the parameter list, while the actual amount of flour and sugar you use is like the arguments.\n# Code sample from: A Byte of Python\ndef print_max(a, b):\n    if a &gt; b:  \n        print(a, 'is maximum') # Prints a is max  \n    elif a == b:\n        print(a, 'is equal to', b) # Prints a is equal to b\n    else:\n        print(b, 'is maximum') # Prints b is max\n\n# Directly pass literals  \nprint_max(3, 4)  \n\nx = 5\ny = 7\n\n# Pass variables as arguments \nprint_max(x, y)\n\n4 is maximum\n7 is maximum\nIn the sample code, we defined a function called print_max which contains two parameters a and b. We use an if..else statement to find out the larger number and print it out.\nThe first time calling the print_max function, we directly provide numbers as arguments. In the second case, we use variables x, y as arguments when calling the function. print_max(x, y) causes the value of parameter x to be assigned the value of argument x, and the value of parameter y to be assigned the value of argument y.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#function-parameters",
    "href": "functions.html#function-parameters",
    "title": "4  Functions",
    "section": "",
    "text": "When defining a function, we reserve some space for the function which are called parameters. Parameters are the receivers of the function definition.\nParameters are defined within the function header’s parentheses, separated by commas. They are accessible within the entire function body.\n\nParameters are variables used to store the values passed in during function calls (arguments).\n\n\n\nWhen calling a function, we pass in some values to the function, these values are called arguments. Arguments are the inputs of a function call.\n\nArguments assign concrete values to the parameters defined in the function. Also separated by commas.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#local-variables",
    "href": "functions.html#local-variables",
    "title": "4  Functions",
    "section": "4.2 Local Variables",
    "text": "4.2 Local Variables\n\nVariables declared inside a function definition are called “local variables”.\n\nThe scope of “local variables” is limited to within the function where it is declared, this constraint is called variable “scope”.\n\nA variable’s scope starts from where it is declared to the end of that code block or function.\n\nLocal variables inside functions are viewed as independent even if variables with the same names exist outside the function. Regardless of identical names, local variables inside functions have no relation with variables outside functions.\n\n\n# Code sample from: A Byte of Python\nx = 50  \n\ndef func(x):\n    print('x is', x) # Print x's value  \n    x = 2 # Modify local x's value\n    print('Changed local x to', x) # Prints modified x  \n\nfunc(x)  \nprint('x is still', x) # Prints original x  \n\nx is 50\nChanged local x to 2\nx is still 50\n\n\nThe first time printing variable x inside the function body, Python uses the value of the parameter declared before the function in the main block.\nNext, we assign the local variable x in the function a value of 2. When we modify the value of local variable x inside the function, the x defined in main block remains unaffected.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#the-global-statement",
    "href": "functions.html#the-global-statement",
    "title": "4  Functions",
    "section": "4.3 The global statement",
    "text": "4.3 The global statement\n\nWhen we need to assign values to variables defined on a global program level (i.e. not inside a specific scope like functions or classes), we normally use the global declaration statement (global statement).\n\nThe global statement tells Python we are working with a global variable instead of a local variable.\n\nNote that without using global, we cannot directly modify variables defined outside functions inside the function.\nWhen a variable that hasn’t been defined is referenced inside a function, Python will try to find that variable outside the function.\n\nDespite this, we don’t recommend this practice as it can confuse readers when trying to understand where that variable is defined.\n\nIf you want to operate on variables outside functions inside the function, it’s recommended to use the global statement to explicitly indicate you are manipulating a globally defined variable.\n\n\n# Code sample from: A Byte of Python\nx = 50  \n\ndef func():\n    global x\n\n    print('x is', x) # Print x's value   \n    x = 2 # Modify global x's value \n    print('Changed global x to', x) # Prints modified x  \n\nfunc()\nprint('Value of x is', x) # Prints final x  \n\nx is 50\nChanged global x to 2\nValue of x is 2\n\n\nThe global statement declares that x is a global variable - therefore, when we assign a value to x inside the function, the change reflects when we use x’s value in main block.\nYou can use the same global statement to specify multiple global variables, e.g. global x, y, z.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#default-parameter-values",
    "href": "functions.html#default-parameter-values",
    "title": "4  Functions",
    "section": "4.4 Default Parameter Values",
    "text": "4.4 Default Parameter Values\nWe can make some function parameters optional by setting default parameter values. When the user does not explicitly provide argument values, the function will use these set default values.\nThis can be achieved by assigning default values after the parameter names in the function definition with an equals sign (=).\n\n# Code sample from: A Byte of Python\ndef say(message, times=1):\n    print(message * times)\n    \nsay('Hello') # Prints \"Hello\"  \nsay('World', 5) # Prints \"WorldWorldWorldWorldWorld\"\n\nHello\nWorldWorldWorldWorldWorld\n\n\nThe function say repeats printing a string a number of times we specify.\n\nWhen we don’t explicitly specify print times, the function defaults to printing the string once. This is achieved by setting parameter times’s default value to 1.\n\nIn the first usage case, we only pass in the string argument, so the function defaults to printing that string once.\n\nIn the second usage case, we pass in the string and a number 5 as arguments, indicating we want the string to print 5 times.\n\nNote:\n\nOnly parameters at the end of the parameter list can have default parameter values.\n\nThat is, in the parameter list of a function, parameters with default values cannot occur before parameters without default values. This is because parameters are assigned positionally.\n\nFor example, def func(a, b=5) is valid, but def func(a=5, b) is invalid.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#keyword-arguments",
    "href": "functions.html#keyword-arguments",
    "title": "4  Functions",
    "section": "4.5 Keyword Arguments",
    "text": "4.5 Keyword Arguments\n\nIf you have a function with many parameters and you want to specify only some of them, you can use named arguments.\n\nSuch arguments are called keyword arguments, where the specification of parameter values is by parameter names (keywords) instead of positions (which is what we have been using so far).\nUsing keyword arguments allows us to call functions more flexibly without needing to match the order of parameters as defined in the function.\n\nAs long as the other parameters have default values, we can assign values only to the parameters we want.\n\n\n# Code sample from: A Byte of Python  \ndef func(a, b=5, c=10):\n    print('a is', a, 'and b is', b, 'and c is', c)\n\nfunc(3, 7)  \nfunc(25, c=24)\nfunc(c=50, a=100)   \n\na is 3 and b is 7 and c is 10\na is 25 and b is 5 and c is 24\na is 100 and b is 5 and c is 50\n\n\nThe function named func has one parameter without default value, followed by two parameters with default values.\n\nIn the first usage, func(3, 7), parameter a gets value 3, parameter b gets value 7, and c gets the default value 10.\n\nIn the second usage, func(25, c=24), 25 gets assigned to parameter a due to position. Then parameter c gets value 24 due to named arguments. Parameter b gets the default value 5.\n\nIn the third usage, we use keyword arguments for all specified values.\n\nNote that although in the function definition, parameter a comes before parameter c, we can still assign a value to parameter c first before assigning to parameter a. This is a characteristic of keyword arguments.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#variable-arguments",
    "href": "functions.html#variable-arguments",
    "title": "4  Functions",
    "section": "4.6 Variable Arguments",
    "text": "4.6 Variable Arguments\nVariable arguments are a special kind of parameter that can accept any number of arguments. This is very useful in cases when you don’t know beforehand how many arguments will be passed to the function, or the number varies.\nIn Python, variable arguments are indicated by adding an asterisk (*) before the parameter name.\n\n# Code sample from: A Byte of Python\ndef total(a=5, *numbers, **phonebook):  \n    print('a', a)\n\n    # Traverse through all items in the tuple   \n    for single_item in numbers:\n        print('single_item', single_item)\n\n    # Traverse through all items in the dictionary     \n    for first_part, second_part in phonebook.items():\n        print(first_part,second_part)\n\ntotal(10, 1, 2, 3, Jack=1123, John=2231, Inge=1560)\n\na 10\nsingle_item 1\nsingle_item 2\nsingle_item 3\nJack 1123\nJohn 2231\nInge 1560\n\n\n\nWhen we declare a starred parameter like *param, all positional arguments from that point till the end will be collected into a tuple named ‘param’.\n\nSimilarly, when we declare a double-starred parameter like **param, all keyword arguments from that point till the end will be collected into a dictionary named ‘param’.\n\nWe can access these arguments inside the function just like traversing a normal tuple or dictionary.\nA function can only have one variable argument, and it must come after all the positional and default parameters.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#the-return-statement",
    "href": "functions.html#the-return-statement",
    "title": "4  Functions",
    "section": "4.7 The return Statement",
    "text": "4.7 The return Statement\nThe return statement is used to return results from functions or end function execution.\nInside a function, an expression after a return statement can have a value, and that value gets returned from the function.\n\n# Code sample from: A Byte of Python\ndef maximum(x, y):\n    if x &gt; y:\n        return x  \n    elif x == y: \n        return 'The numbers are equal'\n    else:\n        return y\n\nprint(maximum(2, 3))  \n\n3\n\n\n\nIn this function, the maximum function uses a simple if..else statement to find the larger value and returns that value.\n\nIn this case, if we call maximum(2, 3), the return value of this function would be 3.\nNote that once a return statement is executed, the function execution immediately stops and the code after it does not get executed.\n\nNote that a statement without a value is equivalent to return None. In Python, None is a special type indicating no value.\nEvery function implicitly has a return None at the end unless you have written a return statement yourself.\n\nThere is a built-in function called max that already implements “finding maximum value” functionality. So use that built-in function wherever possible.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "functions.html#docstrings",
    "href": "functions.html#docstrings",
    "title": "4  Functions",
    "section": "4.8 Docstrings",
    "text": "4.8 Docstrings\nDocstrings refer to documentation strings in Python that are a way of documenting functions, methods, classes, modules etc with an invaluable reference purpose.\nDocstrings are located on the first line of function, method, class and module definitions, enclosed within a pair of triple quotes \"\"\" or ''', which can be single line or multi-line.\n\n# Code sample from: A Byte of Python\ndef print_max(x, y):\n    '''Prints the maximum of two numbers.\n\n    The two values must be integers.'''  \n    # convert to integers, if possible\n    x = int(x)\n    y = int(y)\n\n    if x &gt; y:\n        print(x, 'is maximum')\n    else: \n        print(y, 'is maximum')\n\nprint_max(3, 5)  \nprint(print_max.__doc__)\n\n5 is maximum\nPrints the maximum of two numbers.\n\n    The two values must be integers.\n\n\n\nThe convention for docstrings is to have a multi-line string where the first line starts with a capital letter and ends with a dot. Then the second line is blank, followed by any detailed explanation starting from the third line.\n\nIt is strongly recommended that you follow this convention for docstrings in all non-trivial functions.\n\nIn this example, we can access the docstring of function print_max with the __doc__ attribute (note the double underscores) of that function.\n\nThe functionality of Python’s help() is to retrieve this __doc__ attribute and present it in a neat manner. You can try help(print_max) to view the docstring for print_max.\nAutomated tools can retrieve documentation from your programs this way. So it is highly recommended to use docstrings when writing any non-trivial functions.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "modules.html",
    "href": "modules.html",
    "title": "5  Modules",
    "section": "",
    "text": "5.1 Basic Concepts\nIn Python, modules are a way of organizing and reusing code. A module is a file containing functions, classes and variables that can be imported and used by other programs.\nThe basic idea behind modules is to organize related code together to improve maintainability and reusability. By splitting code into modules, readability and maintainability can be improved.\nModules have the following characteristics:\nIn Python, modules can be written in Python or other languages like C/C++ and compiled into binary code. The latter are usually called “compiled modules” or “extension modules”.\nThey are commonly used to improve performance (compiled code runs faster) or provide functionality Python itself cannot provide directly (like calling low-level OS APIs).\nSee code sample below for module usage:\nimport sys\n\nprint(\"The script has the name %s\" % (sys.argv[0]))\nif len(sys.argv) &gt; 1:\n    print(\"It has some arguments:\")\n    for arg in sys.argv[1:]:\n        print(arg)\n\nprint('\\n\\nThe PYTHONPATH is', sys.path, '\\n')  \n\nThe script has the name C:\\Conda_data\\envs\\main\\Lib\\site-packages\\ipykernel_launcher.py\nIt has some arguments:\n-f\nC:\\Windows\\Temp\\tmpi_em652r.json\n--HistoryManager.hist_file=:memory:\n\n\nThe PYTHONPATH is ['C:\\\\Conda_data\\\\envs\\\\main\\\\python311.zip', 'C:\\\\Conda_data\\\\envs\\\\main\\\\DLLs', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib', 'C:\\\\Conda_data\\\\envs\\\\main', '', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\win32', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\win32\\\\lib', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\Pythonwin']",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modules</span>"
    ]
  },
  {
    "objectID": "modules.html#basic-concepts",
    "href": "modules.html#basic-concepts",
    "title": "5  Modules",
    "section": "",
    "text": "Encapsulation: Modules encapsulate related code into a single file, making the code more organized and manageable.\n\nNamespace: Modules create an isolated namespace that avoids naming conflicts. Functions, classes and variables defined inside modules can be accessed using the module name as prefix, avoiding conflicts.\nCode Reuse: Modules can be imported and used by other programs, enabling code reuse. By importing a module, functions, classes and variables defined in it can be used directly without rewriting code.\n\nExtensibility: Modules can be extended and modified as needed. New functions, classes and variables can be added to modules to meet different requirements.\n\n\n\n\n\n\n5.1.1 The sys Module\nThe sys module contains system-related functions and variables in Python.\n\nsys.argv is a list in Python containing command line arguments passed to a Python script.\nThese arguments are stored as strings, where sys.argv[0] is the script name (the executed Python file name) and the rest sys.argv[1], sys.argv[2] etc are external arguments passed in order.\nIn the sys module, argv variable can be accessed with dot notation sys.argv. This clearly indicates argv is part of sys module and avoids conflicts with any argv variable used in the program.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modules</span>"
    ]
  },
  {
    "objectID": "modules.html#the-import-statement",
    "href": "modules.html#the-import-statement",
    "title": "5  Modules",
    "section": "5.2 The import Statement",
    "text": "5.2 The import Statement\nWhen Python executes an import statement, the Python interpreter searches for the object to import through the following steps:\n\nFirst, the interpreter checks built-in modules. Python’s built-in modules are written in C and linked to the Python interpreter. For example sys used in the sample code is a built-in module.\n\nIf not found in built-in modules, Python interpreter then checks the sys.modules dictionary next. sys.modules stores paths and module objects for all imported modules. Think of it as a history record or cache for modules already imported by Python. If the module has been imported before, get it directly from this dictionary.\nIf still not found in sys.modules, the Python interpreter then checks the sys.path list. sys.path contains locations searched by the Python interpreter for modules, including:\n\nThe current working directory where the program is being executed when launched. Run import os; print(os.getcwd()) to find the program’s current directory.\nSome standard library directories of Python\nAdditional paths where third party packages are installed. Usually under the site-packages directory.\n\n\nPython searches for the module to import through the directories listed in sys.path from top to bottom in order. It checks each directory to see if it contains the module to import. If not found in any of the directories, Python raises a ModuleNotFoundError.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modules</span>"
    ]
  },
  {
    "objectID": "modules.html#byte-compiled-.pyc-files",
    "href": "modules.html#byte-compiled-.pyc-files",
    "title": "5  Modules",
    "section": "5.3 Byte-compiled .pyc Files",
    "text": "5.3 Byte-compiled .pyc Files\nIn Python, byte-compiled .pyc files are an optimization technique used to improve execution speed of Python programs. When the Python interpreter executes a module, it compiles the module source code into bytecode and saves the bytecode to a .pyc file with same name as the module.\nTypically these .pyc files are created in the same directory as the corresponding .py files. If Python does not have write permission to that directory, .pyc files will not be created. In Python 3, modules from standard library and third party libraries are installed under Python’s installation directory, their .pyc files are usually stored under the __pycache__ directory.\nWhether it’s your own written modules or downloaded modules, as long as they have been executed by the Python interpreter before, corresponding .pyc files will be generated to improve program execution speed.\nByte-compiled .pyc files have the following characteristics:\n\nImproved execution speed: Since bytecode is an intermediate form closer to machine language compared to source code, executing bytecode is faster than executing source code. By saving the bytecode of modules to .pyc files, recompiling source code every time the module executes can be avoided, improving program execution speed.\nCross-platform compatibility: .pyc files are platform-independent and can execute on different operating systems. This means .pyc files compiled on one platform can be copied to another platform for execution without needing to recompile the source code.\n\nCaching mechanism: Python interpreter checks timestamp of .pyc files to determine if source code needs recompiling. If source code is unchanged and .pyc file timestamp is newer, interpreter loads .pyc file directly instead of recompiling source code. This caching mechanism reduces program startup time and memory usage.\n\nPoor readability: .pyc files contain compiled bytecode and have poorer readability compared to source code. This is because bytecode is a low-level machine-oriented representation while source code is human-readable high-level language. So .pyc files don’t normally need manual editing or inspection.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modules</span>"
    ]
  },
  {
    "objectID": "modules.html#from...import-statements",
    "href": "modules.html#from...import-statements",
    "title": "5  Modules",
    "section": "5.4 from...import Statements",
    "text": "5.4 from...import Statements\nUsing from...import statements allows us to directly call imported functions or objects without needing to prefix the module name. For example, we can directly import sqrt function from math module, so we don’t need to write math. when calling it.\nThe benefit of this approach is we can selectively import only the functions or classes we want to use instead of loading the entire module, saving some memory compared to the first approach. However, having too many from...import statements or importing functions of the same name from multiple modules in code can cause namespace pollution and function conflicts.\nWe can also use from...import statements to import multiple functions or classes, for example, importing sqrt and pi from math module:\n\nfrom math import sqrt\nprint(sqrt(16))  # Output: 4.0  \n\nfrom math import sqrt, pi\nprint(sqrt(16)) # Output: 4.0\nprint(pi)       # Output: 3.141592653589793\n\n4.0\n4.0\n3.141592653589793",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modules</span>"
    ]
  },
  {
    "objectID": "modules.html#the-__name__-attribute-of-python-modules",
    "href": "modules.html#the-__name__-attribute-of-python-modules",
    "title": "5  Modules",
    "section": "5.5 The __name__ attribute of Python modules",
    "text": "5.5 The __name__ attribute of Python modules\nIn Python, every module has a built-in attribute called __name__, which is extremely important for understanding how modules are loaded and the difference between modules and execution scripts.\nWhen directly running a .py file (e.g. executing python your_script.py from command line), Python automatically sets the __name__ attribute to '__main__'. In this case, we say your_script.py runs as a script.\nHowever, if you import the .py file as a module (e.g. import your_script in another .py file), Python automatically sets __name__ attribute to the module’s name (which would be your_script in this example). In this case, we say your_script.py is an imported module.\nSee the following sample code:\n\nif __name__ == '__main__':\n    print('This program is being run by itself')  \nelse:\n    print('I am being imported from another module')\n\nThis program is being run by itself\n\n\nBased on the above attribute, many Python scripts (especially those run both as modules and scripts) contain the following code at the end of the file:\nif __name__ == \"__main__\":\n    run_my_script()  \nWhere run_my_script() is a function defined in the script. The purpose of this code segment is:\n\nIf you directly run this .py file, Python executes the run_my_script() function;\n\nIf you import this .py file as module, Python does NOT execute run_my_script() function.\n\nThis allows a Python module to be safely imported while also independently runnable, which is a common and useful technique in Python programming.\nIn summary, as a built-in module attribute in Python, __name__ can effectively distinguish between direct script execution and imported module calls, playing an important role in understanding and controlling Python code flow.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modules</span>"
    ]
  },
  {
    "objectID": "modules.html#making-your-own-modules",
    "href": "modules.html#making-your-own-modules",
    "title": "5  Modules",
    "section": "5.6 Making Your Own Modules",
    "text": "5.6 Making Your Own Modules\nIn Python, any .py file can be treated as module. You just need to organize your code properly and save it as a .py file.\nWhen importing modules, Python interpreter searches for module files in some specific directories, paths of which are stored in sys.path list. If your module is in a path outside these directories, you need to append module path to system path, like the sample code below:\n\n# Code sample from: A Byte of Python\nimport sys\nsys.path.append(\"practical_code/modules\") # Add module path  \n\nimport mymodule\n\nmymodule.say_hi()  \nprint('Version', mymodule.__version__)\n\nHi, this is mymodule speaking.\nVersion 0.1\n\n\nSample code using from..import statement:\n\n# Code sample from: A Byte of Python\nimport sys\nsys.path.append(\"practical_code/modules\")   \n\nfrom mymodule import say_hi, __version__\n\nsay_hi()\nprint('Version', __version__) \n\nHi, this is mymodule speaking.\nVersion 0.1",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modules</span>"
    ]
  },
  {
    "objectID": "modules.html#the-dir-function",
    "href": "modules.html#the-dir-function",
    "title": "5  Modules",
    "section": "5.7 The dir Function",
    "text": "5.7 The dir Function\nThe dir function is a built-in function in Python that returns a list of attributes and methods of an object. It accepts an optional argument which is the name of an object or module. If directly calling dir() without arguments, it returns names of all variables, functions, classes etc accessible in the current scope.\nBasic concepts: - Object: Everything is object in Python, including numbers, strings, lists, functions etc. - Attribute: Characteristics or data of an object, accessible via dot operator.\n- Method: Behaviors or functionalities of an object, can be called via dot operator.\nCharacteristics: - dir function returns a list containing names of all attributes and methods of an object or module.\n- Returned list is unordered without guaranteed order of attributes and methods. - dir only returns public attributes and methods, not including private ones.\n- If argument is a module name, returned list contains names of all public module attributes and methods. - If argument is an object, returned list contains all attribute and method names of that object.\n\na = 5\n# Call dir() and print all names in current global scope \nprint(dir())  \n\n# Delete variable a  \ndel a   \n\n# Call dir() again\nprint(dir()) # This time, 'a' disappears from returned list since we deleted it  \n\n# Use dir() to view all sys attributes and methods\nimport sys\ndir(sys)\n\ndef my_function():\n    \"\"\"\n    This is a sample function. \n    \"\"\"\n    pass\n\n# Use dir() to view attributes and methods of my_function  \nprint(dir(my_function)) \n\n['In', 'Out', '__builtin__', '__builtins__', '__name__', '__version__', '_dh', '_i', '_i1', '_i2', '_i3', '_i4', '_i5', '_i6', '_ih', '_ii', '_iii', '_oh', 'a', 'arg', 'exit', 'get_ipython', 'mymodule', 'ojs_define', 'open', 'pi', 'quit', 'say_hi', 'sqrt', 'sys']\n['In', 'Out', '__builtin__', '__builtins__', '__name__', '__version__', '_dh', '_i', '_i1', '_i2', '_i3', '_i4', '_i5', '_i6', '_ih', '_ii', '_iii', '_oh', 'arg', 'exit', 'get_ipython', 'mymodule', 'ojs_define', 'open', 'pi', 'quit', 'say_hi', 'sqrt', 'sys']\n['__annotations__', '__builtins__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__getstate__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']\n\n\n\nWhen dir() is called without arguments, it returns a list of variable, method and type names defined in the current scope.\n\nWhen new variables or methods are created, they get added to this list; when deleted, they disappear from the list.\nWhen dir() is called with module or function names as argument like dir(sys), it returns a list containing names of all attributes and methods of that module or function.\n\nCalling dir() on a custom module or function returns a list including:\n\n__doc__: The docstring of the module or function, i.e. the description text enclosed within triple quotes when you defined it.\n__name__: Name of the module or function.\n\nFor modules, __name__ is '__main__' if directly running the module script, or the module’s own name if imported by other programs.\nFor functions, __name__ is the function’s name.\n\n\n__module__: The __module__ attribute exists only on function objects, representing the name of module that defined the function.\n\nFor functions defined in main program, __module__ is usually 'main';\nFor functions defined in imported modules, __module__ is that module’s name.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modules</span>"
    ]
  },
  {
    "objectID": "modules.html#packages",
    "href": "modules.html#packages",
    "title": "5  Modules",
    "section": "5.8 Packages",
    "text": "5.8 Packages\nIn Python, a package is a way of organizing and managing Python modules. You can simply think of packages as folders containing one or more Python modules.\nA Python package may contain Python modules, sub-packages, or some auxiliary files like documentation and data files. Main goal of Python packages is to provide a convenient way to organize and share a group of related code functionalities.\nUsually there is a special file called __init__.py in Python packages that marks the containing folder as a Python package, it can contain initialization code or specify attributes of the package. However from Python 3.3 onwards, so-called namespace packages are also supported where __init__.py files are no longer mandatory.\nCode example:\nIf we have the following directory structure:\nmy_package/\n├── __init__.py\n├── module1.py\n└── sub_package/\n    ├── __init__.py\n    └── module2.py\n    \nIn this structure, my_package is a Python package containing one module module1 and one sub-package sub_package. sub_package is also a Python package containing one module module2.py.\nAssuming in module1.py we define a function func1, and in module2.py we define a function func2.\n\n# File path: my_package/module1.py\n\ndef func1():\n    print(\"This is function 1 from module 1\")\n    \n# File path: my_package/sub_package/module2.py  \n\ndef func2():\n    print(\"This is function 2 from module 2\")     \n\nIn Python we can import and use these functions as:\n\nimport sys\nsys.path.append(\"practical_code/modules\") # Add package path \n\n# Import module1 module from my_package package  \nimport my_package.module1  \n\n# Call func1 function from module1\nmy_package.module1.func1()  # Outputs: This is function 1 from module 1  \n\n# Import module2 module from sub_package package\nimport my_package.sub_package.module2  \n\n# Call func2 function from module2\nmy_package.sub_package.module2.func2()  # Outputs: This is function 2 from module 2  \n\nThis is function 1 from module 1\nThis is function 2 from module 2",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modules</span>"
    ]
  },
  {
    "objectID": "data_structures.html",
    "href": "data_structures.html",
    "title": "6  Data Structures",
    "section": "",
    "text": "6.1 Sequence\nIn Python, the sequence is the most basic data structure. Each element in the sequence is assigned a number - its position, or index, with the first index being 0, the second index being 1, and so on.\nPython has three common types of sequences:\nThe other three non-sequence data structures are:\nThese three types are not ordered and cannot be accessed via indexes.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data_structures.html#sequence",
    "href": "data_structures.html#sequence",
    "title": "6  Data Structures",
    "section": "",
    "text": "List\nTuple\nString\n\n\n\nSet\nDictionary\nFrozenset",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data_structures.html#list",
    "href": "data_structures.html#list",
    "title": "6  Data Structures",
    "section": "6.2 List",
    "text": "6.2 List\nPython’s list is similar to arrays in other programming languages, but they are more flexible. The elements in the list don’t need to be of the same data type.\nLists are characterized by elements being surrounded by square brackets [] and separated by commas ,.\n\nmylist = [1, \"apple\", 3.14]\nprint(mylist[0]) # prints: 1\n\n1\n\n\nList:\n\nIs ordered\nIs mutable\nCan contain elements of any type\nElements can be accessed by index, with indexes starting from 0\n\n\n\n\n\n\n\nTip\n\n\n\nNote, Python’s indexing starts from 0. This means that when accessing list elements using indexes, the first element in the list is list[0], the second element is list[1], and so on.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data_structures.html#tuple",
    "href": "data_structures.html#tuple",
    "title": "6  Data Structures",
    "section": "6.3 Tuple",
    "text": "6.3 Tuple\nA tuple is an ordered, immutable list. It can be understood as a “read-only” version of a list.\nTuples use parentheses () to enclose elements and are separated by commas ,.\n\nmy_tuple = (1, \"apple\", 3.14)\nprint(my_tuple[0]) # prints: 1\n\n1\n\n\nTuples:\n\nAre ordered\nAre immutable\nCan contain elements of any type\nElements can be accessed by index, with indexes starting from 0\n\nBelow is a code example illustrating the difference between tuples and lists.\n\n# Create a list\nmy_list = [1, 2, 3]\n# Add an element to the end of the list\nmy_list.append(4)\nprint(my_list[3])\n# Create a tuple\nmy_tuple = (1, 2, 3)\n# You can't modify a tuple\n# my_tuple.append(4)  # This would throw an error\n\n4",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data_structures.html#set",
    "href": "data_structures.html#set",
    "title": "6  Data Structures",
    "section": "6.4 Set",
    "text": "6.4 Set\nA set is a non-ordered data structure that does not allow duplicate elements.\nSets enclose elements with curly braces {} and separate them with commas ,.\n\nmy_set = {1, \"apple\", 3.14, \"apple\"}\nprint(my_set) # prints: {1, \"apple\", 3.14}\n\n{'apple', 1, 3.14}\n\n\nSet:\n\nIs unordered\nDoes not allow duplicate elements\nCan contain elements of any type\nCan not be accessed by indexes",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data_structures.html#dictionary",
    "href": "data_structures.html#dictionary",
    "title": "6  Data Structures",
    "section": "6.5 Dictionary",
    "text": "6.5 Dictionary\nA dictionary is an unordered set of key-value pairs.\nA “key-value pair” refers to two associated parts: one is a unique key, and the other is its value. Each key has an associated value. This association is called “mapping”.\nDictionaries enclose elements with curly braces {}, separate keys and values with colons :, and key-value pairs with commas ,.\n\n\n\n\n\n\nWhy called Dictionary\n\n\n\nIn a physical dictionary, you can find a corresponding explanation or translation (corresponding to the “value” in the computer) based on the entry (corresponding to the “key” in the computer). This constitutes an “entry-explanation” pair, similar to the “key-value pair” in computer science.\nTherefore, considering this mapping relationship, this data structure containing “key-value pairs” in computer science is named Dictionary.\n\n\n\nmy_dict = {\n    \"name\": \"apple\",\n    \"color\": \"red\",\n}\nprint(my_dict[\"name\"]) # prints: apple\n\nages = {\n    \"Tom\": 30, \n    \"Alice\": 25, \n    \"Bob\": 27\n}\n\nprint(ages[\"Alice\"]) # prints：25\nages[\"Tom\"] = 31\nprint(ages[\"Tom\"]) # prints：31\n\napple\n25\n31\n\n\nDictionaries:\n\nAre unordered\nIn key-value pairs, the key is unique, but the value can be duplicated\nCan contain elements of any type\nElements are accessed by keys",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data_structures.html#sec-objects-and-classes",
    "href": "data_structures.html#sec-objects-and-classes",
    "title": "6  Data Structures",
    "section": "6.6 Object and Class",
    "text": "6.6 Object and Class\nPython is an object-oriented programming language. In Python, almost everything is an object with its properties and methods. A class provides a mechanism for defining the kind or type for creating objects.\nObject: In Python, an object is a core unit of data. Each object has a type (such as a string, list, dictionary, etc.), and a unique identity (or address in memory). An object can contain various data (i.e., attributes) and functionalities (i.e., methods). It can be seen as an objective entity in the real world, such as a table, a circle, a person, etc.\nFor instance, a person (object) has a name (attribute) and can conduct various activities (methods) such as running, studying, etc.\nClass: A class is a template or blueprint for objects. It defines the basic structure of an object and encapsulates the behaviors (methods) that an object needs to perform. You can define a class to create objects that belong to this class. A class is like a factory for making objects, responsible for specifying what features its products should have.\nFor example, you can define a class “Person” that has attributes like name and age, and methods like eating, sleeping, etc. Then based on this “Person” class, we can create different person objects, such as creating a person object named “Tom” that is 25 years old.\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def introduce(self):\n        return f\"Hello, my name is {self.name} and I am {self.age} years old.\"\n\nsomeone = Person('Tom', 25)\n\nprint(someone.introduce())\n\nHello, my name is Tom and I am 25 years old.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "data_structures.html#references",
    "href": "data_structures.html#references",
    "title": "6  Data Structures",
    "section": "6.7 References",
    "text": "6.7 References\nIn Python, whenever you create an object and assign it to a variable, Python does not store the object’s value in the variable. Instead, Python simply sets the variable to be a reference that points to the object stored in memory. This is known as binding variable names to objects, or called references.\n\n6.7.1 Creating Objects and References\nFor example, when you create a list and assign it to a variable:\n\nlist1 = [1, 2, 3]\n\nAt this point, list1 is just a reference that points to a list object stored in memory, which contains the elements 1, 2, 3. If you create another reference that points to the same object:\n\nlist2 = list1\n\nNow you have two references - list1 and list2, both pointing to the same object.\n\n\n6.7.2 Modifying Mutable Type Objects\nIf you modify the object through one of the references, for example deleting the first element through list1:\n\ndel list1[0]  \n\nThen no matter whether you access this list object through list1 or list2, you will find that the content of this object has changed:\n\nprint(list1)  # prints: [2, 3]  \nprint(list2)  # prints: [2, 3]\n\n[2, 3]\n[2, 3]\n\n\nThis is because list1 and list2 are just references, they do not contain the actual list content themselves, but only point to a location in memory, which is the address of the same list object.\n\n\n6.7.3 Copying Objects\nHowever, sometimes you may need to create a copy of an object, so that you can modify the copy without affecting the original object. For example, you can create a copy of a list through slice operation:\n\nlist3 = list2[:]\n\nNow list3 references a completely new list object, whose content is a complete copy of the list that list2 points to. So when you change the content of list3, the content of the list that list2 points to will not be modified:\n\ndel list3[0]\nprint(list2) # prints: [2, 3]   \nprint(list3) # prints: [3]\n\n[2, 3]\n[3]",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "problem_solving.html",
    "href": "problem_solving.html",
    "title": "7  Problem Solving",
    "section": "",
    "text": "7.1 Software Development Process\nA basic software development process is:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Problem Solving</span>"
    ]
  },
  {
    "objectID": "problem_solving.html#software-development-process",
    "href": "problem_solving.html#software-development-process",
    "title": "7  Problem Solving",
    "section": "",
    "text": "Analysis (What): Define the problem we want to solve\n\nDesign (How): Determine methods to achieve goals\nImplementation (Do It): Start from a simple version first, implement core functionalities\n\nTesting and Debugging (Test): Verify program runs as expected, identify and fix errors\n\nOperation or Deployment: Observe program behavior through actual usage\n\nMaintenance: Optimize and upgrade program based on feedback from usage stage\n\n\n\n\n\n\n\nSoftware is grown, not built. – Bill de hÓra\n软件是成长的,而不是建造的。– Bill de hÓra",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Problem Solving</span>"
    ]
  },
  {
    "objectID": "problem_solving.html#problem-example-backup-program",
    "href": "problem_solving.html#problem-example-backup-program",
    "title": "7  Problem Solving",
    "section": "7.2 Problem Example: Backup Program",
    "text": "7.2 Problem Example: Backup Program\nThe problem presented in “A Byte of Python” is:\n\n\n\n\n\n\nI want a program which creates a backup of all my important files.\n我想要一个能够备份我所有重要文件的程序。\n\n\n\nThe design idea is:\n\nBackup files and directories are specified in a list.\nBackups must be stored in a main backup directory.\n\nFiles are backed up into a zip file.\n\nZip file name is current date and time.\nUses standard Linux/Unix zip command which is default available in any standard GNU/Linux or Unix distribution. Note you can use any archiving command if you have a CLI.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Problem Solving</span>"
    ]
  },
  {
    "objectID": "problem_solving.html#knowledge-points",
    "href": "problem_solving.html#knowledge-points",
    "title": "7  Problem Solving",
    "section": "7.3 Knowledge Points",
    "text": "7.3 Knowledge Points\nSome key knowledge points from the sample code in this A Byte of Python chapter:\n\n7.3.1 Python String Formatting\n\n7.3.1.1 The .format() Method\nThe .format() method is a way of formatting strings where we can insert values into string template placeholders. For example:\n\nname = \"Alice\"\nprint(\"Hello, {}\".format(name)) # Prints: Hello, Alice\n\nHello, Alice\n\n\nIn this code, {} is a placeholder where variable name can be passed into .format() method and automatically replaces the placeholder.\nWe can also add numbers inside {} to specify positions of .format() method arguments:\n\nfirstname = \"Alice\"\nlastname = \"Bob\"\nprint(\"Hello, {0} {1}\".format(firstname, lastname)) # Prints: Hello, Alice Bob\n\nHello, Alice Bob\n\n\nHere {0} and {1} correspond to first and second arguments of .format() method respectively.\n\n\n\n7.3.2 f-strings (Formatted String Literals)\nIn Python 3.6 and later, we usually use f-strings for string formatting, which makes formatting more concise and efficient. F-strings work by prefixing f or F before the string, then write variables or expressions to insert inside {}, Python automatically replaces them with values. For example:\n\nname = \"Alice\" \nprint(f\"Hello, {name}\") # Prints: Hello, Alice\n\nHello, Alice\n\n\nWe can write simple Python expressions inside {}, Python executes them and replaces {} with the result:\n\na = 5\nb = 10\nprint(f\"Five plus ten is {a + b}, not {2 * (a + b)}.\") # Prints: Five plus ten is 15, not 30.  \n\nFive plus ten is 15, not 30.\n\n\n\n\n7.3.3 Using OS Path Separators in Python\nFile path representations differ across operating systems. On Windows systems we use backslash \\ for paths like C:\\Users\\Admin\\Documents. On UNIX systems (Linux, MacOS) forward slash / is used instead, e.g. /home/admin/Documents.\nHowever in Python strings, backslash \\ is a special character used as the escape character for introducing special character sequences. E.g. \\n for newline, \\t for tab. For example:\n\nprint(\"Hello\\nWorld\") # Prints:  \n# Hello\n# World\n\nHello\nWorld\n\n\nSo if we want to use Windows paths like C:\\Users\\Admin\\Documents in Python strings, we need to escape with double backslashes \\\\ like C:\\\\Users\\\\Admin\\\\Documents. Code sample:\n\npath = \"C:\\\\Users\\\\Admin\\\\Documents\" \nprint(path) # Prints: C:\\Users\\Admin\\Documents\n\nC:\\Users\\Admin\\Documents\n\n\nAdditionally, we can use Python raw strings that treat backslashes \\ literally instead of escape characters. Just prefix string with r:\n\npath = r\"C:\\Users\\Admin\\Documents\"\nprint(path) # Prints: C:\\Users\\Admin\\Documents \n\nC:\\Users\\Admin\\Documents\n\n\nHowever it’s not recommended to directly use single backslashes \\ for Windows paths in strings, as unwanted escape sequences can easily be introduced, e.g. \\U starts a Unicode escape sequence, if this happens to appear in a path, Python tries to interpret it as special character sequence leading to errors. So best avoid paths like C:\\Users.\nNote: In most cases, we recommend using the os.path module to handle paths for cross-platform portability.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Problem Solving</span>"
    ]
  },
  {
    "objectID": "problem_solving.html#other-problems",
    "href": "problem_solving.html#other-problems",
    "title": "7  Problem Solving",
    "section": "7.4 Other Problems",
    "text": "7.4 Other Problems\nOther beginner-friendly problems with similar difficulty:\n\nA program that organizes my documents in multiple folders into types (.doc, .pdf etc) stored neatly into separate folders\n\nA program that resizes all my images to specified sizes\nA program that counts word frequency for each word in an English article\n\nA program that finds identical files across two folders and lists them out",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Problem Solving</span>"
    ]
  },
  {
    "objectID": "object_oriented_programming.html",
    "href": "object_oriented_programming.html",
    "title": "8  Object-Oriented Programming",
    "section": "",
    "text": "8.1 Review of Objects and Classes\nWe have already introduced the concepts of objects and classes in Section 6.6. We can summarize as follows:",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "object_oriented_programming.html#review-of-objects-and-classes",
    "href": "object_oriented_programming.html#review-of-objects-and-classes",
    "title": "8  Object-Oriented Programming",
    "section": "",
    "text": "Class: A class is an abstract description of a category of things. It defines the static attributes (fields) and dynamic behaviors (methods) of such things. A class is the template for creating objects and an object is an instance of a class.\n\nObject: An object is an instance of a class, i.e. an entity created based on the class definition. Each object has its own attributes (class variables and instance variables) and behaviors (methods).\n\nAttribute: Attributes are characteristics of a class or object, including static attributes (fields) and dynamic behaviors (methods).\nMethod: Methods are part of a class definition. Methods define the dynamic behaviors of objects, describing how objects can respond to external requests or how to accomplish specific tasks.\n\n\n\n\n\n\n\nTip\n\n\n\nSimilar to structural functionalism - in object-oriented programming, the fields of an object are like its “structure” while the methods are like its “functions”.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "object_oriented_programming.html#class-construction-functional-part",
    "href": "object_oriented_programming.html#class-construction-functional-part",
    "title": "8  Object-Oriented Programming",
    "section": "8.2 Class Construction (Functional Part)",
    "text": "8.2 Class Construction (Functional Part)\nA simplest class looks like:\n\nclass Person:\n    pass  # An empty block  \n\np = Person()\nprint(p)  \n\n&lt;__main__.Person object at 0x0000020D28BBD510&gt;\n\n\nWe use the class statement and class name to create a new class, followed by an indented block of statements that make up the body of the class. Here, the pass statement denotes an empty block since Python block statements cannot be empty.\nAppending parentheses after the class name creates an object/instance. In the example code, we confirm the object is created by printing it out with the print(p) statement. The print result indicates this object is a Person class instance in the __main__ module.\nClass construction is mainly achieved by defining methods of the class. Methods describe operations that can be performed by the class or its instances. In Python we often define methods inside the class, just like defining normal functions.\n\n8.2.1 Methods: Functional Implementation of Classes\nClasses and objects can have methods just like functions, the only difference being the first parameter of methods is self.\nBelow is a simple example of class methods:\n\nclass Person:\n    def say_hi(self):\n        print('Hello, how are you?')\n\np = Person()  \np.say_hi()\n\nHello, how are you?\n\n\n\n\n8.2.2 The Role of self in Class Methods\nIn Python, the first parameter of class methods is usually a special parameter called self, representing the instance that owns the method, or in other words, the instance that will call this method. Through the self parameter, methods can freely access and modify fields and other methods of the object.\n\n\n\n\n\n\nTip\n\n\n\nWhen defining class methods, we don’t know beforehand which instance object will call this method in the future. So we need a parameter (conventionally called self) to receive the runtime passed-in instance object, so that this method can access properties of the instance or call other instance methods.\n\n\n\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\n    def bark(self):\n        return f\"{self.name} says woof!\"  \n\nd1 = Dog(\"Fido\")\nd2 = Dog(\"Rex\")  \n\nprint(d1.bark())  # Prints \"Fido says woof!\"  \nprint(d2.bark())  # Prints \"Rex says woof!\"  \n\nFido says woof!\nRex says woof!\n\n\nWhen an instance calls its method, the Python interpreter automatically passes the instance itself to the self parameter of the method. Through self, we can access and modify instance attributes within the method.\nIn this example, the bark() method gets called on instances d1 and d2, so self represents the calling instance respectively, hence self.name returns the name attribute of d1 and d2 respectively. Each time a method gets called, Python automatically passes in the current object instance as the first argument.\n\n\n\n\n\n\nCaution\n\n\n\nrex.bark()  \nHere when we call rex.bark(), seemingly we did not provide any parameters to the bark method. But actually, the Python interpreter automatically passes the rex instance to bark method’s self parameter. This is why there is always a self parameter at the beginning of class methods, and usually we don’t need to explicitly provide this parameter when calling methods.\nSimilarly, this also means that even for a parameter-less method, it still needs one parameter - self.\n\n\n\n\n8.2.3 The __init__ Method: Class Constructor\nIn Python we often define a special method called __init__ in classes, which is called the constructor method of the class. When we create a new instance from a class, the Python interpreter automatically invokes the __init__ method to initialize the newly created instance.\n\n\n\n\n\n\nMagic Methods\n\n\n\nThe __init__ method name is surrounded by double underscores, meaning it’s a special method with special significance.\nSuch methods prefixed and suffixed by double underscores in Python are usually called “magic methods”. These methods get invoked automatically by the Python interpreter, usually we don’t need to explicitly call them.\n\n\nThe first parameter of the __init__ method is always self, i.e. a reference to the object itself. In the __init__ method we can set initial state of the instance, for example, assigning some initial attribute values.\nBelow is an example of a class with an __init__ method:\n\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nmy_dog = Dog('Willy', 5)  \n\nIn this example, the Dog class has an __init__ method taking three parameters: self, name and age. For the self parameter, as we know, Python provides it automatically when we create class instances. The other parameters (name and age) need to be provided when creating the object.\nThe __init__ method is usually used to initialize state of the object during object creation. By setting object attributes in __init__ method, we can ensure objects have certain initial states once created.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "object_oriented_programming.html#fields-structural-part",
    "href": "object_oriented_programming.html#fields-structural-part",
    "title": "8  Object-Oriented Programming",
    "section": "8.3 Fields (Structural Part)",
    "text": "8.3 Fields (Structural Part)\nVariables defined inside a class or object are called fields, used to describe state or properties of objects. The aforementioned static attributes refer to fields of a class or object.\n\n\n\n\n\n\nCaution\n\n\n\nAttribute = Field + Method\n\n\nFields are variables bound to the namespace of the class or object, so these names are only valid within context of the class and object.\nThere are two types of fields:\n\nClass variables: Belonging to the class, all object instances share this one variable. Modifying it on one object affects all objects.\nInstance variables: Belonging to the object, each object instance has its own copy. Modifying it on one object does not affect others.\n\nBelow is an example for understanding class variables and instance variables:\n\nclass Robot:\n    \"\"\"Represents a robot, with a name.\"\"\"\n\n    # A class variable, counting the number of robots\n    population = 0\n\n    def __init__(self, name):\n        \"\"\"Initializes the data.\"\"\"\n        self.name = name\n        print(\"(Initializing {})\".format(self.name))\n\n        # When this person is created, the robot\n        # adds to the population\n        Robot.population += 1\n\n    def die(self):\n        \"\"\"I am dying.\"\"\"\n        print(\"{} is being destroyed!\".format(self.name))\n\n        Robot.population -= 1\n\n        if Robot.population == 0:\n            print(\"{} was the last one.\".format(self.name))\n        else:\n            print(\"There are still {:d} robots working.\".format(\n                Robot.population))\n\n    def say_hi(self):\n        \"\"\"Greeting by the robot.\n\n        Yeah, they can do that.\"\"\"\n        print(\"Greetings, my masters call me {}.\".format(self.name))\n\n    @classmethod\n    def how_many(cls):\n        \"\"\"Prints the current population.\"\"\"\n        print(\"We have {:d} robots.\".format(cls.population))\n\n\ndroid1 = Robot(\"R2-D2\")\ndroid1.say_hi()\nRobot.how_many()  \n\ndroid2 = Robot(\"C-3PO\")\ndroid2.say_hi() \nRobot.how_many()\n\nprint(\"\\nRobots can do some work here.\\n\")  \n\nprint(\"Robots have finished their work. So let's destroy them.\")\ndroid1.die()  \ndroid2.die()\n\nRobot.how_many()\n\n(Initializing R2-D2)\nGreetings, my masters call me R2-D2.\nWe have 1 robots.\n(Initializing C-3PO)\nGreetings, my masters call me C-3PO.\nWe have 2 robots.\n\nRobots can do some work here.\n\nRobots have finished their work. So let's destroy them.\nR2-D2 is being destroyed!\nThere are still 1 robots working.\nC-3PO is being destroyed!\nC-3PO was the last one.\nWe have 0 robots.\n\n\nIn this example:\n\npopulation is a class variable, used to keep track number of robots.\nname is an instance variable, used to store robot’s name.\n\n__init__ method is a special method used to initialize robot’s name.\nhow_many is a class method, used to print current number of robots. We decorate how_many as a class method.\n\ndie is an instance method, used to represent robot destruction.\n\nAll class members are public here. Names prefixed with a single underscore _ indicate protected names that should not be directly accessed externally. Names prefixed with double underscore __ indicate private names that should not be directly accessed externally.\n8.4 Inheritance\n\nInheritance is an important feature in object-oriented programming. It allows us to define a new class that inherits attributes and methods from one or more existing classes. The inherited class is called the parent class (or base class), and the inheriting class is called the child class (or derived class).\nThe main purpose of inheritance is to achieve code reuse. Through inheritance, the child class can inherit attributes and methods of the parent class so that identical code does not need to be rewritten.\nIn Python, inheritance is achieved by specifying the parent class in parentheses after the class name when defining a class. Below is a simple inheritance example:\n\nclass SchoolMember:\n    '''Represents any school member.'''\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        print('(Initialized SchoolMember: {})'.format(self.name))\n\n    def tell(self):\n        '''Tell my details.'''\n        print('Name:\"{}\" Age:\"{}\"'.format(self.name, self.age), end=\" \")\n\n\nclass Teacher(SchoolMember):\n    '''Represents a teacher.'''\n    def __init__(self, name, age, salary):\n        SchoolMember.__init__(self, name, age)\n        self.salary = salary\n        print('(Initialized Teacher: {})'.format(self.name))\n\n    def tell(self):\n        SchoolMember.tell(self)\n        print('Salary: \"{:d}\"'.format(self.salary))\n\n\nclass Student(SchoolMember):\n    '''Represents a student.'''\n    def __init__(self, name, age, marks):\n        SchoolMember.__init__(self, name, age)\n        self.marks = marks\n        print('(Initialized Student: {})'.format(self.name))\n\n    def tell(self):\n        SchoolMember.tell(self)\n        print('Marks: \"{:d}\"'.format(self.marks))\n\nt = Teacher('Mrs. Shrividya', 40, 30000)\ns = Student('Swaroop', 25, 75)  \n\n# prints a blank line\nprint()   \n\nmembers = [t, s]\nfor member in members:\n    # Works for both Teachers and Students \n    member.tell() \n\n(Initialized SchoolMember: Mrs. Shrividya)\n(Initialized Teacher: Mrs. Shrividya)\n(Initialized SchoolMember: Swaroop)\n(Initialized Student: Swaroop)\n\nName:\"Mrs. Shrividya\" Age:\"40\" Salary: \"30000\"\nName:\"Swaroop\" Age:\"25\" Marks: \"75\"\n\n\nIn this example:\n\nWhen using inheritance, specify the base class name(s) in the tuple after the class name in the class definition (e.g. class Teacher(SchoolMember):).\nThe base class __init__ method needs to be explicitly called via SchoolMember.__init__(self, name, age).\n\nThis is because the subclass __init__ method overrides the base class __init__ method.\n\nIf we want to call the base class __init__ method in the subclass __init__ method, we need to explicitly call it.\n\n\nBoth Teacher and Student classes inherit from SchoolMember class. This means Teacher and Student classes can access attributes and methods of the SchoolMember class.\nFor each subclass we define a tell method which overrides the base class tell method. This is called polymorphism, meaning different classes can produce different responses to the same method.\n\nIf tell method was not defined in subclasses, subclasses would inherit the base class tell method.\nPython always calls subclass methods first, and searches up the inheritance chain for the method if not found.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "object_oriented_programming.html#summary",
    "href": "object_oriented_programming.html#summary",
    "title": "8  Object-Oriented Programming",
    "section": "8.5 Summary",
    "text": "8.5 Summary\n\n8.5.1 Key Characteristics of Object-Oriented Programming\nKey characteristics of object-oriented programming (OOP) are:\n\nModularity: Each object can be viewed as an independent module with its own attributes (also called data members) and methods (also called member functions).\n\nReusability: Object code can be reused wherever needed, code reuse can be achieved through inheritance, encapsulation, polymorphism etc.\n\nExtensibility: Inheritance and polymorphism mechanisms improve extensibility of programs.\n\n\n\n\n\n\n\nOther Common Programming Paradigms\n\n\n\nProcedural Programming: One of the earliest programming paradigms where main idea is to break down programs into a sequence of steps or functions, solving problems by defining data and execution steps of functions.\nFunctional Programming: Advocates writing pure functions, avoiding program state change and data mutability, seeking higher comprehensibility and lower bug rates.\nLogic Programming: Writing programs by describing the logic of a problem, programs would then automatically deduce answers to solving the problem. Prolog is a logic programming language.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "input_and_output.html",
    "href": "input_and_output.html",
    "title": "9  Input and Output",
    "section": "",
    "text": "9.1 User Input\nThe input() function accepts a string as argument which it prints out for the user, then waits for user input and hitting enter. Once the user inputs something and hits enter, the input() function returns the text input by the user.\nSome notes:\nBelow are some sample code:\nThe following are some key points about the sample code above:",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "input_and_output.html#user-input",
    "href": "input_and_output.html#user-input",
    "title": "9  Input and Output",
    "section": "",
    "text": "The input() function always returns the input as string. If you need an integer, you need to use the int() function to convert the returned string to integer.\n\nThe input() function always returns a string. If you need a float number, you need to use the float() function to convert the returned string to float.\n\nThe input() function can be used without arguments, in which case it just shows a simple colon prompt waiting for user input. It can also take a string argument which will be printed out as a prompt message for the user.\n\nWhen using the input() function, the program execution pauses and blocks before the user inputs something and hits enter.\n\nIf you want to input passwords or other sensitive information, you may want the input content to not be shown. In this case you can use the getpass() function from the getpass module.\n\n\n\n# Example 1  \nname = input(\"What is your name? \")  \nprint(\"Hello, \" + name + \"!\")\n# Example 2\ndef reverse(text):\n    return text[::-1]\n\ndef is_palindrome(text):\n    return text == reverse(text)\n\nsomething = input(\"Enter text: \")\nif is_palindrome(something):\n    print(\"Yes, it is a palindrome\")\nelse:\n    print(\"No, it is not a palindrome\") \n# Example 3  \nimport getpass\npassword = getpass.getpass(\"Enter your password: \")\nif password == \"12345\":\n    print(\"Access granted\")\nelse:\n    print(\"Access denied\")  \n# Example 4\ndef reverse(text):\n    return text[::-1]\ndef is_palindrome(text):\n    return text == reverse(text)\n    \nsomething = input(\"Enter text: \")\nfiltered_something = ''.join(c for c in something if c.isalnum()).lower() \nif is_palindrome(filtered_something):\n    print(\"Yes, it is a palindrome\")\nelse:\n    print(\"No, it is not a palindrome\")\n\n\nIn Example 1, the input() function has a string argument that gets printed out as prompt for the user.\n\nIn Example 2, the input() function has a string argument that gets printed out as prompt for the user. The input content is passed to the reverse() and is_palindrome() functions.\n\nIn Example 2, we use slice notation to reverse the string. text[::-1] returns a reversed string. Slice notation syntax is text[start:end:step]. Default values are start=0, end=len(text), step=1. A negative step value means slicing from right to left, reversing a string.\n\nIn Example 3, we use the getpass() function from the getpass module to get password input from the user. This function does not show the user input.\nIn Example 4, we use the isalnum() method to check if the string only contains letters and numbers. The isalnum() method returns True if the string only contains letters and numbers, otherwise returns False. The join() method joins a list of strings into a new string.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "input_and_output.html#files",
    "href": "input_and_output.html#files",
    "title": "9  Input and Output",
    "section": "9.2 Files",
    "text": "9.2 Files\nPython provides some built-in functions and methods to allow us to create, open, read and write files. These operations are mainly achieved through the built-in open() function and methods of the file object.\nBelow are some common file operations:\n\nThe open function: This is a built-in function used to open a file and return a file object.\n\nThe open function takes two arguments: file name (required) and mode (optional).\n\nThe mode argument is a string indicating file open mode. Default value is r indicating read-only mode. Other options include w (write mode), a (append mode), r+ (read and write mode) etc.\n\nw mode will create a new file, overwriting existing file if it already exists.\n\nIn r mode, a file object’s methods can only be used to read file content. In w mode, methods can only write content. In a mode, methods can only append content.\n\nTo be able to read right after writing some content, need to open file in read and write mode (e.g. r+ or w+).\n\nread method: Used to read file content.\n\nThe read method takes an integer argument to specify number of bytes to read. If no argument is passed, read() reads entire file.\nAfter reading/writing file content, the file object’s pointer moves to end of file. To read content again, need to use seek method to move pointer back to start of file.\n\n\nwrite method: Used to write content to the file. This method takes a string argument which gets written to the file.\n\nclose method: Used to close the file. After closing, any operations on the file object will fail.\n\nBelow are some sample code:\n\nfile1 = open(r\"practical_code\\input_and_output\\myfile.txt\", \"r\")\ncontent = file1.read()\nprint(content) \nfile1.close()\n\n# This is a example of Python IO.\nAnd this is the second line.\n\n\n\nfile2 = open(r\"practical_code\\input_and_output\\myfile2.txt\", \"w\")\nfile2.write(\"This is a test\")\nfile2.close()\n\nWhen doing file operations, should always remember to close the file after finishing operation. To better manage file resources, Python provides the with statement that closes file automatically:\n\nwith open(r\"practical_code\\input_and_output\\myfile.txt\", \"r\") as file:\n    content = file.read()\n    print(content)\n\n# This is a example of Python IO.\nAnd this is the second line.\n\n\nBelow is a more complex example:\n\npoem = '''\\  \nProgramming is fun\nWhen the work is done  \nif you wanna make your work also fun:\n    use Python!  \n'''\nf = open(r\"practical_code\\input_and_output\\poem.txt\", \"w\") \nf.write(poem)\nf.close()\n\nf = open(r\"practical_code\\input_and_output\\poem.txt\", \"r\")\nwhile True:\n    line = f.readline()\n    if len(line) == 0:\n        break\n    print(line, end='')\nf.close() \n\n\\  \nProgramming is fun\nWhen the work is done  \nif you wanna make your work also fun:\n    use Python!  \n\n\nIn this sample code:\n\nWe first use the open function to create a file object, then use the write method to write some content.\nUse the readline method to read file content. readline reads one line each time, returning a string. When reaching end of file, readline returns an empty string, i.e. len(line) == 0. We then use a break statement to exit the loop.\nWe use the end='' parameter to avoid adding a new line at the end of each line.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "input_and_output.html#pickle-module",
    "href": "input_and_output.html#pickle-module",
    "title": "9  Input and Output",
    "section": "9.3 Pickle Module",
    "text": "9.3 Pickle Module\nPickle is a standard Python module that is an important module in Python used for serializing and deserializing Python object structures.\nThrough the Pickle module, Python object structures can be converted to a byte stream that contains all necessary information for reconstructing the original object. The process of converting to a byte stream is called “pickling”, while the process of restoring the object from the byte stream is called “unpickling”.\nPickle can handle almost all Python objects, including functions, classes, and even user-defined objects.\nThe concept of “persistently storing objects” generally refers to saving the state of objects in memory to persistent storage media such as hard drives, databases, or remote servers, etc. Then at a later time, even if the original program has stopped, this data can be read back into memory and restored as objects.\nThe functionality of the Pickle module is one important means of persistently storing objects. Through the pickle module, we can convert Python objects in memory into byte streams, then store these byte streams in files, databases, or send them over networks to other places. When we need them, we can convert these byte streams back into Python objects through unpickling operations.\nThe main methods for pickling and unpickling using the pickle module are:\n\npickle.dumps(obj): Converts a Python object to a byte stream.\n\npickle.dump(obj, file): Converts a Python object to a byte stream and writes that byte stream to a file.\npickle.loads(bytes_object): Restores an object from a byte string.\npickle.load(file): Reads byte streams from a file and converts them to Python objects.\n\nBelow is a basic usage example of this module:\n\nimport pickle\n\ndata = {\n    'a': [1, 2.0, 3, 4+6j],\n    'b': (\"character string\", b\"byte string\"),\n    'c': {None, True, False}\n}\n\nwith open(r\"practical_code\\input_and_output\\data.pkl\", \"wb\") as f:\n    pickle.dump(data, f)\n\nwith open(r\"practical_code\\input_and_output\\data.pkl\", \"rb\") as f:\n    restored_data = pickle.load(f)\nprint(restored_data) \n\n{'a': [1, 2.0, 3, (4+6j)], 'b': ('character string', b'byte string'), 'c': {False, None, True}}\n\n\nIn this example, we first use the pickle.dump method to convert a Python object to a byte stream and write that byte stream to a file. We then use the pickle.load method to read the byte stream from the file and convert it back to a Python object.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "input_and_output.html#unicode-characters-and-encoding",
    "href": "input_and_output.html#unicode-characters-and-encoding",
    "title": "9  Input and Output",
    "section": "9.4 Unicode Characters and Encoding",
    "text": "9.4 Unicode Characters and Encoding\nIn Python 3, strings are Unicode strings. Unicode is a standard that defines the character set for text in all languages of the world. The Unicode character set covers all characters for all text in the world’s writing systems, including Chinese, Japanese, Greek, Cyrillic characters etc. Each character has a unique Unicode code point which is an integer.\nEncoding and decoding:\n\nThe process of converting Unicode characters to byte streams is called encoding. In Python we can use the encode method to encode a Unicode string into a byte stream.\nThe process of converting byte streams back to Unicode characters is called decoding. We can use the decode method to decode a byte stream back into a Unicode string.\n\nA common encoding method is UTF-8 encoding.\nWhen programming, if we need to deal with non-ASCII characters, we should always use Unicode strings. Only when we need to convert the Unicode string to a byte stream do we need to use encoding.\n\nWhen writing a program using Unicode characters, we should ensure the program uses UTF-8 encoding. This way our program can handle text in all languages of the world.\nBelow is an example handling Unicode characters:\n\nimport io\n\nf = io.open(r\"practical_code\\input_and_output\\zh_CN.txt\", \"wt\", encoding=\"utf-8\") \nf.write(u\"你好,世界!\")  \nf.close()\n\ntext = io.open(r\"practical_code\\input_and_output\\zh_CN.txt\", encoding=\"utf-8\").read()\nprint(text)\n\n你好,世界!\n\n\nIn this sample code:\n\nIn Python 3, the io.open function works exactly the same as the open function.\n\nBut in Python 2, the open function does not support specifying encoding. In Python 2 we should use the io.open function to open files.\nIf we want the program to be compatible with both Python 2 and Python 3, we should use the io.open function to open files. But if we only need Python 3 compatibility, for simplicity we can just use the open function.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Input and Output</span>"
    ]
  },
  {
    "objectID": "exceptions.html",
    "href": "exceptions.html",
    "title": "10  Exceptions",
    "section": "",
    "text": "10.1 Handling Exceptions\nWe can use try..except statements to catch exceptions. The try statement contains the block of code that may raise an exception, as well as the exception handlers that handle those exceptions. The except block contains all the error handlers.\nThe basic syntax of a try..except statement is:\ntry:\n    # Code that may raise exception\n    x = 1 / 0  \nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\n\nCannot divide by zero\nIn the above code example:",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "exceptions.html#handling-exceptions",
    "href": "exceptions.html#handling-exceptions",
    "title": "10  Exceptions",
    "section": "",
    "text": "The try statement contains code that may raise an exception, i.e. x = 1 / 0.\n\nThe except statement contains the code to handle exceptions, i.e. print(\"Cannot divide by zero\").\nThe except statement can handle a single specified exception or a tuple of exceptions inside parentheses.\n\nIf no exception type is specified, the except statement will catch all types of exceptions.\nIn the code sample, except ZeroDivisionError specifies to only catch ZeroDivisionError exceptions. This is a specific exception type for handling divide by zero errors.\nEach try statement can have multiple except statements to handle different types of exceptions. However, only one except statement will be executed.\n\nEach try statement must have at least one except statement or finally statement to handle exceptions.\n\n\n10.1.1 The else Statement\nThe else statement is used to specify a block of code to execute if no exception occurs. The basic syntax of the else statement is:\n\ntry:\n    # Code that may raise exception  \n    x = 1 / 1   \nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\nelse:\n    # Code to execute if no exception occurs\n    print(\"No exceptions occurred\") \n\nNo exceptions occurred\n\n\nIn the above code example:\n\nThe else statement contains code to execute if no exception occurs, i.e. print(\"No exceptions occurred\").\nThe else statement is usually used to perform some clean-up operations when no exception occurs.\nThe else statement must appear after all except statements but before the finally statement.\n\n\n\n10.1.2 The finally Statement\nThe finally statement is used to specify a block of code to execute regardless of whether an exception occurs or not. The finally statement is usually used to release resources or perform clean-up operations. The basic syntax of the finally statement is:\n\ntry:\n    # Code that may raise exception\n    x = 1 / 0   \nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")  \nelse:\n    # Code to execute if no exception occurs\n    print(\"No exceptions occurred\")\nfinally:\n    # Code to execute regardless of exception \n    print(\"This is always executed\")\n\nCannot divide by zero\nThis is always executed\n\n\nIn the above code example:\n\nThe finally statement contains code to always execute regardless if an exception occurs or not, i.e. print(\"This is always executed\").\nThe finally statement is usually used to release resources or perform clean-up operations. For example, we can close files, release locks, close database connections etc. in a finally statement.\n\n\n\n10.1.3 The with Statement\nIn Python, the with statement is syntactic sugar that is mainly used to simplify resource management related code. For resources like file operations, network connections, database connections etc. that require explicit release after use, we can use the with statement to automatically manage the release of resources, making the code more concise and avoiding potential resource leaks.\n\n\n\n\n\n\nWhat is Syntactic Sugar\n\n\n\nSyntactic sugar refers to syntax designed to make certain programming tasks easier to read or more expressive. Its main purpose is to improve readability of programs, make code more concise, or make semantics more explicit.\nThe term “syntactic sugar” was originally coined by Peter J. Landin (a computer scientist) in 1964, and is used figuratively to describe features that don’t add new functionality to a computer language but make it more pleasant for humans to write or read code.\nThe figurative meaning of this noun is that such syntax is like adding some “sugar” to code, making the code that may otherwise be dull and rigid become sweeter and more aesthetic, bringing fun to programming. Just like sugar improves the taste of food without adding nutrition, syntactic sugar makes code more pleasant and easier to understand without changing the core functionality or semantics of the programming language.\nFor example, decorators and list comprehensions in Python don’t add any new functionality to the language, they just make it clearer to write code with the same functionality, making programming more enjoyable. So they are called “syntactic sugar”.\n\n\nThe basic syntax of a with statement is:\nwith expression as variable:\n    # code block\nWhere expression must be an object that implements the __enter__ and __exit__ methods.\n\nThe __enter__ method is invoked before executing the code block, used to return a resource object.\nThe __exit__ method is invoked after finishing executing the code block, responsible for cleaning up or releasing resources.\n\nAn example of using a with statement is:\nwith open(r\"practical_code\\input_and_output\\data.pkl\", \"wb\") as f:\n    pickle.dump(data, f) \nIn the above code example:\n\nThe with statement first invokes the __enter__ method of the file object to open the file, and then assigns the returned file object to f.\nNext, the with statement executes the code block, i.e. pickle.dump(data, f).\n\nRegardless if this code block raises exceptions or not, the with statement invokes the __exit__ method of the file object to close the file. So we don’t need to explicitly call f.close() to close the file.\n\nWhen handling exceptions without using with statements, we would need to explicitly call f.close() in a finally statement of the try block to close the file. By using with statements, we don’t need to do this.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "exceptions.html#exception-classes",
    "href": "exceptions.html#exception-classes",
    "title": "10  Exceptions",
    "section": "10.2 Exception Classes",
    "text": "10.2 Exception Classes\nPython provides some built-in exception classes to represent different types of error conditions. Common exception classes include:\n\nException: Base class for all exception classes.\n\nNameError: Name error, raised when trying to access a variable or function that does not exist.\nTypeError: Type error, raised when an operation or function is applied to an incompatible type.\n\nValueError: Value error, raised when an operation or function is applied to an object with the correct type but invalid value.\n\nIndexError: Index error, raised when trying to access an index of a list, tuple or string that does not exist.\n\nKeyError: Key error, raised when trying to access a key in a dictionary that does not exist.\n\nFileNotFoundError: File not found error, raised when trying to open a file that does not exist.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "exceptions.html#raising-exceptions",
    "href": "exceptions.html#raising-exceptions",
    "title": "10  Exceptions",
    "section": "10.3 Raising Exceptions",
    "text": "10.3 Raising Exceptions\nWe can use the raise statement to raise exceptions. The raise statement is used to raise a specified exception.\nThe exception that can be raised can be an instance of any class, but is usually an instance of built-in exception classes. The basic syntax of a raise statement is:\nraise ValueError(\"Invalid value\") \nThis line of code raises a ValueError exception with the error message Invalid value. In general, we raise exceptions this way to notify callers that some specific error condition has occurred, and we can define custom exception classes for such cases.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "exceptions.html#custom-exception-classes",
    "href": "exceptions.html#custom-exception-classes",
    "title": "10  Exceptions",
    "section": "10.4 Custom Exception Classes",
    "text": "10.4 Custom Exception Classes\nA custom exception class is a class that inherits from the Exception class. We can create custom exception classes by inheriting from the Exception class. The basic syntax of a custom exception class is:\nclass ShortInputException(Exception):\n    def __init__(self, length, atleast):\n        self.length = length\n        self.atleast = atleast\ntry:\n    text = input(\"Enter something --&gt; \")\n    if len(text) &lt; 3:\n        raise ShortInputException(len(text), 3)  \nexcept EOFError:\n    print(\"Why did you do an EOF on me?\")\nexcept ShortInputException as e:\n    #print(\"ShortInputException: The input was of length %d, was expecting at least %d\" % (e.length, e.atleast))\n    print(f\"ShortInputException: The input was of length {e.length}, was expecting at least {e.atleast}\")\nelse:\n    print(\"No exception was raised\")\nIn the above code example:\n\nShortInputException is a custom exception class that inherits from the Exception class.\nThe statement raise ShortInputException(len(text), 3) raises a ShortInputException exception.\n\nWhen an except statement catches an exception, it generates an exception instance containing the details. We can use the as keyword to assign the instance a variable name that we can then access in the except block for the exception details.\n%d is a placeholder for formatting strings. The % operator is used for string formatting. In this case, %d indicates inserting an integer into the string.\n\nIn Python 3.6 and later, we can use f-strings for string formatting. F-strings provide a new way to format strings where variables can be directly inserted using variable names instead of placeholders, making it more intuitive and flexible.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Exceptions</span>"
    ]
  },
  {
    "objectID": "standard_library.html",
    "href": "standard_library.html",
    "title": "11  Standard Library",
    "section": "",
    "text": "11.1 The sys Module\nThe sys module provides variables and functions for interacting with the Python interpreter.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Standard Library</span>"
    ]
  },
  {
    "objectID": "standard_library.html#the-sys-module",
    "href": "standard_library.html#the-sys-module",
    "title": "11  Standard Library",
    "section": "",
    "text": "11.1.1 sys.argv\nAs we saw in Section 5.1.1, sys.argv is a list containing command line arguments.\nWe summarize again here:\n\nsys.argv[0] is the script name\n\nsys.argv[1] is the first argument\nsys.argv[2] is the second argument\nLength of sys.argv is number of command line arguments\n\nA simple example:\n\nimport sys\n\nprint(sys.argv) \n\n['C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\ipykernel_launcher.py', '-f', 'C:\\\\Windows\\\\Temp\\\\tmpcg7zx9fv.json', '--HistoryManager.hist_file=:memory:']\n\n\n\n\n11.1.2 sys.version\nsys.version contains Python interpreter version info.\n\nimport sys\n\nprint(sys.version)\n\n3.11.8 | packaged by conda-forge | (main, Feb 16 2024, 20:40:50) [MSC v.1937 64 bit (AMD64)]\n\n\nsys module has a tuple called version_info containing version info too.\n\n\n11.1.3 sys.path\nsys.path is a list containing module search paths.\n\nimport sys\n\nprint(sys.path)  \n\n['C:\\\\Conda_data\\\\envs\\\\main\\\\python311.zip', 'C:\\\\Conda_data\\\\envs\\\\main\\\\DLLs', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib', 'C:\\\\Conda_data\\\\envs\\\\main', '', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\win32', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\win32\\\\lib', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\Pythonwin']",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Standard Library</span>"
    ]
  },
  {
    "objectID": "standard_library.html#the-os-module",
    "href": "standard_library.html#the-os-module",
    "title": "11  Standard Library",
    "section": "11.2 The os Module",
    "text": "11.2 The os Module\nThe os module provides many functions to interact with the operating system.\nCommon operations include getting current working directory, changing directory, creating/deleting directories/files etc.\n\n11.2.1 os.getcwd()\nos.getcwd() returns current working directory.\n\nimport os\n\nprint(os.getcwd())\n\nC:\\Users\\WeiZichao\\OneDrive - MSFT\\Code\\MyProjects\\My-Python-Learning\n\n\n\n\n11.2.2 os.listdir()\nos.listdir() returns files and directories in the specified directory.\n\nimport os\n\nprint(os.listdir())\n\n['.git', '.gitignore', '.quarto', 'basic.qmd', 'control_flow.qmd', 'data_structures.qmd', 'docs', 'exceptions.qmd', 'functions.qmd', 'index.qmd', 'input_and_output.qmd', 'LICENSE', 'modules.qmd', 'more.qmd', 'object_oriented_programming.qmd', 'operators_and_expressions.qmd', 'practical_code', 'problem_solving.qmd', 'python-logo-only.svg', 'README.md', 'README.zh-CN.md', 'references.bib', 'references.qmd', 'standard_library.ipynb', 'standard_library.qmd', '_book', '_quarto.yml']\n\n\n\n\n11.2.3 os.mkdir()\nos.mkdir() creates a new directory.\nimport os\n\nos.mkdir(r'practical_code/standard_library/newdir') \n\n\n11.2.4 os.remove()\nos.remove() deletes a file.\nimport os\n\nos.remove(r'practical_code/standard_library/newdir')\n\n\n11.2.5 os.rmdir()\nos.rmdir() deletes a directory.\nimport os\n\nos.rmdir(r'practical_code/standard_library/newdir')",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Standard Library</span>"
    ]
  },
  {
    "objectID": "standard_library.html#the-logging-module",
    "href": "standard_library.html#the-logging-module",
    "title": "11  Standard Library",
    "section": "11.3 The logging Module",
    "text": "11.3 The logging Module\nThe logging module provides a flexible way to record log information.\nBasic logging module syntax:\n\nimport logging\n\nlogging.debug('This is a debug message')  \nlogging.info('This is an info message')\nlogging.warning('This is a warning message')\nlogging.error('This is an error message') \nlogging.critical('This is a critical message')\n\nWARNING:root:This is a warning message\nERROR:root:This is an error message\nCRITICAL:root:This is a critical message\n\n\nAdditionally, the logging module also provides configuration options like outputting log messages to specified locations, specifying log format, log level etc.\nA slightly more complex example:\n\nimport os\nimport logging\n\nlogging_file = os.path.join(os.getcwd(), 'practical_code/standard_library/logging.log')  \n\nprint(\"Logging to\", logging_file)  \n\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    filename=logging_file,\n    filemode='w'  \n)\n\nlogging.debug('This is a debug message')\nlogging.info('This is an info message') \nlogging.warning('This is a warning message')\n\nWARNING:root:This is a warning message\n\n\nLogging to C:\\Users\\WeiZichao\\OneDrive - MSFT\\Code\\MyProjects\\My-Python-Learning\\practical_code/standard_library/logging.log\n\n\nIn the above sample code:\n\nlogging_file is path to log file, configured here as practical_code/standard_library/logging.log\nlogging.basicConfig() configures log format, level, output location etc.\n\nFunctions like logging.debug(), logging.info(), logging.warning() etc record log messages\nfilemode='w' opens log file in write mode, overwriting existing files if any\n%(asctime)s, %(name)s, %(levelname)s, %(message)s are log format placeholders for log timestamp, name, level and message respectively.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Standard Library</span>"
    ]
  },
  {
    "objectID": "standard_library.html#module-of-the-week-series",
    "href": "standard_library.html#module-of-the-week-series",
    "title": "11  Standard Library",
    "section": "11.4 Module of the Week Series",
    "text": "11.4 Module of the Week Series\nBesides the modules introduced above, there are many other useful standard library modules like debugging, testing, file handling, network communication, date/time handling, math/science, encryption etc.\nAdditionally, Doug Hellmann’s Python Module of the Week is a great resource introducing many modules in the Python standard library.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Standard Library</span>"
    ]
  },
  {
    "objectID": "more.html",
    "href": "more.html",
    "title": "12  More",
    "section": "",
    "text": "This section will be used to record issues I encounter and knowledge points when actually using Python.\n(For now this section is still empty.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>More</span>"
    ]
  }
]