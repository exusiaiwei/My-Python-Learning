{
  "hash": "8919d5d4f58205dc0e74e81e892f8631",
  "result": {
    "engine": "jupyter",
    "markdown": "# Modules\n\n## Basic Concepts  \n\nIn Python, modules are a way of organizing and reusing code. A module is a file containing functions, classes and variables that can be imported and used by other programs.  \n\nThe basic idea behind modules is to organize related code together to improve maintainability and reusability. By splitting code into modules, readability and maintainability can be improved.  \n\nModules have the following characteristics:  \n\n- Encapsulation: Modules encapsulate related code into a single file, making the code more organized and manageable.   \n- Namespace: Modules create an isolated namespace that avoids naming conflicts. Functions, classes and variables defined inside modules can be accessed using the module name as prefix, avoiding conflicts.\n- Code Reuse: Modules can be imported and used by other programs, enabling code reuse. By importing a module, functions, classes and variables defined in it can be used directly without rewriting code.  \n- Extensibility: Modules can be extended and modified as needed. New functions, classes and variables can be added to modules to meet different requirements.  \n\nIn Python, modules can be written in Python or other languages like C/C++ and compiled into binary code. The latter are usually called \"compiled modules\" or \"extension modules\".  \n\nThey are commonly used to improve performance (compiled code runs faster) or provide functionality Python itself cannot provide directly (like calling low-level OS APIs).\n\nSee code sample below for module usage:  \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport sys\n\nprint(\"The script has the name %s\" % (sys.argv[0]))\nif len(sys.argv) > 1:\n    print(\"It has some arguments:\")\n    for arg in sys.argv[1:]:\n        print(arg)\n\nprint('\\n\\nThe PYTHONPATH is', sys.path, '\\n')  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe script has the name C:\\Conda_data\\envs\\main\\Lib\\site-packages\\ipykernel_launcher.py\nIt has some arguments:\n-f\nC:\\Windows\\Temp\\tmpay3ixgdj.json\n--HistoryManager.hist_file=:memory:\n\n\nThe PYTHONPATH is ['C:\\\\Conda_data\\\\envs\\\\main\\\\python311.zip', 'C:\\\\Conda_data\\\\envs\\\\main\\\\DLLs', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib', 'C:\\\\Conda_data\\\\envs\\\\main', '', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\win32', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\win32\\\\lib', 'C:\\\\Conda_data\\\\envs\\\\main\\\\Lib\\\\site-packages\\\\Pythonwin'] \n\n```\n:::\n:::\n\n\n### The `sys` Module{#sec-sys}\nThe `sys` module contains system-related functions and variables in Python.  \n\n- `sys.argv` is a list in Python containing command line arguments passed to a Python script.\n- These arguments are stored as strings, where `sys.argv[0]` is the script name (the executed Python file name) and the rest `sys.argv[1]`, `sys.argv[2]` etc are external arguments passed in order.\n- In the `sys` module, `argv` variable can be accessed with dot notation `sys.argv`. This clearly indicates `argv` is part of `sys` module and avoids conflicts with any `argv` variable used in the program.\n\n\n## The `import` Statement  \n\nWhen Python executes an `import` statement, the Python interpreter searches for the object to import through the following steps:\n\n1. First, the interpreter checks built-in modules. Python's built-in modules are written in C and linked to the Python interpreter. For example `sys` used in the sample code is a built-in module.  \n2. If not found in built-in modules, Python interpreter then checks the `sys.modules` dictionary next. `sys.modules` stores paths and module objects for all imported modules. Think of it as a history record or cache for modules already imported by Python. If the module has been imported before, get it directly from this dictionary.\n3. If still not found in `sys.modules`, the Python interpreter then checks the `sys.path` list. `sys.path` contains locations searched by the Python interpreter for modules, including:  \n   1. The current working directory where the program is being executed when launched. Run `import os; print(os.getcwd())` to find the program's current directory.\n   2. Some standard library directories of Python \n   3. Additional paths where third party packages are installed. Usually under the `site-packages` directory.  \n4. Python searches for the module to import through the directories listed in `sys.path` from top to bottom in order. It checks each directory to see if it contains the module to import. If not found in any of the directories, Python raises a `ModuleNotFoundError`.\n\n## Byte-compiled `.pyc` Files  \n\nIn Python, byte-compiled `.pyc` files are an optimization technique used to improve execution speed of Python programs. When the Python interpreter executes a module, it compiles the module source code into bytecode and saves the bytecode to a `.pyc` file with same name as the module.  \n\nTypically these `.pyc` files are created in the same directory as the corresponding `.py` files. If Python does not have write permission to that directory, `.pyc` files will not be created. In Python 3, modules from standard library and third party libraries are installed under Python's installation directory, their `.pyc` files are usually stored under the `__pycache__` directory.  \n\nWhether it's your own written modules or downloaded modules, as long as they have been executed by the Python interpreter before, corresponding `.pyc` files will be generated to improve program execution speed.  \n\nByte-compiled `.pyc` files have the following characteristics:   \n\n- Improved execution speed: Since bytecode is an intermediate form closer to machine language compared to source code, executing bytecode is faster than executing source code. By saving the bytecode of modules to `.pyc` files, recompiling source code every time the module executes can be avoided, improving program execution speed.\n- Cross-platform compatibility: `.pyc` files are platform-independent and can execute on different operating systems. This means `.pyc` files compiled on one platform can be copied to another platform for execution without needing to recompile the source code.  \n- Caching mechanism: Python interpreter checks timestamp of `.pyc` files to determine if source code needs recompiling. If source code is unchanged and `.pyc` file timestamp is newer, interpreter loads `.pyc` file directly instead of recompiling source code. This caching mechanism reduces program startup time and memory usage.   \n- Poor readability: `.pyc` files contain compiled bytecode and have poorer readability compared to source code. This is because bytecode is a low-level machine-oriented representation while source code is human-readable high-level language. So `.pyc` files don't normally need manual editing or inspection.  \n\n## `from...import` Statements  \n\nUsing `from...import` statements allows us to directly call imported functions or objects without needing to prefix the module name. For example, we can directly import `sqrt` function from `math` module, so we don't need to write `math.` when calling it.  \n\nThe benefit of this approach is we can selectively import only the functions or classes we want to use instead of loading the entire module, saving some memory compared to the first approach. However, having too many `from...import` statements or importing functions of the same name from multiple modules in code can cause namespace pollution and function conflicts.  \n\nWe can also use `from...import` statements to import multiple functions or classes, for example, importing `sqrt` and `pi` from `math` module:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom math import sqrt\nprint(sqrt(16))  # Output: 4.0  \n\nfrom math import sqrt, pi\nprint(sqrt(16)) # Output: 4.0\nprint(pi)       # Output: 3.141592653589793\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4.0\n4.0\n3.141592653589793\n```\n:::\n:::\n\n\n## The `__name__` attribute of Python modules   \n\nIn Python, every module has a built-in attribute called `__name__`, which is extremely important for understanding how modules are loaded and the difference between modules and execution scripts.  \n\nWhen directly running a `.py` file (e.g. executing `python your_script.py` from command line), Python automatically sets the `__name__` attribute to `'__main__'`. In this case, we say `your_script.py` runs as a script.  \n\nHowever, if you import the `.py` file as a module (e.g. `import your_script` in another `.py` file), Python automatically sets `__name__` attribute to the module's name (which would be `your_script` in this example). In this case, we say  `your_script.py` is an imported module.\n\nSee the following sample code:  \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nif __name__ == '__main__':\n    print('This program is being run by itself')  \nelse:\n    print('I am being imported from another module')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis program is being run by itself\n```\n:::\n:::\n\n\nBased on the above attribute, many Python scripts (especially those run both as modules and scripts) contain the following code at the end of the file:  \n\n```\nif __name__ == \"__main__\":\n    run_my_script()  \n```\n\nWhere `run_my_script()` is a function defined in the script. The purpose of this code segment is:  \n\n- If you directly run this `.py` file, Python executes the `run_my_script()` function;  \n- If you import this `.py` file as module, Python does NOT execute `run_my_script()` function.   \n\nThis allows a Python module to be safely imported while also independently runnable, which is a common and useful technique in Python programming.  \n\nIn summary, as a built-in module attribute in Python, `__name__` can effectively distinguish between direct script execution and imported module calls, playing an important role in understanding and controlling Python code flow.\n\n## Making Your Own Modules   \n\nIn Python, any `.py` file can be treated as module. You just need to organize your code properly and save it as a `.py` file.  \n\nWhen importing modules, Python interpreter searches for module files in some specific directories, paths of which are stored in `sys.path` list. If your module is in a path outside these directories, you need to append module path to system path, like the sample code below:  \n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Code sample from: A Byte of Python\nimport sys\nsys.path.append(\"practical_code/modules\") # Add module path  \n\nimport mymodule\n\nmymodule.say_hi()  \nprint('Version', mymodule.__version__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHi, this is mymodule speaking.\nVersion 0.1\n```\n:::\n:::\n\n\nSample code using `from..import` statement:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Code sample from: A Byte of Python\nimport sys\nsys.path.append(\"practical_code/modules\")   \n\nfrom mymodule import say_hi, __version__\n\nsay_hi()\nprint('Version', __version__) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHi, this is mymodule speaking.\nVersion 0.1\n```\n:::\n:::\n\n\n## The `dir` Function  \n\nThe `dir` function is a built-in function in Python that returns a list of attributes and methods of an object. It accepts an optional argument which is the name of an object or module. If directly calling `dir()` without arguments, it returns names of all variables, functions, classes etc accessible in the current scope.  \n\nBasic concepts:\n- Object: Everything is object in Python, including numbers, strings, lists, functions etc. \n- Attribute: Characteristics or data of an object, accessible via dot operator.  \n- Method: Behaviors or functionalities of an object, can be called via dot operator.   \n\nCharacteristics:\n- `dir` function returns a list containing names of all attributes and methods of an object or module.  \n- Returned list is unordered without guaranteed order of attributes and methods.\n- `dir` only returns public attributes and methods, not including private ones.   \n- If argument is a module name, returned list contains names of all public module attributes and methods.\n- If argument is an object, returned list contains all attribute and method names of that object.  \n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\na = 5\n# Call dir() and print all names in current global scope \nprint(dir())  \n\n# Delete variable a  \ndel a   \n\n# Call dir() again\nprint(dir()) # This time, 'a' disappears from returned list since we deleted it  \n\n# Use dir() to view all sys attributes and methods\nimport sys\ndir(sys)\n\ndef my_function():\n    \"\"\"\n    This is a sample function. \n    \"\"\"\n    pass\n\n# Use dir() to view attributes and methods of my_function  \nprint(dir(my_function)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['In', 'Out', '__builtin__', '__builtins__', '__name__', '__version__', '_dh', '_i', '_i1', '_i2', '_i3', '_i4', '_i5', '_i6', '_ih', '_ii', '_iii', '_oh', 'a', 'arg', 'exit', 'get_ipython', 'mymodule', 'ojs_define', 'open', 'pi', 'quit', 'say_hi', 'sqrt', 'sys']\n['In', 'Out', '__builtin__', '__builtins__', '__name__', '__version__', '_dh', '_i', '_i1', '_i2', '_i3', '_i4', '_i5', '_i6', '_ih', '_ii', '_iii', '_oh', 'arg', 'exit', 'get_ipython', 'mymodule', 'ojs_define', 'open', 'pi', 'quit', 'say_hi', 'sqrt', 'sys']\n['__annotations__', '__builtins__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__getstate__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']\n```\n:::\n:::\n\n\n- When `dir()` is called without arguments, it returns a list of variable, method and type names defined in the current scope.  \n- When new variables or methods are created, they get added to this list; when deleted, they disappear from the list.\n- When `dir()` is called with module or function names as argument like `dir(sys)`, it returns a list containing names of all attributes and methods of that module or function.  \n- Calling `dir()` on a custom module or function returns a list including:    \n  - `__doc__`: The docstring of the module or function, i.e. the description text enclosed within triple quotes when you defined it.\n  - `__name__`: Name of the module or function. \n    - For modules, `__name__` is `'__main__'` if directly running the module script, or the module's own name if imported by other programs.\n    - For functions, `__name__` is the function's name.  \n  - `__module__`: The `__module__` attribute exists only on function objects, representing the name of module that defined the function. \n    - For functions defined in main program, `__module__` is usually `'main'`; \n    - For functions defined in imported modules, `__module__` is that module's name.\n\n\n## Packages  \n\nIn Python, a package is a way of organizing and managing Python modules. You can simply think of packages as folders containing one or more Python modules.  \n\nA Python package may contain Python modules, sub-packages, or some auxiliary files like documentation and data files. Main goal of Python packages is to provide a convenient way to organize and share a group of related code functionalities.   \n\nUsually there is a special file called `__init__.py` in Python packages that marks the containing folder as a Python package, it can contain initialization code or specify attributes of the package. However from Python 3.3 onwards, so-called namespace packages are also supported where `__init__.py` files are no longer mandatory.  \n\nCode example:  \n\nIf we have the following directory structure:  \n\n```\nmy_package/\n├── __init__.py\n├── module1.py\n└── sub_package/\n    ├── __init__.py\n    └── module2.py\n    \n```\nIn this structure, `my_package` is a Python package containing one module `module1` and one sub-package `sub_package`. `sub_package` is also a Python package containing one module `module2.py`.  \n\nAssuming in `module1.py` we define a function `func1`, and in `module2.py` we define a function `func2`.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# File path: my_package/module1.py\n\ndef func1():\n    print(\"This is function 1 from module 1\")\n    \n# File path: my_package/sub_package/module2.py  \n\ndef func2():\n    print(\"This is function 2 from module 2\")     \n```\n:::\n\n\nIn Python we can import and use these functions as:  \n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nimport sys\nsys.path.append(\"practical_code/modules\") # Add package path \n\n# Import module1 module from my_package package  \nimport my_package.module1  \n\n# Call func1 function from module1\nmy_package.module1.func1()  # Outputs: This is function 1 from module 1  \n\n# Import module2 module from sub_package package\nimport my_package.sub_package.module2  \n\n# Call func2 function from module2\nmy_package.sub_package.module2.func2()  # Outputs: This is function 2 from module 2  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is function 1 from module 1\nThis is function 2 from module 2\n```\n:::\n:::\n\n\n",
    "supporting": [
      "modules_files"
    ],
    "filters": []
  }
}