{
  "hash": "9bfbc9fcfdd0d387a08c3e4243a65a26",
  "result": {
    "engine": "jupyter",
    "markdown": "# Data Structures\n\n## Sequence\n\nIn Python, the sequence is the most basic data structure. Each element in the sequence is assigned a number - its position, or index, with the first index being 0, the second index being 1, and so on.\n\nPython has three common types of sequences:\n\n- List\n- Tuple\n- String\n\nThe other three non-sequence data structures are:\n\n- Set\n- Dictionary\n- Frozenset\n\nThese three types are not ordered and cannot be accessed via indexes.\n\n## List\n\nPython's list is similar to arrays in other programming languages, but they are more flexible. The elements in the list don't need to be of the same data type.\n\nLists are characterized by elements being surrounded by square brackets `[]` and separated by commas `,`.\n\n::: {#ae2fdf9d .cell execution_count=1}\n``` {.python .cell-code}\nmylist = [1, \"apple\", 3.14]\nprint(mylist[0]) # prints: 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n```\n:::\n:::\n\n\nList:\n\n- Is ordered\n- Is mutable\n- Can contain elements of any type \n- Elements can be accessed by index, with indexes starting from 0\n\n::: {.callout-tip}\nNote, Python's indexing starts from 0. This means that when accessing list elements using indexes, the first element in the list is `list[0]`, the second element is `list[1]`, and so on.\n:::\n\n## Tuple\n\nA tuple is an ordered, immutable list. It can be understood as a \"read-only\" version of a list.\n\nTuples use parentheses `()` to enclose elements and are separated by commas `,`.\n\n::: {#674b2714 .cell execution_count=2}\n``` {.python .cell-code}\nmy_tuple = (1, \"apple\", 3.14)\nprint(my_tuple[0]) # prints: 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n```\n:::\n:::\n\n\nTuples:\n\n- Are ordered\n- Are immutable\n- Can contain elements of any type \n- Elements can be accessed by index, with indexes starting from 0\n\nBelow is a code example illustrating the difference between tuples and lists.\n\n::: {#fb2526e1 .cell execution_count=3}\n``` {.python .cell-code}\n# Create a list\nmy_list = [1, 2, 3]\n# Add an element to the end of the list\nmy_list.append(4)\nprint(my_list[3])\n# Create a tuple\nmy_tuple = (1, 2, 3)\n# You can't modify a tuple\n# my_tuple.append(4)  # This would throw an error\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n:::\n\n\n## Set\n\nA set is a non-ordered data structure that does not allow duplicate elements.\n\nSets enclose elements with curly braces `{}` and separate them with commas `,`.\n\n::: {#eb8e9eec .cell execution_count=4}\n``` {.python .cell-code}\nmy_set = {1, \"apple\", 3.14, \"apple\"}\nprint(my_set) # prints: {1, \"apple\", 3.14}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'apple', 1, 3.14}\n```\n:::\n:::\n\n\nSet:\n\n- Is unordered\n- Does not allow duplicate elements\n- Can contain elements of any type \n- Can not be accessed by indexes\n\n\n## Dictionary\n\nA dictionary is an unordered set of key-value pairs.\n\nA \"key-value pair\" refers to two associated parts: one is a unique key, and the other is its value. Each key has an associated value. This association is called \"mapping\".\n\nDictionaries enclose elements with curly braces `{}`, separate keys and values with colons `:`, and key-value pairs with commas `,`.\n\n::: {.callout-tip}\n# Why called Dictionary\n\nIn a physical dictionary, you can find a corresponding explanation or translation (corresponding to the \"value\" in the computer) based on the entry (corresponding to the \"key\" in the computer). This constitutes an \"entry-explanation\" pair, similar to the \"key-value pair\" in computer science.\n\nTherefore, considering this mapping relationship, this data structure containing \"key-value pairs\" in computer science is named Dictionary.\n:::\n\n::: {#80d41c2f .cell execution_count=5}\n``` {.python .cell-code}\nmy_dict = {\n    \"name\": \"apple\",\n    \"color\": \"red\",\n}\nprint(my_dict[\"name\"]) # prints: apple\n\nages = {\n    \"Tom\": 30, \n    \"Alice\": 25, \n    \"Bob\": 27\n}\n\nprint(ages[\"Alice\"]) # prints：25\nages[\"Tom\"] = 31\nprint(ages[\"Tom\"]) # prints：31\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple\n25\n31\n```\n:::\n:::\n\n\nDictionaries:\n\n- Are unordered\n- In key-value pairs, the key is unique, but the value can be duplicated\n- Can contain elements of any type \n- Elements are accessed by keys\n\n## Object and Class {#sec-objects-and-classes}\n\nPython is an object-oriented programming language. In Python, almost everything is an object with its properties and methods. A class provides a mechanism for defining the kind or type for creating objects.\n\nObject: In Python, an object is a core unit of data. Each object has a type (such as a string, list, dictionary, etc.), and a unique identity (or address in memory). An object can contain various data (i.e., attributes) and functionalities (i.e., methods). It can be seen as an objective entity in the real world, such as a table, a circle, a person, etc.\n\nFor instance, a person (object) has a name (attribute) and can conduct various activities (methods) such as running, studying, etc.\n\nClass: A class is a template or blueprint for objects. It defines the basic structure of an object and encapsulates the behaviors (methods) that an object needs to perform. You can define a class to create objects that belong to this class. A class is like a factory for making objects, responsible for specifying what features its products should have.\n\nFor example, you can define a class \"Person\" that has attributes like name and age, and methods like eating, sleeping, etc. Then based on this \"Person\" class, we can create different person objects, such as creating a person object named \"Tom\" that is 25 years old.\n\n::: {#1d15091b .cell execution_count=6}\n``` {.python .cell-code}\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def introduce(self):\n        return f\"Hello, my name is {self.name} and I am {self.age} years old.\"\n\nsomeone = Person('Tom', 25)\n\nprint(someone.introduce())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, my name is Tom and I am 25 years old.\n```\n:::\n:::\n\n\n## References\n\nIn Python, whenever you create an object and assign it to a variable, Python does not store the object's value in the variable. Instead, Python simply sets the variable to be a reference that points to the object stored in memory. This is known as binding variable names to objects, or called references.\n\n### Creating Objects and References\n\n\nFor example, when you create a list and assign it to a variable:\n\n::: {#c2bd41d9 .cell execution_count=7}\n``` {.python .cell-code}\nlist1 = [1, 2, 3]\n```\n:::\n\n\nAt this point, list1 is just a reference that points to a list object stored in memory, which contains the elements 1, 2, 3. If you create another reference that points to the same object: \n\n::: {#6e139a00 .cell execution_count=8}\n``` {.python .cell-code}\nlist2 = list1\n```\n:::\n\n\nNow you have two references - list1 and list2, both pointing to the same object.\n\n\n### Modifying Mutable Type Objects\n\n\nIf you modify the object through one of the references, for example deleting the first element through list1:\n\n::: {#730ce562 .cell execution_count=9}\n``` {.python .cell-code}\ndel list1[0]  \n```\n:::\n\n\nThen no matter whether you access this list object through list1 or list2, you will find that the content of this object has changed:\n\n::: {#4547457d .cell execution_count=10}\n``` {.python .cell-code}\nprint(list1)  # prints: [2, 3]  \nprint(list2)  # prints: [2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 3]\n[2, 3]\n```\n:::\n:::\n\n\nThis is because list1 and list2 are just references, they do not contain the actual list content themselves, but only point to a location in memory, which is the address of the same list object.\n\n\n### Copying Objects\n\n\nHowever, sometimes you may need to create a copy of an object, so that you can modify the copy without affecting the original object. For example, you can create a copy of a list through slice operation:\n\n::: {#dcaa47ec .cell execution_count=11}\n``` {.python .cell-code}\nlist3 = list2[:]\n```\n:::\n\n\nNow list3 references a completely new list object, whose content is a complete copy of the list that list2 points to. So when you change the content of list3, the content of the list that list2 points to will not be modified:\n\n::: {#9fe46b5a .cell execution_count=12}\n``` {.python .cell-code}\ndel list3[0]\nprint(list2) # prints: [2, 3]   \nprint(list3) # prints: [3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 3]\n[3]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "data_structures_files"
    ],
    "filters": [],
    "includes": {}
  }
}