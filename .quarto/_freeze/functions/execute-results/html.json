{
  "hash": "cb8d9d0478bd539d20dae1ae1d1ebd8e",
  "result": {
    "engine": "jupyter",
    "markdown": "# Functions\n\nFunctions are basic building blocks in programming that allow us to name a block of code and reuse it wherever needed. The act of executing these statements is called calling the function.  \n\nIn our learning process, we have already come across and used many of Python's built-in functions like `len` and `range`.  \n\nWe use the `def` keyword to define functions. The `def` keyword is followed by the function name and parentheses `()`. The parentheses may contain some parameters (preset variable names), and the line ends with a colon `:`.\n\n::: {#3adc165f .cell execution_count=1}\n``` {.python .cell-code}\ndef say_hello():\n    # Block belonging to the function \n    print('hello world')  \n# End of function\n\nsay_hello() # Call the function  \nsay_hello() # Call the function again\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello world\nhello world\n```\n:::\n:::\n\n\nThe above code defines a function named `say_hello`. This function accepts no parameters, so there are no variables declared in the parentheses. We can pass in different arguments to let the function take different inputs and produce corresponding results.  \n\n## Function Parameters  \n\nFunctions can accept parameters and utilize these values to produce some effect.  \n\nParameter:  \n\n- When defining a function, we reserve some space for the function which are called parameters. Parameters are the receivers of the function definition.\n- Parameters are defined within the function header's parentheses, separated by commas. They are accessible within the entire function body.  \n- Parameters are variables used to store the values passed in during function calls (arguments).\n\nArgument:   \n\n- When calling a function, we pass in some values to the function, these values are called arguments. Arguments are the inputs of a function call.   \n- Arguments assign concrete values to the parameters defined in the function. Also separated by commas.  \n\nThis concept is analogous to a recipe and cooking. The list of ingredients on a recipe (e.g. certain grams of flour, certain grams of sugar) is like the parameter list, while the actual amount of flour and sugar you use is like the arguments.\n\n::: {#51734297 .cell execution_count=2}\n``` {.python .cell-code}\n# Code sample from: A Byte of Python\ndef print_max(a, b):\n    if a > b:  \n        print(a, 'is maximum') # Prints a is max  \n    elif a == b:\n        print(a, 'is equal to', b) # Prints a is equal to b\n    else:\n        print(b, 'is maximum') # Prints b is max\n\n# Directly pass literals  \nprint_max(3, 4)  \n\nx = 5\ny = 7\n\n# Pass variables as arguments \nprint_max(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4 is maximum\n7 is maximum\n```\n:::\n:::\n\n\nIn the sample code, we defined a function called `print_max` which contains two parameters `a` and `b`. We use an `if..else` statement to find out the larger number and print it out.  \n\nThe first time calling the `print_max` function, we directly provide numbers as arguments. In the second case, we use variables `x`, `y` as arguments when calling the function. `print_max(x, y)` causes the value of parameter `x` to be assigned the value of argument `x`, and the value of parameter `y` to be assigned the value of argument `y`.  \n\n## Local Variables  \n\n- Variables declared inside a function definition are called \"local variables\".  \n- The scope of \"local variables\" is limited to within the function where it is declared, this constraint is called variable \"scope\".   \n- A variable's scope starts from where it is declared to the end of that code block or function.  \n- Local variables inside functions are viewed as independent even if variables with the same names exist outside the function. Regardless of identical names, local variables inside functions have no relation with variables outside functions.  \n\n::: {#a19aa0b0 .cell execution_count=3}\n``` {.python .cell-code}\n# Code sample from: A Byte of Python\nx = 50  \n\ndef func(x):\n    print('x is', x) # Print x's value  \n    x = 2 # Modify local x's value\n    print('Changed local x to', x) # Prints modified x  \n\nfunc(x)  \nprint('x is still', x) # Prints original x  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is 50\nChanged local x to 2\nx is still 50\n```\n:::\n:::\n\n\nThe first time printing variable `x` inside the function body, Python uses the value of the parameter declared before the function in the main block.  \n\nNext, we assign the local variable `x` in the function a value of 2. When we modify the value of local variable `x` inside the function, the `x` defined in main block remains unaffected.  \n\n## The global statement   \n\n- When we need to assign values to variables defined on a global program level (i.e. not inside a specific scope like functions or classes), we normally use the global declaration statement (`global` statement).   \n- The global statement tells Python we are working with a global variable instead of a local variable.  \n- Note that without using global, we cannot directly modify variables defined outside functions inside the function.\n- When a variable that hasn't been defined is referenced inside a function, Python will try to find that variable outside the function.  \n- Despite this, we don't recommend this practice as it can confuse readers when trying to understand where that variable is defined.  \n- If you want to operate on variables outside functions inside the function, it's recommended to use the `global` statement to explicitly indicate you are manipulating a globally defined variable.  \n\n::: {#c5bf9bea .cell execution_count=4}\n``` {.python .cell-code}\n# Code sample from: A Byte of Python\nx = 50  \n\ndef func():\n    global x\n\n    print('x is', x) # Print x's value   \n    x = 2 # Modify global x's value \n    print('Changed global x to', x) # Prints modified x  \n\nfunc()\nprint('Value of x is', x) # Prints final x  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is 50\nChanged global x to 2\nValue of x is 2\n```\n:::\n:::\n\n\nThe `global` statement declares that `x` is a global variable - therefore, when we assign a value to `x` inside the function, the change reflects when we use `x`'s value in main block.  \n\nYou can use the same `global` statement to specify multiple global variables, e.g. `global x, y, z`.\n\n## Default Parameter Values   \n\nWe can make some function parameters optional by setting default parameter values. When the user does not explicitly provide argument values, the function will use these set default values.  \n\nThis can be achieved by assigning default values after the parameter names in the function definition with an equals sign (=).  \n\n::: {#ddd5fe97 .cell execution_count=5}\n``` {.python .cell-code}\n# Code sample from: A Byte of Python\ndef say(message, times=1):\n    print(message * times)\n    \nsay('Hello') # Prints \"Hello\"  \nsay('World', 5) # Prints \"WorldWorldWorldWorldWorld\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\nWorldWorldWorldWorldWorld\n```\n:::\n:::\n\n\nThe function `say` repeats printing a string a number of times we specify.  \n\n- When we don't explicitly specify print times, the function defaults to printing the string once. This is achieved by setting parameter `times`'s default value to 1.  \n- In the first usage case, we only pass in the string argument, so the function defaults to printing that string once.  \n- In the second usage case, we pass in the string and a number 5 as arguments, indicating we want the string to print 5 times.  \n\nNote:  \n\n- Only parameters at the end of the parameter list can have default parameter values.  \n- That is, in the parameter list of a function, parameters with default values cannot occur before parameters without default values. This is because parameters are assigned positionally.  \n- For example, `def func(a, b=5)` is valid, but `def func(a=5, b)` is invalid.  \n\n## Keyword Arguments   \n\n- If you have a function with many parameters and you want to specify only some of them, you can use named arguments.   \n- Such arguments are called keyword arguments, where the specification of parameter values is by parameter names (keywords) instead of positions (which is what we have been using so far).\n- Using keyword arguments allows us to call functions more flexibly without needing to match the order of parameters as defined in the function.  \n- As long as the other parameters have default values, we can assign values only to the parameters we want.  \n\n::: {#835f3715 .cell execution_count=6}\n``` {.python .cell-code}\n# Code sample from: A Byte of Python  \ndef func(a, b=5, c=10):\n    print('a is', a, 'and b is', b, 'and c is', c)\n\nfunc(3, 7)  \nfunc(25, c=24)\nfunc(c=50, a=100)   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\na is 3 and b is 7 and c is 10\na is 25 and b is 5 and c is 24\na is 100 and b is 5 and c is 50\n```\n:::\n:::\n\n\nThe function named `func` has one parameter without default value, followed by two parameters with default values.  \n\n- In the first usage, `func(3, 7)`, parameter `a` gets value 3, parameter `b` gets value 7, and `c` gets the default value 10.  \n- In the second usage, `func(25, c=24)`, 25 gets assigned to parameter `a` due to position. Then parameter `c` gets value 24 due to named arguments. Parameter `b` gets the default value 5.  \n- In the third usage, we use keyword arguments for all specified values.  \n- Note that although in the function definition, parameter `a` comes before parameter `c`, we can still assign a value to parameter `c` first before assigning to parameter `a`. This is a characteristic of keyword arguments.  \n\n## Variable Arguments  \n\nVariable arguments are a special kind of parameter that can accept any number of arguments. This is very useful in cases when you don't know beforehand how many arguments will be passed to the function, or the number varies.  \n\nIn Python, variable arguments are indicated by adding an asterisk (*) before the parameter name.  \n\n::: {#2a049e47 .cell execution_count=7}\n``` {.python .cell-code}\n# Code sample from: A Byte of Python\ndef total(a=5, *numbers, **phonebook):  \n    print('a', a)\n\n    # Traverse through all items in the tuple   \n    for single_item in numbers:\n        print('single_item', single_item)\n\n    # Traverse through all items in the dictionary     \n    for first_part, second_part in phonebook.items():\n        print(first_part,second_part)\n\ntotal(10, 1, 2, 3, Jack=1123, John=2231, Inge=1560)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na 10\nsingle_item 1\nsingle_item 2\nsingle_item 3\nJack 1123\nJohn 2231\nInge 1560\n```\n:::\n:::\n\n\n- When we declare a starred parameter like `*param`, all positional arguments from that point till the end will be collected into a tuple named 'param'.    \n- Similarly, when we declare a double-starred parameter like `**param`, all keyword arguments from that point till the end will be collected into a dictionary named 'param'.   \n- We can access these arguments inside the function just like traversing a normal tuple or dictionary.\n- A function can only have one variable argument, and it must come after all the positional and default parameters.  \n\n## The `return` Statement  \n\nThe `return` statement is used to return results from functions or end function execution.  \n\nInside a function, an expression after a `return` statement can have a value, and that value gets returned from the function.  \n\n::: {#ec11e701 .cell execution_count=8}\n``` {.python .cell-code}\n# Code sample from: A Byte of Python\ndef maximum(x, y):\n    if x > y:\n        return x  \n    elif x == y: \n        return 'The numbers are equal'\n    else:\n        return y\n\nprint(maximum(2, 3))  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n```\n:::\n:::\n\n\n- In this function, the `maximum` function uses a simple `if..else` statement to find the larger value and returns that value.   \n- In this case, if we call `maximum(2, 3)`, the return value of this function would be 3.\n- Note that once a `return` statement is executed, the function execution immediately stops and the code after it does not get executed.   \n- Note that a statement without a value is equivalent to `return None`. In Python, `None` is a special type indicating no value.\n- Every function implicitly has a `return None` at the end unless you have written a `return` statement yourself.  \n- There is a built-in function called `max` that already implements \"finding maximum value\" functionality. So use that built-in function wherever possible.  \n\n## Docstrings  \n\nDocstrings refer to documentation strings in Python that are a way of documenting functions, methods, classes, modules etc with an invaluable reference purpose.  \n\nDocstrings are located on the first line of function, method, class and module definitions, enclosed within a pair of triple quotes `\"\"\"` or `'''`, which can be single line or multi-line.  \n\n::: {#1fd6aedf .cell execution_count=9}\n``` {.python .cell-code}\n# Code sample from: A Byte of Python\ndef print_max(x, y):\n    '''Prints the maximum of two numbers.\n\n    The two values must be integers.'''  \n    # convert to integers, if possible\n    x = int(x)\n    y = int(y)\n\n    if x > y:\n        print(x, 'is maximum')\n    else: \n        print(y, 'is maximum')\n\nprint_max(3, 5)  \nprint(print_max.__doc__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 is maximum\nPrints the maximum of two numbers.\n\n    The two values must be integers.\n```\n:::\n:::\n\n\n- The convention for docstrings is to have a multi-line string where the first line starts with a capital letter and ends with a dot. Then the second line is blank, followed by any detailed explanation starting from the third line.   \n- It is strongly recommended that you follow this convention for docstrings in all non-trivial functions.   \n- In this example, we can access the docstring of function `print_max` with the `__doc__` attribute (note the double underscores) of that function.  \n- The functionality of Python's help() is to retrieve this `__doc__` attribute and present it in a neat manner. You can try `help(print_max)` to view the docstring for `print_max`.\n- Automated tools can retrieve documentation from your programs this way. So it is highly recommended to use docstrings when writing any non-trivial functions.  \n\n",
    "supporting": [
      "functions_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}