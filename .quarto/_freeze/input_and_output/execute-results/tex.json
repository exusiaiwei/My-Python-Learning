{
  "hash": "cebe579aa50044a4bbb732fd89c71fc9",
  "result": {
    "engine": "jupyter",
    "markdown": "# Input and Output\n\nUser interaction is a common and necessary part during programming. Python provides some simple and easy-to-use functions and methods for input/output operations like getting user input, outputting results to screen, generating and handling files etc.  \n\n## User Input  \nThe `input()` function accepts a string as argument which it prints out for the user, then waits for user input and hitting enter. Once the user inputs something and hits enter, the `input()` function returns the text input by the user.  \n\nSome notes:  \n\n- The `input()` function always returns the input as string. If you need an integer, you need to use the `int()` function to convert the returned string to integer.  \n- The `input()` function always returns a string. If you need a float number, you need to use the `float()` function to convert the returned string to float.   \n- The `input()` function can be used without arguments, in which case it just shows a simple colon prompt waiting for user input. It can also take a string argument which will be printed out as a prompt message for the user.  \n- When using the `input()` function, the program execution pauses and blocks before the user inputs something and hits enter. \n  - If you want to input passwords or other sensitive information, you may want the input content to not be shown. In this case you can use the `getpass()` function from the `getpass` module.  \n\nBelow are some sample code:\n\n\n```python\n# Example 1  \nname = input(\"What is your name? \")  \nprint(\"Hello, \" + name + \"!\")\n```  \n\n```python  \n# Example 2\ndef reverse(text):\n    return text[::-1]\n\ndef is_palindrome(text):\n    return text == reverse(text)\n\nsomething = input(\"Enter text: \")\nif is_palindrome(something):\n    print(\"Yes, it is a palindrome\")\nelse:\n    print(\"No, it is not a palindrome\") \n```  \n\n```python\n# Example 3  \nimport getpass\npassword = getpass.getpass(\"Enter your password: \")\nif password == \"12345\":\n    print(\"Access granted\")\nelse:\n    print(\"Access denied\")  \n```\n\n\n```python  \n# Example 4\ndef reverse(text):\n    return text[::-1]\ndef is_palindrome(text):\n    return text == reverse(text)\n    \nsomething = input(\"Enter text: \")\nfiltered_something = ''.join(c for c in something if c.isalnum()).lower() \nif is_palindrome(filtered_something):\n    print(\"Yes, it is a palindrome\")\nelse:\n    print(\"No, it is not a palindrome\")\n```\n\nThe following are some key points about the sample code above:\n\n- In Example 1, the `input()` function has a string argument that gets printed out as prompt for the user.  \n- In Example 2, the `input()` function has a string argument that gets printed out as prompt for the user. The input content is passed to the `reverse()` and `is_palindrome()` functions.  \n- In Example 2, we use slice notation to reverse the string. `text[::-1]` returns a reversed string. Slice notation syntax is `text[start:end:step]`. Default values are `start=0`, `end=len(text)`, `step=1`. A negative `step` value means slicing from right to left, reversing a string.  \n- In Example 3, we use the `getpass()` function from the `getpass` module to get password input from the user. This function does not show the user input.\n- In Example 4, we use the `isalnum()` method to check if the string only contains letters and numbers. The `isalnum()` method returns `True` if the string only contains letters and numbers, otherwise returns `False`. The `join()` method joins a list of strings into a new string.  \n\n## Files  \n\nPython provides some built-in functions and methods to allow us to create, open, read and write files. These operations are mainly achieved through the built-in `open()` function and methods of the file object.  \n\nBelow are some common file operations:  \n\n1. The `open` function: This is a built-in function used to open a file and return a file object.\n   1. The `open` function takes two arguments: file name (required) and mode (optional).  \n   2. The mode argument is a string indicating file open mode. Default value is `r` indicating read-only mode. Other options include `w` (write mode), `a` (append mode), `r+` (read and write mode) etc.  \n   3. `w` mode will create a new file, overwriting existing file if it already exists.  \n   4. In `r` mode, a file object's methods can only be used to read file content. In `w` mode, methods can only write content. In `a` mode, methods can only append content.   \n   5. To be able to read right after writing some content, need to open file in read and write mode (e.g. `r+` or `w+`).\n2. `read` method: Used to read file content.  \n   1. The `read` method takes an integer argument to specify number of bytes to read. If no argument is passed, `read()` reads entire file.\n   2. After reading/writing file content, the file object's pointer moves to end of file. To read content again, need to use `seek` method to move pointer back to start of file.  \n3. `write` method: Used to write content to the file. This method takes a string argument which gets written to the file.  \n4. `close` method: Used to close the file. After closing, any operations on the file object will fail.  \n\nBelow are some sample code:  \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfile1 = open(r\"practical_code\\input_and_output\\myfile.txt\", \"r\")\ncontent = file1.read()\nprint(content) \nfile1.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# This is a example of Python IO.\nAnd this is the second line.\n```\n:::\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfile2 = open(r\"practical_code\\input_and_output\\myfile2.txt\", \"w\")\nfile2.write(\"This is a test\")\nfile2.close()\n```\n:::\n\n\nWhen doing file operations, should always remember to close the file after finishing operation. To better manage file resources, Python provides the `with` statement that closes file automatically:  \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nwith open(r\"practical_code\\input_and_output\\myfile.txt\", \"r\") as file:\n    content = file.read()\n    print(content)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# This is a example of Python IO.\nAnd this is the second line.\n```\n:::\n:::\n\n\nBelow is a more complex example:  \n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\npoem = '''\\  \nProgramming is fun\nWhen the work is done  \nif you wanna make your work also fun:\n    use Python!  \n'''\nf = open(r\"practical_code\\input_and_output\\poem.txt\", \"w\") \nf.write(poem)\nf.close()\n\nf = open(r\"practical_code\\input_and_output\\poem.txt\", \"r\")\nwhile True:\n    line = f.readline()\n    if len(line) == 0:\n        break\n    print(line, end='')\nf.close() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\\  \nProgramming is fun\nWhen the work is done  \nif you wanna make your work also fun:\n    use Python!  \n```\n:::\n:::\n\n\nIn this sample code:\n\n- We first use the `open` function to create a file object, then use the `write` method to write some content.\n- Use the `readline` method to read file content. `readline` reads one line each time, returning a string. When reaching end of file, `readline` returns an empty string, i.e. `len(line) == 0`. We then use a `break` statement to exit the loop.\n- We use the `end=''` parameter to avoid adding a new line at the end of each line.\n\n## Pickle Module\n\nPickle is a standard Python module that is an important module in Python used for serializing and deserializing Python object structures.  \n\nThrough the Pickle module, Python object structures can be converted to a byte stream that contains all necessary information for reconstructing the original object. The process of converting to a byte stream is called \"pickling\", while the process of restoring the object from the byte stream is called \"unpickling\".  \n\n`Pickle` can handle almost all Python objects, including functions, classes, and even user-defined objects.\n\nThe concept of \"persistently storing objects\" generally refers to saving the state of objects in memory to persistent storage media such as hard drives, databases, or remote servers, etc. Then at a later time, even if the original program has stopped, this data can be read back into memory and restored as objects.\n\nThe functionality of the Pickle module is one important means of persistently storing objects. Through the pickle module, we can convert Python objects in memory into byte streams, then store these byte streams in files, databases, or send them over networks to other places. When we need them, we can convert these byte streams back into Python objects through unpickling operations.\n\nThe main methods for pickling and unpickling using the pickle module are:\n\n- `pickle.dumps(obj)`: Converts a Python object to a byte stream.  \n- `pickle.dump(obj, file)`: Converts a Python object to a byte stream and writes that byte stream to a file.\n- `pickle.loads(bytes_object)`: Restores an object from a byte string.\n- `pickle.load(file)`: Reads byte streams from a file and converts them to Python objects.\n\n\nBelow is a basic usage example of this module:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport pickle\n\ndata = {\n    'a': [1, 2.0, 3, 4+6j],\n    'b': (\"character string\", b\"byte string\"),\n    'c': {None, True, False}\n}\n\nwith open(r\"practical_code\\input_and_output\\data.pkl\", \"wb\") as f:\n    pickle.dump(data, f)\n\nwith open(r\"practical_code\\input_and_output\\data.pkl\", \"rb\") as f:\n    restored_data = pickle.load(f)\nprint(restored_data) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'a': [1, 2.0, 3, (4+6j)], 'b': ('character string', b'byte string'), 'c': {False, None, True}}\n```\n:::\n:::\n\n\nIn this example, we first use the `pickle.dump` method to convert a Python object to a byte stream and write that byte stream to a file. We then use the `pickle.load` method to read the byte stream from the file and convert it back to a Python object.\n\n## Unicode Characters and Encoding  \n\nIn Python 3, strings are Unicode strings. Unicode is a standard that defines the character set for text in all languages of the world. The Unicode character set covers all characters for all text in the world's writing systems, including Chinese, Japanese, Greek, Cyrillic characters etc. Each character has a unique Unicode code point which is an integer.   \n\nEncoding and decoding:  \n\n- The process of converting Unicode characters to byte streams is called encoding. In Python we can use the `encode` method to encode a Unicode string into a byte stream.\n- The process of converting byte streams back to Unicode characters is called decoding. We can use the `decode` method to decode a byte stream back into a Unicode string.  \n- A common encoding method is UTF-8 encoding.\n- When programming, if we need to deal with non-ASCII characters, we should always use Unicode strings. Only when we need to convert the Unicode string to a byte stream do we need to use encoding.  \n\nWhen writing a program using Unicode characters, we should ensure the program uses UTF-8 encoding. This way our program can handle text in all languages of the world.\n\n\nBelow is an example handling Unicode characters:  \n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nimport io\n\nf = io.open(r\"practical_code\\input_and_output\\zh_CN.txt\", \"wt\", encoding=\"utf-8\") \nf.write(u\"你好,世界!\")  \nf.close()\n\ntext = io.open(r\"practical_code\\input_and_output\\zh_CN.txt\", encoding=\"utf-8\").read()\nprint(text)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n你好,世界!\n```\n:::\n:::\n\n\nIn this sample code:   \n\n- In Python 3, the `io.open` function works exactly the same as the `open` function.  \n- But in Python 2, the `open` function does not support specifying encoding. In Python 2 we should use the `io.open` function to open files.\n- If we want the program to be compatible with both Python 2 and Python 3, we should use the `io.open` function to open files. But if we only need Python 3 compatibility, for simplicity we can just use the `open` function.\n\n",
    "supporting": [
      "input_and_output_files"
    ],
    "filters": []
  }
}