[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Python Studying",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\n(Swaroop?)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "5  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "basic.html",
    "href": "basic.html",
    "title": "2  Basic",
    "section": "",
    "text": "2.1 Data Types",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic</span>"
    ]
  },
  {
    "objectID": "basic.html#data-types",
    "href": "basic.html#data-types",
    "title": "2  Basic",
    "section": "",
    "text": "2.1.1 Literal Constants\nLiteral constants are fixed values that are directly written in the code and do not change during program execution.\nIn Python, there are several types of literal constants, including:\n\nNumeric literals: integers, floating-point numbers, and complex numbers.\nString literals: sequences of characters enclosed in single quotes (’’) or double quotes (““).\nBoolean literals: True and False.\nNone: a special constant that represents the absence of a value.\n\nLiteral constants are used to assign values to variables, perform calculations, and define conditions in Python programs.\nThey provide a way to represent fixed values directly in the code, making the program more understandable and maintainable.\n\nx = 10  # Assign an integer literal to the variable\ny = 3.14  # Assign a float literal to the variable\nname = 'John'  # String enclosed in single quotes\nmessage = \"Hello, world!\"  # String enclosed in double quotes\nis_active = True  # Assign a boolean literal to the variable\nempty_value = None  # Assign a None literal to the variable\n\n\n\n2.1.2 String\nThe string is a data type used to represent text data.\nFeatures:\n\nIn Python, you can specify a string with single or double quotes.\nTriple quotes can be used to specify a multi-line string.\nThe value of a string cannot be modified.\n\n\n# Create a string\nname = \"Alice\"\n\n# Concatenate strings\ngreeting = \"Hello, \" + name + \"!\"\n\n# Print the string\nprint(greeting)  # Output: Hello, Alice!\n\n# Get the length of the string\nlength = len(name)\nprint(length)  # Output: 5\n\n# Slice the string\nsubstring = name[1:3]\nprint(substring)  # Output: li\n\n# Replace in the string\nnew_name = name.replace(\"A\", \"B\")\nprint(new_name)  # Output: Blice\n\nHello, Alice!\n5\nli\nBlice\n\n\n\n2.1.2.1 String formatting function\nThe format function of a string can pass the corresponding parameters into the string.\n\nThe placeholder is {}\nCan specify the insertion order by index, python counts from 0.\nParameters can be named.\n\n\nname = \"Alice\"\nage = 25\n\n# Use placeholders to insert variables\ngreeting = \"Hello, my name is {} and I am {} years old.\".format(name, age)\nprint(greeting)  # Output: Hello, my name is Alice and I am 25 years old.\n\n# You can specify the order of insertion by index\ngreeting2 = \"Hello, my name is {1} and I am {0} years old.\".format(age, name)\nprint(greeting2)  # Output: Hello, my name is Alice and I am 25 years old.\n\n# You can use keyword parameters to specify the value to be inserted\ngreeting3 = \"Hello, my name is {name} and I am {age} years old.\".format(name=\"Alice\", age=25)\nprint(greeting3)  # Output: Hello, my name is Alice and I am 25 years old.\n\nHello, my name is Alice and I am 25 years old.\nHello, my name is Alice and I am 25 years old.\nHello, my name is Alice and I am 25 years old.\n\n\n\n\n\n2.1.3 Escape Sequences\nEscape sequences are a special sequence of characters that start with a backslash (\\) and are followed by one or more characters. They are used to represent non-printing characters, special characters, or characters with special meanings.\nEscape sequences start with a backslash (\\) and are followed by one or more characters to represent a specific character or operation. By using escape sequences, we can insert these special characters into strings, rather than interpreting them as ordinary characters.\nDefinition and Characteristics of Escape Sequences:\n\nEscape sequences start with a backslash (\\).\nEscape sequences are formed by one or more characters.\nEscape sequences are used to represent non-printing characters, special characters, or characters with special meanings.\nEscape sequences can be used in strings, character constants, regular expressions, and other contexts.\n\nHere are some common escape sequences and what they represent:\n\n\\n: newline\n\\t: tab\n\\r: carriage return\n\\': single quote\n\\\": double quote\n\\\\: backslash\n\n\n# Using escape sequences to represent special characters in strings:\nprint(\"Hello\\tWorld\")  # Output: Hello    World\nprint(\"I\\'m a programmer\")  # Output: I'm a programmer\nprint(\"She said, \\\"Hello!\\\"\")  # Output: She said, \"Hello!\"\nprint(\"\\\"I love you.\\\" \\n \\\"Me too.\\\"\")\n\n# Using escape sequences to match special characters in regular expressions:\nimport re\npattern = r\"\\d+\"  # Matches one or more digits\nresult = re.findall(pattern, \"12345\")\nprint(result)  # Output: ['12345']\n\nHello   World\nI'm a programmer\nShe said, \"Hello!\"\n\"I love you.\" \n \"Me too.\"\n['12345']",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic</span>"
    ]
  },
  {
    "objectID": "basic.html#variables",
    "href": "basic.html#variables",
    "title": "2  Basic",
    "section": "2.2 Variables",
    "text": "2.2 Variables\nA variable is a concept in Python that is used to store and manipulate data. It can store various types of data, such as integers, floating-point numbers, strings, etc.\nFeatures:\n\nYou can store data in a variable via an assignment operation.\nYou can use the variable name to access the data stored in the variable.\nThe value of a variable can be modified at any time.\nVariables can be used and passed at different locations in a program.\nThe scope of a variable can be limited within a specific block of code.\n\n\ni = 5\nprint(i)\n\ne = ( i + 1 ) * 2\n\nprint(e)\n\ns = '''This is a multi-line string.\nThis is the second line.'''\n\nprint(s)\n\n5\n12\nThis is a multi-line string.\nThis is the second line.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic</span>"
    ]
  },
  {
    "objectID": "basic.html#execution-logic",
    "href": "basic.html#execution-logic",
    "title": "2  Basic",
    "section": "2.3 Execution Logic",
    "text": "2.3 Execution Logic\n\n2.3.1 Logical Lines and Physical Lines\nA logical line refers to a line in the code that represents a statement or command, while a physical line refers to the text that actually occupies a line in the code file.\nA logical line can span multiple physical lines by connecting multiple physical lines into one logical line using line connectors (\\). A physical line is the actual number of lines in the code file, with each physical line ending with a newline character (\\n).\nFeatures of Logical Lines:\n\nA logical line can contain one or more statements or commands.\nLogical lines can span multiple physical lines.\nA logical line ends with a newline character (\\n).\n\nFeatures of Physical Lines:\n\nPhysical lines are the actual number of lines in the code file.\nEach physical line ends with a newline character (\\n).\n\nPython encourages each physical line to correspond to one logical line, that is, one statement per line, to ensure code readability.\n\n# Example of a logical line spanning multiple physical lines\nx = 1 + \\\n    2 + \\\n    3\n\nprint(x)\n\n# Example of logical lines being the same as physical lines\ny = 5\nprint(y)\n\ny = 5;\nprint(y);\n\ny = 5; print(y);\n\ny = 5; print(y)\n\n6\n5\n5\n5\n5\n\n\n\n\n2.3.2 Indentation\nIndentation is a syntax rule in Python used to represent the hierarchical structure of the code blocks. In Python, the indentation is mandatory and it determines the execution order and logical relations of the code. The level of indentation of the logical lines determines the grouping of the statements. Statements in the same group form a block of code.\nBasic Concepts:\n\nIndentation is achieved through the use of spaces or tabs.\nThe amount and style of indentation must remain consistent, typically four spaces are recommended for indentation.\nThe hierarchal structure of the indentation determines the nesting relation of the code blocks.\n\nFeatures:\n\nIndentation is used to define code blocks for functions, loops, conditional statements, and more.\nIndentation can enhance the readability and maintainability of the code.\nIndentation errors can lead to syntax errors or logical errors.\n\nCode Example: Here is one example where indentation forms blocks of code:\n\ndef greet(name):\n    if name == \"Alice\":\n        print(\"Hello, Alice!\")\n    else:\n        print(\"Hello, stranger!\")\n\ngreet(\"Bob\")\n\nHello, stranger!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic</span>"
    ]
  },
  {
    "objectID": "operators_and_expressions.html",
    "href": "operators_and_expressions.html",
    "title": "3  Operators and Expressions",
    "section": "",
    "text": "3.1 Operators",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Operators and Expressions</span>"
    ]
  },
  {
    "objectID": "operators_and_expressions.html#operators",
    "href": "operators_and_expressions.html#operators",
    "title": "3  Operators and Expressions",
    "section": "",
    "text": "3.1.1 1. Arithmetic Operators:\n\nAddition Operator (+): Used to add two values. It can handle numeric values, strings, and lists, among other types.\nSubtraction Operator (-): Used to subtract one value from another. If the first operand is missing, it defaults to 0.\nMultiplication Operator (*): Used to multiply two values. When used with strings, it returns a string repeated a fixed number of times.\nDivision Operator (/): Used to divide one value by another.\nModulus Operator (%): Used to calculate the remainder of two values divided.\nExponentiation Operator (**): Used to calculate the exponent of a value.\nFloor Division Operator (//): Used to calculate the integer part of the division of two values. The answer is rounded down to the nearest integer value; if either operand is a floating-point number, the answer will be a floating-point number.\n\n\n# Addition Operator\nx1 = 2 + 3\nprint(x1)\nx2 = \"a\" + \"b\"\nprint(x2)\n# Subtraction Operator\ny1 = 3 - 2\nprint(y1)\ny2 = - 2\nprint(y2)\n# Multiplication Operator\na1 = 5 * 6\nprint(a1)\na2 = \"my\" * 6\nprint(a2)\n# Division Operator\nb = 50 / 25\nprint(b)\n# Modulus Operator\nc1 = 26 % 3\nprint(c1)\nc2 = -25.5 % 2.25\nprint(c2)\n# Exponentiation Operator\nd= 2 ** 3\nprint(d)\n# Floor Division Operator\ne1 = 28 // 3\nprint(e1)\ne2 = 9//1.8\nprint(e2)\n\n5\nab\n1\n-2\n30\nmymymymymymy\n2.0\n2\n1.5\n8\n9\n4.0\n\n\n\n\n3.1.2 2. Comparison Operators:\n\nEquality Operator (==): Used to check if two values are equal.\nInequality Operator (!=): Used to check if two values are not equal.\nGreater Than Operator (&gt;): Used to check if one value is greater than another.\nLess Than Operator (&lt;): Used to check if one value is less than another.\nGreater Than or Equal Operator (&gt;=): Used to check if one value is greater than or equal to another.\nLess Than or Equal Operator (&lt;=): Used to check if one value is less than or equal to another.\n\n\na = 1 == 1\nprint(a)\nb = 1 != 1\nprint(b)\nc = 2 &gt; 1\nprint(c)\nd = 2 &lt; 1\nprint(d)\ne = 2 &gt;= 2\nprint(e)\nf = 1 &lt;= 2\nprint(f)\n\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\n\n\n\n\n3.1.3 3. Logical Operators (Boolean Operators):\n\nAnd Operator (and): Used to check if multiple conditions are all true. The result is true only when all conditions are true.\nOr Operator (or): Used to check if at least one condition is true. The result is true as long as one condition is true.\nNot Operator (not): Used to negate a condition.\n\n\n# Logical AND operator (and): The result is true only when all conditions are true\na = True and True\nprint(a)  # Output: True\n\nb = True and False\nprint(b)  # Output: False\n\n# Logical OR operator (or): The result is true as long as one condition is true\nc = True or False\nprint(c)  # Output: True\n\nd = False or False\nprint(d)  # Output: False\n\n# Logical NOT operator (not): Negates the condition\ne = not True\nprint(e)  # Output: False\n\nf = not False\nprint(f)  # Output: True\n\nTrue\nFalse\nTrue\nFalse\nFalse\nTrue\n\n\nShort-circuit evaluation: When using logical operators (such as and and or) to connect multiple conditional expressions, Python determines whether to evaluate all conditions based on the characteristics of the operator.\n\nIn the case of the and operator, if any condition is False, the entire expression will be False, and Python will stop evaluating the remaining values and immediately return False.\nIn the case of the or operator, if any condition is True, the entire expression will be True, and Python will stop evaluating the remaining values and immediately return True. Short-circuit evaluation can improve code efficiency and performance by avoiding unnecessary computations and evaluations.\n\n\n# Example of short-circuit evaluation\na = 4\nb = 0\n\nif b != 0 and a / b &lt; 1:\n    print(\"Condition is satisfied\")\nelse:\n    print(\"Condition is not satisfied\")\n\nCondition is not satisfied\n\n\nIn the above example, short-circuit evaluation is used to skip the division by zero operation (a / b) as the overall result is determined to be False at the step b != 0. This avoids the error that would occur if the division operation was executed without short-circuit evaluation.\n\n\n3.1.4 4. Bitwise Operators:\nBit: The smallest unit for storing and processing data. A bit can only hold two possible values: 0 or 1. Numbers in a computer are stored in binary form, which consists of 0s and 1s.\nBitwise Shift: Bitwise shift is an operation used to modify the value of a number by shifting its bits. There are two types of bitwise shifts: left shift and right shift. Left shift adds a 0 to the right end of the number, while right shift removes the rightmost bit.\n\nIn decimal, shifting one place to the left (adding a 0 at the end) is equivalent to multiplying by 10, and shifting one place to the right (removing the rightmost digit) is equivalent to dividing by 10.\nIn binary, shifting one place to the left (adding a 0 at the end) is equivalent to multiplying by 2, and shifting one place to the right (removing the rightmost bit) is equivalent to dividing by 2.\n\nBitwise Operators:\n\nBitwise AND Operator (&): Performs a bitwise AND operation on two values. If both corresponding bits are 1, the result is 1; otherwise, it is 0.\nBitwise OR Operator (|): Performs a bitwise OR operation on two values. If at least one of the corresponding bits is 1, the result is 1; otherwise, it is 0.\nBitwise XOR Operator (^): Performs a bitwise XOR operation on two values. If one of the corresponding bits is 1 and the other is 0, the result is 1; otherwise, it is 0 (i.e., the result is 0 if both bits are the same).\nBitwise NOT Operator (~): Performs a bitwise NOT operation on a value. It flips each bit, changing 0 to 1 and 1 to 0. The bitwise NOT of x is -(x+1).\nLeft Shift Operator (&lt;&lt;): Shifts a value to the left by a specified number of bits.\nRight Shift Operator (&gt;&gt;): Shifts a value to the right by a specified number of bits.\n\n\n# Define two variables\na = 60  # The binary representation of 60 is 0011 1100\nb = 13  # The binary representation of 13 is 0000 1101\n\nprint(a, \"in binary is\", bin(a))\nprint(b, \"in binary is\", bin(b))\n\nprint(\"a & b =\", a & b)  # Bitwise AND operation. The binary result is 0000 1100, which is 12 in decimal\nprint(\"a | b =\", a | b)  # Bitwise OR operation. The binary result is 0011 1101, which is 61 in decimal\nprint(\"a ^ b =\", a ^ b)  # Bitwise XOR operation. The binary result is 0011 0001, which is 49 in decimal\nprint(\"~a =\", ~a)  # Bitwise NOT operation. The binary result is 1100 0011, which is -61 in decimal (note: it is a negative number)\n\nprint(\"a &lt;&lt; 2 =\", a &lt;&lt; 2)  # Left shift operation by 2 bits. The binary result is 1111 0000, which is 240 in decimal\nprint(\"a &gt;&gt; 2 =\", a &gt;&gt; 2)  # Right shift operation by 2 bits. The binary result is 0000 1111, which is 15 in decimal\n\n60 in binary is 0b111100\n13 in binary is 0b1101\na & b = 12\na | b = 61\na ^ b = 49\n~a = -61\na &lt;&lt; 2 = 240\na &gt;&gt; 2 = 15\n\n\n\n\n3.1.5 5. Assignment Operator：\n\nAddition Assignment Operator (+=): Used to add a value to a variable and assign the result to that variable.\nSubtraction Assignment Operator (-=): Used to subtract a value from a variable and assign the result to that variable.\nMultiplication Assignment Operator (*=): Used to multiply a value with a variable and assign the result to that variable.\nDivision Assignment Operator (/=): Used to divide a value by a variable and assign the result to that variable.\nModulus Assignment Operator (%=): Used to calculate the remainder of two values divided and assign the result to a variable.\nExponentiation Assignment Operator (**=): Used to calculate the exponent of a value and assign the result to a variable.\nFloor Division Assignment Operator (//=): Used to calculate the integer part of two values divided and assign the result to a variable.\n\n\n# Simple Assignment Operator (=)\na = 10\nprint(\"a =\", a)  # Output: a = 10\n\n# Addition Assignment Operator (+=)\na += 2\nprint(\"a =\", a)  # Output: a = 12\n\n# Subtraction Assignment Operator (-=)\na -= 2\nprint(\"a =\", a)  # Output: a = 10\n\n# Multiplication Assignment Operator (*=)\na *= 2\nprint(\"a =\", a)  # Output: a = 20\n\n# Division Assignment Operator (/=)\na /= 2\nprint(\"a =\", a)  # Output: a = 10.0\n\n# Modulus Assignment Operator (%=)\na %= 3\nprint(\"a =\", a)  # Output: a = 1.0\n\n# Exponentiation Assignment Operator (**=)\na **= 3\nprint(\"a =\", a)  # Output: a = 1.0\n\n# Floor Division Assignment Operator (//=)\na = 10\na //= 3\nprint(\"a =\", a)  # Output: a = 3\n\na = 10\na = 12\na = 10\na = 20\na = 10.0\na = 1.0\na = 1.0\na = 3",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Operators and Expressions</span>"
    ]
  },
  {
    "objectID": "operators_and_expressions.html#expressions",
    "href": "operators_and_expressions.html#expressions",
    "title": "3  Operators and Expressions",
    "section": "3.2 Expressions",
    "text": "3.2 Expressions\nAn expression is a combination of operators and operands used to calculate and generate values.\nIn Python, expressions can be simple arithmetic expressions or complex logical expressions.\nFor example, here are some common examples of expressions:\n\nArithmetic expression: 2 + 3 * 4\nLogical expression: (x &gt; 5) and (y &lt; 10)\nString concatenation expression: ‘Hello’ + ‘World’\nList comprehension expression: [x for x in range(10) if x % 2 == 0]\n\nThe value of an expression is calculated based on the types of operands and the rules of operators. When evaluating an expression, Python determines the order of operations based on certain precedence and associativity rules.\n\n3.2.1 Order of Evaluation\nSimilar to how multiplication has higher precedence than addition in mathematics, expressions in Python also have different levels of precedence. Python evaluates operators and expressions with higher precedence first, and then evaluates expressions with lower precedence.\nFor complex expressions, although you can rely on remembering the precedence rules to ensure the correct order of operations, it is generally recommended to use parentheses explicitly to indicate the order of evaluation for clarity and readability.\nIn cases where operators have the same precedence, the order of evaluation is determined by their associativity. Associativity can be left-associative or right-associative. - Left-associative means evaluation proceeds from left to right. Common examples include arithmetic operators (such as addition, subtraction, multiplication, division, etc.), comparison operators, and most bitwise operators. - Right-associative means evaluation proceeds from right to left. Common examples include exponentiation operator, assignment operator (=), and compound assignment operators (such as +=, -=, *=, /=, %=, **=, //=, &=, ^=, &gt;&gt;=, &lt;&lt;=).\n\n# Left-associative\nprint(1 - 2 + 3)  # Output: 2\n\n# Right-associative\n# For the exponentiation operator, Python evaluates from right to left\n# So it first calculates 4**2, which is 16, and then calculates 2**16\nprint(2 ** 4 ** 2)  # Output: 65536\n# Explicitly specify the order of evaluation\nprint((2 ** 4) ** 2)  # Output: 256\n\n2\n65536\n256\n\n\n\n\n3.2.2 Mathematical Operations and Shortcut for Assignment\nA common practice is to perform mathematical operations on variables and then assign the result back to the variable, and there is a shortcut for this type of expression.\n\na = 2\na = a * 3\nprint(\"a =\", a)\n\nb = 2\nb *= 3\nprint(\"b =\", b)\n\na = 6\nb = 6",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Operators and Expressions</span>"
    ]
  },
  {
    "objectID": "control_flow.html",
    "href": "control_flow.html",
    "title": "4  Control Flow",
    "section": "",
    "text": "4.1 if Statement\nConditional statements allow different code blocks to be executed based on the truth or falsehood of a condition. The if statement is used to execute a code block when a condition is true, while the else statement is used to execute a code block when a condition is false.\n# The sample code comes from A Byte of Python\n# Here we define the guess value directly, instead of obtaining it through input\n# This is because environments like Quarto and Jupyter Notebook can't handle intermediate input (input function)\n# Such environments are designed to execute code in bulk. Once all cells start executing, they can complete all runs without human intervention\n# Therefore, we directly set a value here, instead of obtaining it through input\nguess = 20  \n\nnumber = 23\n\nprint('Your guess is:', guess)\n\nif guess == number:\n    print('Congratulations, you guessed it right.')\n    print('(But you did not win any prize!)')\nelif guess &lt; number:\n    # Another code block\n    print('No, it is a little bit larger than that.')\n    # You can do anything you want to do in the code block...\nelse:\n    print('No, it is a little bit smaller than that.')\n    # You will only get here if your guess is greater than number\n\nprint('Done')\n# This last statement will always be executed,\n# after if statement.\n\n# If you want to obtain user input in other environments (such as standard Python environment or IDLE),\n# You can change the fifth line of code to \"guess = int(input('Enter an integer:'))\".\n# This way, you can receive user input as the value of 'guess', and then perform subsequent judgement.\n\nYour guess is: 20\nNo, it is a little bit larger than that.\nDone\nThe knowledge points in the example code:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "control_flow.html#if-statement",
    "href": "control_flow.html#if-statement",
    "title": "4  Control Flow",
    "section": "",
    "text": "The input function prints a string to the screen and waits for input. After the input is entered, the input() function returns the input as a string.\nint is a class, and here it is used to convert a string to an integer. If you need to convert to a float, you can use float.\nIndentation is used to classify statements into different code blocks. Consistent indentation should be followed.\nif, elif, and else statements must have a colon at the end of the logical line, followed by the corresponding code block.\nThe elif statement combines two related if else-if else statements into a single if-elif-else statement. It can simplify the program and reduce indentation.\nIt is possible to nest one if statement inside another if statement, which is called a nested if statement.\nelif and else statements are optional. An if statement can be effective with only the if part.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "control_flow.html#while-statement",
    "href": "control_flow.html#while-statement",
    "title": "4  Control Flow",
    "section": "4.2 while Statement",
    "text": "4.2 while Statement\nThe while statement allows a set of statements to be repeatedly executed as long as a condition is true. The while statement is a type of loop statement and can include an optional if statement.\n\n# The sample code comes from A Byte of Python\nnumber = 23\nrunning = True\n\n# As we can't use input() function in Quarto or Jupyter Notebook, we set up a preset guess list here\nguesses = [20, 25, 23]  \nguesses_iter = iter(guesses)  # Create an iterator \n\nwhile running:\n    # In Quarto and Jupyter Notebook, 'input()' function needs to be rewritten as iterating guess value from preset list\n    guess = next(guesses_iter)\n    print('Your guess is:', guess)\n\n    if guess == number:\n        # If the guess value equals to set value, it will print that you guess right and end the while loop\n        print('Congratulations! You guess it right.')\n        running = False\n    elif guess &lt; number:\n        # It will also show that the preset guess value is too low\n        print('No, it is a little higher than that.')\n    else:\n        # It will also show that the preset guess value is too high\n        print('No, it is a little lower than that.')\n\nprint('Done')\n\n# When the iterator 'guesses_iter' traverse all guesses, the program will end\n# If you are running it in a real Python environment or IDLE, you can comment out the line 'guess = next(guesses_iter)'\n# and uncomment the line 'guess = int(input('Enter an integer : '))', and also comment out 'guesses' and 'guesses_iter'\n# Then it can achieve the continuous guessing of the user through the user input and continuous while loop\n\nYour guess is: 20\nNo, it is a little higher than that.\nYour guess is: 25\nNo, it is a little lower than that.\nYour guess is: 23\nCongratulations! You guess it right.\nDone\n\n\nThe knowledge points in the example code:\n\nBy setting the variable running to True before the while loop, the program checks if the variable running is True before executing the corresponding while block.\nAfter executing the block, the condition (i.e., the variable running) is checked again.\nIf the condition is true, the while block is executed again.\nIf the condition is false, the optional else block is executed, and then the next statement is continued.\nIf a while loop has an else clause, it will always be executed unless the loop is exited using a break statement.\nTrue and False are called boolean types and can be considered as equivalents of the values 1 and 0, respectively.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "control_flow.html#for-loop",
    "href": "control_flow.html#for-loop",
    "title": "4  Control Flow",
    "section": "4.3 for Loop",
    "text": "4.3 for Loop\nThe for..in statement is another type of loop statement that iterates over an object sequence, i.e., it iterates over each item in the sequence one by one.\nAt this point, a sequence can be seen as an ordered collection of items.\n\n# Example code from A Byte of Python\nfor i in range(1, 5):\n    print(i)\nelse:\n    print('The for loop is over')\n\n1\n2\n3\n4\nThe for loop is over\n\n\nThe knowledge points in the example code are as follows:\n\nThe built-in function range can generate a sequence of numbers.\nBy default, the step size of range is 1. The third number provided to range will be the step size, for example, range(1,5,2) gives [1,3]. The second number (i.e., the end number) is not included.\nrange generates only one number at a time. If you need the complete list of numbers, you need to call list().\nThe else part in a for loop is optional. If included, it will always be executed unless the loop is exited using the break statement.\nAlthough the example code only demonstrates a list of numbers, the for loop can be used with sequences composed of objects of any type.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "control_flow.html#break-statement",
    "href": "control_flow.html#break-statement",
    "title": "4  Control Flow",
    "section": "4.4 break statement",
    "text": "4.4 break statement\nThe break statement is called a jump statement, which can stop the execution of a loop statement even if the loop condition is not False or the sequence of items has not been fully iterated.\nIf a for or while loop is exited using break, the corresponding else block of the loop will not be executed.\n\n# The sample code comes from A Byte of Python\n# Set up a preset input list\ninputs = ['Hello', 'abcdef', '12345', 'quit']\n\n# Create an iterator\ninputs_iter = iter(inputs)\n\nwhile True:\n    # Get the input from the preset input list\n    s = next(inputs_iter)\n\n    print('The input string is: ', s)\n    if s == 'quit':\n        break\n    print('The length of the string is', len(s))\nprint('Done')\n\n# Here we use a preset input list and iterator to simulate user input\n# In each loop, we get an input from the list and check whether the input is 'quit'. If yes, we break the loop.\n# Otherwise, we print out the length of the input\n# This way, we can run the code in an environment like Quarto or Jupyter Notebook that does not support input()\n# If you want to run it in a real Python environment or IDLE,\n# you can comment out the line 's = next(inputs_iter)', uncomment the line 's = input('Enter something: ')',\n# also comment out 'inputs' and 'inputs_iter', and it will be back to its original state.\n\nThe input string is:  Hello\nThe length of the string is 5\nThe input string is:  abcdef\nThe length of the string is 6\nThe input string is:  12345\nThe length of the string is 5\nThe input string is:  quit\nDone\n\n\nThe knowledge points in the example code are as follows:\n\nThe built-in function len can measure the length of an input string.\nThe break statement can also be used with a for loop.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "control_flow.html#continue-statement",
    "href": "control_flow.html#continue-statement",
    "title": "4  Control Flow",
    "section": "4.5 continue statement",
    "text": "4.5 continue statement\nThe continue statement is used to skip the remaining statements in the current loop block and continue with the next iteration of the loop.\n\n# The sample code comes from A Byte of Python\n# Set up a preset input list\ninputs = ['Hello', 'abcdef', '12', '1234', 'quit']\n\n# Create an iterator\ninputs_iter = iter(inputs)\n\nwhile True:\n    # Get input from the preset input list\n    # s = input('Enter something : ')\n    s = next(inputs_iter)\n\n    print('The input string is: ', s)\n    if s == 'quit':\n        break\n    if len(s) &lt; 3:\n        print('Too short')\n        continue\n    print('Input length is sufficient')\n    # You can do anything you want to do in the code block...\nprint('Done')\n\n# This code can run smoothly in both Quarto and Jupyter environments. In each loop, \n# it will get an input from the preset string list and then perform different operations based on the length of this input:\n# 1. If the input is 'quit', then it will end the entire loop;\n# 2. If the length of the input is less than 3, then it will print 'Too short', and skip the rest of the current loop, and directly start the next loop;\n# 3. If the length of the input is not less than 3, then it will print 'Input length is sufficient'.\n\nThe input string is:  Hello\nInput length is sufficient\nThe input string is:  abcdef\nInput length is sufficient\nThe input string is:  12\nToo short\nThe input string is:  1234\nInput length is sufficient\nThe input string is:  quit\nDone",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  }
]