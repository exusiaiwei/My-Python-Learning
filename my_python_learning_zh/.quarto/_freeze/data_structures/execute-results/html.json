{
  "hash": "fcbd5e290bab0d9b0031c5a011a2e003",
  "result": {
    "engine": "jupyter",
    "markdown": "# 数据结构\n\n![python数据结构](fig/python_data_structure.png)\n\n## 序列（Sequence）\n\n在Python中，序列(Sequence)是最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。\n\nPython有三种常见的序列类型：\n\n- 列表（List）\n- 元组（Tuple）\n- 字符串（String）\n\n另外三种非序列的数据结构是：\n\n- 集合（Set）\n- 字典（Dictionary）\n- 冰冻集合（frozenset）\n\n这三种类型并非有序，也不能通过索引访问元素。\n\n## 列表（List）\n\nPython 的列表类似于其他编程语言中的数组，但是比这些数组更灵活。列表中的元素不一定要是相同的数据类型。\n\n列表用方括号 `[]` 包围元素，并用逗号 `,` 分割。\n\n::: {#97b7607e .cell execution_count=1}\n``` {.python .cell-code}\nmy_list = [1, \"apple\", 3.14]\nprint(my_list[0]) # prints: 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n```\n:::\n:::\n\n\n列表：\n\n- 是有序的\n- 是可变的\n- 可以包含任何类型的元素\n- 可以通过索引访问元素，索引从0开始\n\n::: {.callout-tip}\n## 索引\n注意, Python的索引是从0开始。这意味着在使用索引访问列表元素时，列表中的第一个元素是 `list[0]`，第二个元素是 `list[1]`，以此类推。\n\n此外，索引是前包含后不包含的。`word[1:3]`这样的索引意味着从索引1开始，直到索引3之前的元素（即索引1和2）。\n:::\n\n\n## 元组（Tuple）\n\n元组是有序的、不可变的列表。可以理解为一种“只读”版本的列表。\n\n元组用括号 `()` 包围元素，并用逗号 `,` 分割。\n\n::: {#202564ae .cell execution_count=2}\n``` {.python .cell-code}\nmy_tuple = (1, \"apple\", 3.14)\nprint(my_tuple[0]) # prints: 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n```\n:::\n:::\n\n\n元组：\n\n- 是有序的\n- 是不可变的\n- 可以包含任何类型的元素\n- 可以通过索引访问元素，索引从0开始\n\n下面是一个体现元组和列表的差别的代码示例\n\n::: {#ce1606f7 .cell execution_count=3}\n``` {.python .cell-code}\n# 创建一个列表\nmy_list = [1, 2, 3]\n# 在列表末尾添加一个元素\nmy_list.append(4)\nprint(my_list[3])\n# 创建一个元组\nmy_tuple = (1, 2, 3)\n# 不能修改元组\n# my_tuple.append(4)  # 这样会报错\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n:::\n\n\n## 集合（Set）\n\n集合是非有序的数据结构，它不允许重复元素。\n\n集合用花括号`{}`包围元素，并用逗号 `,` 分割。\n\n::: {#83706a8c .cell execution_count=4}\n``` {.python .cell-code}\nmy_set = {1, \"apple\", 3.14, \"apple\"}\nprint(my_set) # prints: {1, \"apple\", 3.14}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'apple', 1, 3.14}\n```\n:::\n:::\n\n\n集合:\n\n- 是无序的\n- 集合中元素不能重复\n- 可以包含任何类型的元素\n- 不能通过索引访问元素\n\n## 字典（Dictionary）\n\n字典是一个无序的键值对集合。\n\n\"键值对\"（Key-Value Pair）指的是两个关联的部分：一个是唯一的键（Key），另一个是值（Value）。每个键都有一个关联的值。这种关联叫做\"映射\"。\n\n字典使用花括号`{}`包围元素，键值之间用冒号`:`分隔，而键值对之间用逗号`,`分隔。\n\n::: {.callout-tip}\n# 为什么叫字典\n\n在一本实体字典中，你可以根据词条（对应于计算机中的“键”）找到对应的解释或者翻译（对应于计算机中的“值”）。这构成了一个\"词条-解释\"对，与计算机科学中的\"键-值对\"类似。\n\n因此，考虑到这种映射关系，计算机科学中的这种包含\"键-值对\"的数据结构，就被命名为字典（Dictionary）。\n:::\n\n::: {#31066e2e .cell execution_count=5}\n``` {.python .cell-code}\nmy_dict = {\n    \"name\": \"apple\",\n    \"color\": \"red\",\n}\nprint(my_dict[\"name\"]) # prints: apple\n\nages = {\n    \"Tom\": 30, \n    \"Alice\": 25, \n    \"Bob\": 27\n}\n\nprint(ages[\"Alice\"]) # 输出：25\nages[\"Tom\"] = 31  # 将Tom的年龄改为31\nprint(ages[\"Tom\"]) # 输出：31\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple\n25\n31\n```\n:::\n:::\n\n\n字典:\n\n- 是无序的\n- 键值对中的键是唯一的,但值可以重复\n- 可以包含任何类型的元素\n- 通过键来访问元素\n\n当你使用一个键来访问一个字典时，Python会返回与该键相关联的值。如果你使用一个不存在的键，Python会引发一个`KeyError`异常。\n\n为了避免这一点，可以使用`get()`方法。`get(key, default) `方法允许指定一个默认值，当字典中不存在指定的键时，它会返回该默认值而不是引发异常。\n\n## 对象（Object）和类（Class）{#sec-objects-and-classes}\n\nPython是一种面向对象的编程语言。在Python中，几乎所有的东西都是对象，拥有其属性和方法。类(Class)就是为创建对象的种类或类型提供了定义的一种机制。\n\n对象(Object)：在Python中，对象是数据的核心单元。每个对象都具有一个类型（例如，字符串，列表，字典等），以及一个独一无二的身份（在内存中的地址）。对象可以包含包含多种数据（即属性）和功能（即方法）。它可以视为现实世界中的客观实体，比如一张桌子、一个圆形、一个人等。\n\n举例来说，一个人（对象）有姓名（属性）和能进行各种活动（方法）如跑步、学习等。\n\n\n类(Class)：类是对象的模板或蓝图。它定义了对象的基本结构，并封装了对象需要执行的行为（方法）。你可以定义一个类来创建属于这个类的对象。类就相当于制造物件的工厂，负责规定其生产出的对象应该拥有哪些特性。\n\n\n举例来说，你可以定义一个“人”的类（class），它有名字和年龄等属性，也有吃饭，睡觉等方法。然后根据这个“人”类，我们可以创建不同的人对象，比如创建一个名叫“张三”、年龄25岁的人对象。\n\n::: {#a1cd21be .cell execution_count=6}\n``` {.python .cell-code}\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def introduce(self):\n        return f\"Hello, my name is {self.name} and I am {self.age} years old.\"\n\n# 创建一个属于Person类的对象\nsomeone = Person('张三', 25)\n\n# 调用对象的方法\nprint(someone.introduce())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, my name is 张三 and I am 25 years old.\n```\n:::\n:::\n\n\n## 引用\n\n在Python中，每当你创建一个对象并将其赋值给一个变量时，Python并不会将对象的值存储在变量中。相反，Python仅仅是将变量设置为一个引用，指向存储在内存中的对象。这种方式被称为绑定变量名到对象，或者叫做引用。\n\n### 创建对象和引用\n\n\n举个例子，当你创建一个列表并赋值给某个变量：\n\n::: {#9d46291e .cell execution_count=7}\n``` {.python .cell-code}\nlist1 = [1, 2, 3]\n```\n:::\n\n\n此时，list1只是一个引用，它指向存储在内存中的一个列表对象，此对象包含元素1, 2, 3。如果你再创建一个引用，并指向同样的对象：\n\n::: {#8c578ed1 .cell execution_count=8}\n``` {.python .cell-code}\nlist2 = list1\n```\n:::\n\n\n此时你有两个引用——list1和list2，它们同时指向同一个对象。\n\n\n### 修改可变类型的对象\n\n\n如果你通过其中一个引用去修改这个对象，例如你通过list1去删除第一个元素：\n\n::: {#3c1d4f96 .cell execution_count=9}\n``` {.python .cell-code}\ndel list1[0]\n```\n:::\n\n\n那么无论你是通过list1还是list2来访问这个列表对象，你都会发现的此对象的内容已经发生了变化：\n\n::: {#07610314 .cell execution_count=10}\n``` {.python .cell-code}\nprint(list1)  # 输出: [2, 3]\nprint(list2)  # 输出: [2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 3]\n[2, 3]\n```\n:::\n:::\n\n\n这是因为list1和list2都只是引用，它们并不包含实际的列表内容，而只是指向内存中的一个位置，即同一个列表对象的地址。\n\n\n### 对象的复制\n\n\n然而，有时你可能需要创建一个对象的副本，这样你就可以修改这个副本，而不影响原来的对象。例如，通过切片操作可以创建一个列表的副本：\n\n::: {#eabdb6ed .cell execution_count=11}\n``` {.python .cell-code}\nlist3 = list2[:]\n```\n:::\n\n\n此时list3引用的是一个完全新的列表对象，这个对象的内容是list2所指向的列表的一个完全的拷贝。所以，当你更改list3的内容时，list2指向的列表内容不会被修改：\n\n::: {#698ee44f .cell execution_count=12}\n``` {.python .cell-code}\ndel list3[0]\nprint(list2)  # 输出: [2, 3]\nprint(list3)  # 输出: [3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 3]\n[3]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "data_structures_files"
    ],
    "filters": [],
    "includes": {}
  }
}