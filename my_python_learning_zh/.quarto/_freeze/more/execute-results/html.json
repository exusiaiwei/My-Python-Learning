{
  "hash": "f204510ad217d974cfeee8cca8e69843",
  "result": {
    "engine": "jupyter",
    "markdown": "# 更多\n\n这里将用来记载我在实际使用Python中遇到的问题和知识点。\n\n（现在，这里还空无一物\n\n## 字符串方法\n\n字符串实现了所有常见的序列操作，如索引、切片、连接、重复、成员资格检查等。此外，字符串还提供了一些特有的方法，用于查找、替换、大小写转换等。\n\n在Python中，常用的字符串方法有：\n\n- `str.startswith(prefix[, start[, end]])`：检查字符串是否以指定的前缀开头。\n- `str.endswith(suffix[, start[, end]])`：检查字符串是否以指定的后缀结尾。\n- `str.title()`：将字符串中的每个单词的首字母大写。\n- `str.upper()`：将字符串中的所有字母大写。\n- `str.lower()`：将字符串中的所有字母小写。\n- `str.strip([chars])`：去除字符串首尾的指定字符。如果不指定参数，则默认去除空白字符。\n- `str.lstrip([chars])`：去除字符串开头的指定字符。如果不指定参数，则默认去除空白字符。\n- `str.rstrip([chars])`：去除字符串结尾的指定字符。如果不指定参数，则默认去除空白字符。\n- `str.replace(old, new[, count])`：将字符串中的指定子串替换为新的子串。\n- `str.removeprefix(prefix)`：去除字符串开头的指定前缀。\n- `str.removesuffix(suffix)`：去除字符串结尾的指定后缀。\n\n\n## Python 推导式（Comprehensions）\n\nPython 推导式是一种简洁且功能强大的语法，用于创建新的序列（如列表、集合、字典）或生成器。推导式允许你在一行代码中将循环和条件语句组合起来，提高代码的可读性和效率。\n\nPython 提供了四种类型的推导式：\n\n1. 列表推导式（List Comprehension）\n2. 集合推导式（Set Comprehension）\n3. 字典推导式（Dictionary Comprehension）\n4. 生成器表达式（Generator Expression）\n\n### 列表推导式（List Comprehension）\n\n列表推导式用于创建新的列表。其语法如下：\n\n```python\n[expression for item in iterable if condition]\n```\n\n- `expression`：表达式，用于对每个元素进行操作或转换。\n- `item`：迭代器变量，表示当前迭代的元素。\n- `iterable`：可迭代对象，如列表、元组、字符串等。\n- `if condition`：可选的条件语句，用于过滤元素。\n\n示例：\n\n::: {#bb34e7ae .cell execution_count=1}\n``` {.python .cell-code}\nsquares = [x ** 2 for x in range(1, 6)]\n# 输出：[1, 4, 9, 16, 25]\n```\n:::\n\n\n### 集合推导式（Set Comprehension）\n\n集合推导式用于创建新的集合。其语法与列表推导式类似，但使用大括号 `{}` 而不是方括号 `[]`。\n\n```python\nunique_squares = {x ** 2 for x in [1, 1, 2, 3, 3, 4]}\n# 输出：{1, 4, 9, 16}\n```\n\n### 字典推导式（Dictionary Comprehension）\n\n字典推导式用于创建新的字典。其语法如下：\n\n```python\n{key_expression: value_expression for item in iterable if condition}\n```\n\n- `key_expression`：表达式，用于生成字典的键。\n- `value_expression`：表达式，用于生成字典的值。\n- `item`、`iterable` 和 `if condition` 的含义与列表推导式相同。\n\n示例：\n\n::: {#e0df0f6d .cell execution_count=2}\n``` {.python .cell-code}\nsquare_dict = {x: x ** 2 for x in range(1, 6)}\n# 输出：{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n```\n:::\n\n\n### 生成器表达式（Generator Expression）\n\n生成器表达式用于创建生成器对象。其语法与列表推导式类似，但使用圆括号 `()` 而不是方括号 `[]`。生成器表达式是延迟计算的，只有在需要时才会生成数值，因此对于大型数据集或无限序列非常有用。\n\n::: {#82555ab8 .cell execution_count=3}\n``` {.python .cell-code}\nsquare_generator = (x ** 2 for x in range(1, 6))\nfor square in square_generator:\n    print(square)\n# 输出：\n# 1\n# 4\n# 9\n# 16\n# 25\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n4\n9\n16\n25\n```\n:::\n:::\n\n\n值得注意的是，生成器表达式并不局限于生成特定的值序列。它可以根据需求生成任意类型的对象，如字符串、元组、集合等，甚至是常量值。\n\n下面是一个例子：\n\n::: {#8fb7c4e4 .cell execution_count=4}\n``` {.python .cell-code}\ndef count_failed_students(student_scores):\n    \"\"\"Count the number of failing students out of the group provided.\n\n    :param student_scores: list - containing int student scores.\n    :return: int - count of student scores at or below 40.\n    \"\"\"\n    return sum(1 for score in student_scores if score <= 40)\n```\n:::\n\n\n在这个函数里，我们需要统计学生成绩中不及格的人数。我们使用了生成器表达式 `sum(1 for score in student_scores if score <= 40)` 来计算不及格的学生人数。这里的生成器表达式返回的是一个生成器对象，它会在迭代时逐个生成值 1，最终通过 `sum()` 函数将这些值相加得到不及格的学生人数。\n\n这种用法可能不太常见，但它展示了生成器表达式的灵活性。它不仅可以生成基于表达式的值序列，还可以根据条件生成常量值，用于计数、过滤或其他目的。\n\n### 嵌套推导式\n\n推导式还可以嵌套使用，以生成更复杂的结构。例如，你可以使用嵌套的列表推导式来创建矩阵：\n\n::: {#4e4f5eb5 .cell execution_count=5}\n``` {.python .cell-code}\nmatrix = [[i * j for j in range(1, 4)] for i in range(1, 4)]\n# 输出：[[1, 2, 3], [2, 4, 6], [3, 6, 9]]\n```\n:::\n\n\n### 总结\n\n推导式是 Python 中一种强大且表达力强的特性，可以简化代码并提高可读性。它们允许你在一行代码中将循环和条件语句组合起来，用于创建新的列表、集合、字典或生成器。\n\n理解和使用推导式是编写 Pythonic 代码的重要部分。合理运用推导式可以使你的代码更加简洁、优雅和高效。\n\n",
    "supporting": [
      "more_files"
    ],
    "filters": [],
    "includes": {}
  }
}